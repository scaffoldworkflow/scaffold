
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">scaffold/server/api/auth.go (33.3%)</option>
				
				<option value="file1">scaffold/server/api/datastore.go (0.0%)</option>
				
				<option value="file2">scaffold/server/api/file.go (0.0%)</option>
				
				<option value="file3">scaffold/server/api/health.go (0.0%)</option>
				
				<option value="file4">scaffold/server/api/helpers.go (36.4%)</option>
				
				<option value="file5">scaffold/server/api/history.go (0.0%)</option>
				
				<option value="file6">scaffold/server/api/input.go (0.0%)</option>
				
				<option value="file7">scaffold/server/api/run.go (0.0%)</option>
				
				<option value="file8">scaffold/server/api/state.go (0.0%)</option>
				
				<option value="file9">scaffold/server/api/task.go (0.0%)</option>
				
				<option value="file10">scaffold/server/api/user.go (57.6%)</option>
				
				<option value="file11">scaffold/server/api/webhook.go (0.0%)</option>
				
				<option value="file12">scaffold/server/api/workflow.go (59.6%)</option>
				
				<option value="file13">scaffold/server/auth/auth.go (9.0%)</option>
				
				<option value="file14">scaffold/server/config/config.go (66.7%)</option>
				
				<option value="file15">scaffold/server/cron/cron.go (8.9%)</option>
				
				<option value="file16">scaffold/server/datastore/datastore.go (37.2%)</option>
				
				<option value="file17">scaffold/server/docs/docs.go (100.0%)</option>
				
				<option value="file18">scaffold/server/filestore/filestore.go (11.9%)</option>
				
				<option value="file19">scaffold/server/history/history.go (0.0%)</option>
				
				<option value="file20">scaffold/server/input/input.go (38.2%)</option>
				
				<option value="file21">scaffold/server/main.go (82.1%)</option>
				
				<option value="file22">scaffold/server/manager/manager.go (7.9%)</option>
				
				<option value="file23">scaffold/server/middleware/middleware.auth.go (21.8%)</option>
				
				<option value="file24">scaffold/server/middleware/middleware.cors.go (77.8%)</option>
				
				<option value="file25">scaffold/server/mongodb/mongodb.go (80.0%)</option>
				
				<option value="file26">scaffold/server/page/common/common.go (0.0%)</option>
				
				<option value="file27">scaffold/server/page/dashboard.go (0.0%)</option>
				
				<option value="file28">scaffold/server/page/histories.go (0.0%)</option>
				
				<option value="file29">scaffold/server/page/history.go (0.0%)</option>
				
				<option value="file30">scaffold/server/page/login.go (66.7%)</option>
				
				<option value="file31">scaffold/server/page/page.go (0.0%)</option>
				
				<option value="file32">scaffold/server/page/user.go (0.0%)</option>
				
				<option value="file33">scaffold/server/page/users.go (0.0%)</option>
				
				<option value="file34">scaffold/server/page/workflow.go (0.0%)</option>
				
				<option value="file35">scaffold/server/page/workflows.go (0.0%)</option>
				
				<option value="file36">scaffold/server/proxy/proxy.go (0.0%)</option>
				
				<option value="file37">scaffold/server/rabbitmq/rabbitmq.go (42.7%)</option>
				
				<option value="file38">scaffold/server/routes.go (99.3%)</option>
				
				<option value="file39">scaffold/server/run/run.go (0.0%)</option>
				
				<option value="file40">scaffold/server/state/state.go (22.9%)</option>
				
				<option value="file41">scaffold/server/task/task.go (39.4%)</option>
				
				<option value="file42">scaffold/server/user/user.go (45.6%)</option>
				
				<option value="file43">scaffold/server/utils/utils.go (0.0%)</option>
				
				<option value="file44">scaffold/server/worker/worker.go (39.4%)</option>
				
				<option value="file45">scaffold/server/workflow/workflow.go (72.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "net/http"
        "scaffold/server/auth"
        "scaffold/server/user"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
)

//        @summary                                        Generate API Token
//        @description                                Generate an API token for a user
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {array}                object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /auth/token/{username}/{token_name} [post]
func GenerateAPIToken(ctx *gin.Context) <span class="cov0" title="0">{
        username := ctx.Param("username")
        name := ctx.Param("name")

        token, err := user.GenerateAPIToken(username, name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{"token": token})</span>
}

//        @summary                                        Revoke API Token
//        @description                                Revoke an API token for a user
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {array}                object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /auth/token/{username}/{token_name} [delete]
func RevokeAPIToken(ctx *gin.Context) <span class="cov0" title="0">{
        username := ctx.Param("username")
        name := ctx.Param("name")

        err := user.RevokeAPIToken(username, name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Ping manager
//        @description                                Ping manager to reset node age
//        @tags                                                manager
//        @tags                                                health
//        @success                                        200
//        @failure                                        500
//        @failure                                        401
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /health/ping/{name} [post]
func Ping(c *gin.Context) <span class="cov10" title="34">{
        name := c.Param("name")
        auth.NodeLock.Lock()
        if n, ok := auth.Nodes[name]; ok </span><span class="cov10" title="34">{
                n.Ping = 0
                auth.Nodes[name] = n
        }</span>
        <span class="cov10" title="34">auth.NodeLock.Unlock()

        c.Status(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/datastore"
        "scaffold/server/input"
        "scaffold/server/utils"
        "scaffold/server/workflow"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a datastore
//        @description                                Create a datastore from a JSON object
//        @tags                                                manager
//        @tags                                                datastore
//        @accept                                                json
//        @produce                                        json
//        @Param                                                datastore        body                datastore.DataStore        true        "DataStore Data"
//        @success                                        201                        {object}        object
//        @failure                                        500                        {object}        object
//        @failure                                        401                        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore [post]
func CreateDataStore(ctx *gin.Context) <span class="cov0" title="0">{
        var d datastore.DataStore
        if err := ctx.ShouldBindJSON(&amp;d); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">c, err := workflow.GetWorkflowByName(d.Name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                }</span>
        }

        <span class="cov0" title="0">err = datastore.CreateDataStore(&amp;d)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a datastore
//        @description                                Delete a datastore by its name
//        @tags                                                manager
//        @tags                                                datastore
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore/{workflow_name} [delete]
func DeleteDataStoreByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")

        err := datastore.DeleteDataStoreByWorkflow(name)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all datastores
//        @description                                Get all datastores
//        @tags                                                manager
//        @tags                                                datastore
//        @produce                                        json
//        @success                                        200        {array}                datastore.DataStore
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore [get]
func GetAllDataStores(ctx *gin.Context) <span class="cov0" title="0">{
        datastores, err := datastore.GetAllDataStores()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        // Need to copy each workflow from pointer to value since pointers are returned
        // weirdly (I think at least)
        <span class="cov0" title="0">datastoresOut := make([]datastore.DataStore, 0)
        for _, d := range datastores </span><span class="cov0" title="0">{
                c, err := workflow.GetWorkflowByName(d.Name)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                                datastoresOut = append(datastoresOut, *d)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">datastoresOut = append(datastoresOut, *d)</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, datastoresOut)</span>
}

//        @summary                                        Get a datastore
//        @description                                Get a datastore by its name
//        @tags                                                manager
//        @tags                                                datastore
//        @produce                                        json
//        @success                                        200        {object}        datastore.DataStore
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore/{workflow_name} [get]
func GetDataStoreByName(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")

        d, err := datastore.GetDataStoreByWorkflow(name)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if d == nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("Datastore %s does not exist", name)})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, *d)</span>
}

//        @summary                                        Update a datastore
//        @description                                Update a datastore from a JSON object
//        @tags                                                manager
//        @tags                                                datastore
//        @accept                                                json
//        @produce                                        json
//        @Param                                                datastore        body                datastore.DataStore        true        "DataStore Data"
//        @success                                        201                        {object}        object
//        @failure                                        500                        {object}        object
//        @failure                                        401                        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/datastore/{workflow_name} [put]
func UpdateDataStoreByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")

        var d datastore.DataStore
        if err := ctx.ShouldBindJSON(&amp;d); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        // Need to copy over workflow inputs since some weirdness happens when updating the
        // datastore
        <span class="cov0" title="0">inputs := []input.Input{}
        if config.Config.Node.Type == constants.NODE_TYPE_MANAGER </span><span class="cov0" title="0">{
                c, err := workflow.GetWorkflowByName(name)
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(err, ctx, http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">inputs = c.Inputs</span>
        }

        <span class="cov0" title="0">err := datastore.UpdateDataStoreByWorkflow(name, &amp;d, inputs)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "os"
        "scaffold/server/datastore"
        "scaffold/server/filestore"
        "scaffold/server/input"
        "scaffold/server/utils"
        "scaffold/server/workflow"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

//        @summary                                        Download a file
//        @description                                Download a file from a workflow
//        @tags                                                manager
//        @tags                                                file
//        @produce                                        application/text
//        @success                                        200
//        @failure                                        500
//        @failure                                        401
//        @failure                                        404
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/file/{workflow_name}/{file_name}/download [get]
func DownloadFile(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")
        fileName := ctx.Param("file")

        c, err := workflow.GetWorkflowByName(name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                        return
                }</span>
        }

        <span class="cov0" title="0">path := fmt.Sprintf("/tmp/%s", uuid.New().String())

        err = filestore.GetFile(fmt.Sprintf("%s/%s", name, fileName), path)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">if err := os.Remove(path); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">ctx.Header("Content-Disposition", "attachment; filename="+fileName)
        ctx.Header("Content-Type", "application/text/plain")
        ctx.Header("Accept-Length", fmt.Sprintf("%d", data))
        ctx.Writer.Write(data)
        ctx.Status(http.StatusOK)</span>
}

//        @summary                                        Upload a file
//        @description                                Upload a file to a workflow
//        @tags                                                manager
//        @tags                                                file
//        @accept                                                multipart/form-data
//        @produce                                        json
//        @success                                        200
//        @failure                                        500
//        @failure                                        400
//        @failure                                        401
//        @failure                                        404
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/file/{datastore_name} [post]
func UploadFile(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")

        c, err := workflow.GetWorkflowByName(name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                }</span>
        }

        <span class="cov0" title="0">file, err := ctx.FormFile("file")
        fileName := file.Filename

        // The file cannot be received.
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">path := fmt.Sprintf("/tmp/%s", uuid.New().String())

        // The file is received, so let's save it
        if err := ctx.SaveUploadedFile(file, path); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if err := filestore.UploadFile(path, fmt.Sprintf("%s/%s", name, fileName)); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if err := os.Remove(path); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ds, err := datastore.GetDataStoreByWorkflow(name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ds.Files = append(ds.Files, fileName)
        ds.Files = utils.RemoveDuplicateValues(ds.Files)

        inputs := []input.Input{}

        if err := datastore.UpdateDataStoreByWorkflow(name, ds, inputs); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        // File saved successfully. Return proper result
        <span class="cov0" title="0">utils.DynamicAPIResponse(ctx, "/ui/files", http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get files
//        @description                                Get files by workflow
//        @tags                                                manager
//        @tags                                                file
//        @produce                                        json
//        @success                                        200        {array}                filestore.ObjectMetadata
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/file/{workflow_name} [get]
func GetFilesByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")

        c, err := workflow.GetWorkflowByName(name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                        return
                }</span>
        }

        <span class="cov0" title="0">objects, err := filestore.ListObjects()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">out := make([]filestore.ObjectMetadata, 0)

        for _, obj := range objects </span><span class="cov0" title="0">{
                if obj.Workflow == name </span><span class="cov0" title="0">{
                        out = append(out, obj)
                }</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, out)</span>
}

//        @summary                                        Get file
//        @description                                Get file by workflow and name
//        @tags                                                manager
//        @tags                                                file
//        @produce                                        json
//        @success                                        200        {object}        filestore.ObjectMetadata
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/file/{workflow_name}/{file_name} [get]
func GetFileByNames(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("name")
        file := ctx.Param("file")

        c, err := workflow.GetWorkflowByName(name)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                        return
                }</span>
        }

        <span class="cov0" title="0">objects, err := filestore.ListObjects()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">obj, ok := objects[file]
        if !ok </span><span class="cov0" title="0">{
                utils.Error(fmt.Errorf("file %s does not exist in datastore %s", file, name), ctx, http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">if obj.Workflow != name </span><span class="cov0" title="0">{
                utils.Error(fmt.Errorf("workflow %s does not have file %s", name, file), ctx, http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, obj)</span>
}

//        @summary                                        Get all files
//        @description                                Get all files
//        @tags                                                manager
//        @tags                                                file
//        @produce                                        json
//        @success                                        200        {array}                filestore.ObjectMetadata
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/file [get]
func GetAllFiles(ctx *gin.Context) <span class="cov0" title="0">{
        objects, err := filestore.ListObjects()
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">out := make([]filestore.ObjectMetadata, 0)

        for _, obj := range objects </span><span class="cov0" title="0">{
                c, err := workflow.GetWorkflowByName(obj.Workflow)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                                out = append(out, obj)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">out = append(out, obj)</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, out)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "net/http"
        "scaffold/server/constants"
        "scaffold/server/health"

        "github.com/gin-gonic/gin"
)

//        @summary                Check if a node is healthy
//        @description        Get node health
//        @tags                        manager
//        @tags                        worker
//        @tags                        health
//        @success                200
//        @failure                503
//        @router                        /health/healthy [get]
func Healthy(c *gin.Context) <span class="cov0" title="0">{
        if health.IsHealthy </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"version": constants.VERSION})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusServiceUnavailable)</span>
}

//        @summary                Check if a node is ready
//        @description        Get node readiness
//        @tags                        manager
//        @tags                        worker
//        @tags                        health
//        @success                200
//        @failure                503
//        @router                        /health/ready [get]
func Ready(c *gin.Context) <span class="cov0" title="0">{
        if health.IsReady </span><span class="cov0" title="0">{
                c.Status(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusServiceUnavailable)</span>
}

//        @summary                Check if a worker node is available
//        @description        Get status from node succeeding if not containers are running
//        @tags                        worker
//        @tags                        health
//        @success                200
//        @failure                503
//        @router                        /health/available [get]
func Available(c *gin.Context) <span class="cov0" title="0">{
        if health.IsAvailable </span><span class="cov0" title="0">{
                c.Status(http.StatusOK)
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusServiceUnavailable)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// API implements worker and manager API endpoints for Scaffold functionality
package api

import (
        "strings"

        "github.com/gin-gonic/gin"

        "scaffold/server/config"
        "scaffold/server/user"
        "scaffold/server/utils"

        logger "github.com/jfcarter2358/go-logger"
)

func validateUserGroup(ctx *gin.Context, groups []string) bool <span class="cov10" title="6">{
        var token string
        var err error
        var usr *user.User

        logger.Infof("", "Validating user against groups: %v", groups)

        if len(groups) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if we have an auth header
        <span class="cov10" title="6">authString := ctx.Request.Header.Get("Authorization")
        if authString == "" </span><span class="cov0" title="0">{
                // Check if the request is coming from a logged in UI user
                token, err = ctx.Cookie("scaffold_token")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Tracef("", "Scaffold token was empty")
                        return false
                }</span>
                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr == nil </span><span class="cov0" title="0">{
                        logger.Tracef("", "No user exists with login token")
                        return false
                }</span>
        } else<span class="cov10" title="6"> {
                logger.Tracef("", "Auth header detected")
                token = strings.Split(authString, " ")[1]

                // Is the request coming from a node itself?
                if token == config.Config.Node.PrimaryKey </span><span class="cov10" title="6">{
                        logger.Tracef("", "Primary key detected")
                        return true
                }</span>

                // Get the user via the information
                <span class="cov0" title="0">usr, _ = user.GetUserByAPIToken(token)
                if usr == nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Unable to get user by API token")
                        return false
                }</span>
        }

        <span class="cov0" title="0">if utils.Contains(usr.Groups, "admin") </span><span class="cov0" title="0">{
                logger.Tracef("", "User is part of admin group")
                return true
        }</span>
        <span class="cov0" title="0">for _, group := range groups </span><span class="cov0" title="0">{
                logger.Tracef("", "Checking %v against %s", usr.Groups, group)
                if utils.Contains(usr.Groups, group) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "net/http"
        "scaffold/server/history"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
)

//        @summary                                        Get a history
//        @description                                Get a run history by a run ID
//        @tags                                                manager
//        @tags                                                history
//        @produce                                        json
//        @success                                        200        {object}        history.History
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/history/{run_id} [get]
func GetHistory(ctx *gin.Context) <span class="cov0" title="0">{
        runID := ctx.Param("runID")
        h, err := history.GetHistoryByRunID(runID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, &amp;h)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "errors"
        "net/http"
        "scaffold/server/input"
        "scaffold/server/manager"
        "scaffold/server/utils"
        "scaffold/server/workflow"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a input
//        @description                                Create a input from a JSON object
//        @tags                                                manager
//        @tags                                                input
//        @accept                                                json
//        @produce                                        json
//        @Param                                                input        body                input.Input        true        "Input Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input [post]
func CreateInput(ctx *gin.Context) <span class="cov0" title="0">{
        var i input.Input
        if err := ctx.ShouldBindJSON(&amp;i); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">c, err := workflow.GetWorkflowByName(i.Workflow)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                }</span>
        }

        <span class="cov0" title="0">err = input.CreateInput(&amp;i)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a input
//        @description                                Delete a input by its name and its workflow
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{input_name} [delete]
func DeleteInputByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        n := ctx.Param("name")

        err := input.DeleteInputByNames(cn, n)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Delete inputs
//        @description                                Delete inputs by their workflow
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{workflow_name} [delete]
func DeleteInputsByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")

        err := input.DeleteInputsByWorkflow(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all inputs
//        @description                                Get all inputs
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {array}                input.Input
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input [get]
func GetAllInputs(ctx *gin.Context) <span class="cov0" title="0">{
        inputs, err := input.GetAllInputs()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">inputsOut := make([]input.Input, 0)
        for _, i := range inputs </span><span class="cov0" title="0">{
                c, err := workflow.GetWorkflowByName(i.Workflow)
                if err == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                                inputsOut = append(inputsOut, *i)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">inputsOut = append(inputsOut, *i)</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, inputsOut)</span>
}

//        @summary                                        Get a input
//        @description                                Get a input by its name and its workflow
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {object}        input.Input
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{workflow_name}/{input_name} [get]
func GetInputByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        n := ctx.Param("name")

        i, err := input.GetInputByNames(cn, n)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if i == nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusOK, input.Input{})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, *i)</span>
}

//        @summary                                        Get inputs
//        @description                                Get inputs by their workflow
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {array}                input.Input
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{workflow_name} [get]
func GetInputsByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")

        i, err := input.GetInputsByWorkflow(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, i)</span>
}

//        @summary                                        Update a input
//        @description                                Update a input from a JSON object
//        @tags                                                manager
//        @tags                                                input
//        @accept                                                json
//        @produce                                        json
//        @Param                                                input        body                input.Input        true        "Input Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{workflow_name}/{input_name} [put]
func UpdateInputByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        n := ctx.Param("name")

        var i input.Input
        if err := ctx.ShouldBindJSON(&amp;i); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">err := input.UpdateInputByNames(cn, n, &amp;i)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Trigger update to dependent tasks
//        @description                                Trigger updates of states for dependent tasks
//        @tags                                                manager
//        @tags                                                input
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/input/{workflow_name}/update [post]
func UpdateInputDependenciesByName(ctx *gin.Context) <span class="cov0" title="0">{
        name := ctx.Param("workflow")

        var changed []string
        if err := ctx.ShouldBindJSON(&amp;changed); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">err := manager.InputChangeStateChange(name, changed)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "scaffold/server/constants"
        "scaffold/server/history"
        "scaffold/server/manager"
        "scaffold/server/msg"
        "scaffold/server/rabbitmq"
        "scaffold/server/run"
        "scaffold/server/state"
        "scaffold/server/task"
        "scaffold/server/utils"
        "scaffold/server/workflow"

        "github.com/google/uuid"
        logger "github.com/jfcarter2358/go-logger"

        "github.com/gin-gonic/gin"
)

//        @summary                                        Kill a run
//        @description                                Instruct a manager to kill a run
//        @tags                                                manager
//        @tags                                                run
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @produce                                        json
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/run/{workflow_name}/{task_name}/{task_number} [delete]
func ManagerKillRun(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        logger.Infof("", "Triggering run kill for %s.%s", cn, tn)
        manager.DoKill(cn, tn)

        ctx.JSON(http.StatusOK, gin.H{"message": "OK"})
}</span>

//        @summary                                        Kill a run
//        @description                                Kill a run on a worker
//        @tags                                                worker
//        @tags                                                run
//        @success                                        200
//        @failure                                        500
//        @failure                                        401
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/kill/{workflow_name}/{task_name} [delete]
func KillRun(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        c, err := workflow.GetWorkflowByName(cn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
                return
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusUnauthorized)
                }</span>
        }

        <span class="cov0" title="0">t, err := task.GetTaskByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if t.Kind == constants.TASK_KIND_CONTAINER </span><span class="cov0" title="0">{
                if err := run.ContainerKill(cn, tn); err != nil </span><span class="cov0" title="0">{
                        utils.Error(err, ctx, http.StatusInternalServerError)
                        return
                }</span>
        } else<span class="cov0" title="0"> if t.Kind == constants.TASK_KIND_LOCAL </span><span class="cov0" title="0">{
                if err := run.LocalKill(cn, tn); err != nil </span><span class="cov0" title="0">{
                        utils.Error(err, ctx, http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov0" title="0">ctx.Status(http.StatusOK)</span>
}

//        @summary                                        Create a run
//        @description                                Create a run from a workflow and task
//        @tags                                                manager
//        @tags                                                run
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/run/{workflow_name}/{task_name} [post]
func CreateRun(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        c, err := workflow.GetWorkflowByName(cn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">t, err := task.GetTaskByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">s, err := state.GetStateByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if t.Disabled </span><span class="cov0" title="0">{
                utils.Error(fmt.Errorf("task %s is disabled", tn), ctx, http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">runID := uuid.New().String()

        m := msg.TriggerMsg{
                Task:     tn,
                Workflow: cn,
                Action:   constants.ACTION_TRIGGER,
                Groups:   c.Groups,
                Number:   t.RunNumber + 1,
                RunID:    runID,
                Context:  s.Context,
        }

        h := history.History{
                RunID:    runID,
                States:   make([]state.State, 0),
                Workflow: cn,
        }

        if err := history.CreateHistory(&amp;h); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">logger.Infof("", "Creating run with message %v", m)
        rabbitmq.ManagerPublish(m)

        ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get run status
//        @description                                Get status of a run by ID
//        @tags                                                manager
//        @tags                                                run
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/run/{run_id} [get]
func GetRunStatus(ctx *gin.Context) <span class="cov0" title="0">{
        runID := ctx.Param("runID")
        h, err := history.GetHistoryByRunID(runID)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">running := false
        errored := false
        waiting := false
        killed := false
        success := false

        s := h.States[len(h.States)-1]
        t := s.Task

        ss, err := state.GetStateByNames(h.Workflow, t)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">switch ss.Status </span>{
        case constants.STATE_STATUS_RUNNING:<span class="cov0" title="0">
                running = true</span>
        case constants.STATE_STATUS_ERROR:<span class="cov0" title="0">
                errored = true</span>
        case constants.STATE_STATUS_WAITING, constants.STATE_STATUS_NOT_STARTED:<span class="cov0" title="0">
                waiting = true</span>
        case constants.STATE_STATUS_KILLED:<span class="cov0" title="0">
                killed = true</span>
        case constants.STATE_STATUS_SUCCESS:<span class="cov0" title="0">
                success = true</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{
                "running": running,
                "errored": errored,
                "waiting": waiting,
                "killed":  killed,
                "success": success,
                "task":    t,
        })</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "scaffold/server/state"
        "scaffold/server/utils"
        "scaffold/server/workflow"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a state
//        @description                                Create a state from a JSON object
//        @tags                                                manager
//        @tags                                                state
//        @accept                                                json
//        @produce                                        json
//        @Param                                                state        body                state.State        true        "State Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state [post]
func CreateState(ctx *gin.Context) <span class="cov0" title="0">{
        var s state.State
        if err := ctx.ShouldBindJSON(&amp;s); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">c, err := workflow.GetWorkflowByName(s.Workflow)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                }</span>
        }

        <span class="cov0" title="0">err = state.CreateState(&amp;s)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a state
//        @description                                Delete a state by its name and its workflow
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{workflow_name}/{state_name} [delete]
func DeleteStateByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        err := state.DeleteStateByNames(cn, tn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Delete states
//        @description                                Delete states by their workflow
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{workflow_name} [delete]
func DeleteStatesByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")

        err := state.DeleteStatesByWorkflow(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all states
//        @description                                Get all states
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {array}                state.State
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state [get]
func GetAllStates(ctx *gin.Context) <span class="cov0" title="0">{
        states, err := state.GetAllStates()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">statesOut := make([]state.State, 0)
        for _, s := range states </span><span class="cov0" title="0">{
                c, err := workflow.GetWorkflowByName(s.Workflow)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                                statesOut = append(statesOut, *s)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">statesOut = append(statesOut, *s)</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, statesOut)</span>
}

//        @summary                                        Get a state
//        @description                                Get a state by its name and its workflow
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {object}        state.State
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{workflow_name}/{state_name} [get]
func GetStateByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        s, err := state.GetStateByNames(cn, tn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if s == nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("State %s/%s does not exist", cn, tn)})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, *s)</span>
}

//        @summary                                        Get states
//        @description                                Get states by their workflow
//        @tags                                                manager
//        @tags                                                state
//        @produce                                        json
//        @success                                        200        {array}                state.State
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{workflow_name} [get]
func GetStatesByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")

        s, err := state.GetStatesByWorkflow(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, s)</span>
}

//        @summary                                        Update a state
//        @description                                Update a state from a JSON object
//        @tags                                                manager
//        @tags                                                state
//        @accept                                                json
//        @produce                                        json
//        @Param                                                state        body                state.State        true        "State Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/state/{workflow_name}/{state_name} [put]
func UpdateStateByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        var s state.State
        if err := ctx.ShouldBindJSON(&amp;s); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">err := state.UpdateStateByNames(cn, tn, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "scaffold/server/state"
        "scaffold/server/task"
        "scaffold/server/utils"
        "scaffold/server/workflow"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a task
//        @description                                Create a task from a JSON object
//        @tags                                                manager
//        @tags                                                task
//        @accept                                                json
//        @produce                                        json
//        @Param                                                task        body                task.Task        true        "Task Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task [post]
func CreateTask(ctx *gin.Context) <span class="cov0" title="0">{
        var t task.Task
        if err := ctx.ShouldBindJSON(&amp;t); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">c, err := workflow.GetWorkflowByName(t.Workflow)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
        }</span>
        <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                }</span>
        }

        <span class="cov0" title="0">err = task.CreateTask(&amp;t)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a task
//        @description                                Delete a task by its name and its workflow
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{task_name} [delete]
func DeleteTaskByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        err := task.DeleteTaskByNames(cn, tn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Delete tasks
//        @description                                Delete tasks by their workflow
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{workflow_name} [delete]
func DeleteTasksByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")

        err := task.DeleteTasksByWorkflow(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all tasks
//        @description                                Get all tasks
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {array}                task.Task
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task [get]
func GetAllTasks(ctx *gin.Context) <span class="cov0" title="0">{
        tasks, err := task.GetAllTasks()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">tasksOut := make([]task.Task, 0)
        for _, t := range tasks </span><span class="cov0" title="0">{
                c, err := workflow.GetWorkflowByName(t.Workflow)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if c.Groups != nil </span><span class="cov0" title="0">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                                tasksOut = append(tasksOut, *t)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">tasksOut = append(tasksOut, *t)</span>
        }

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, tasksOut)</span>
}

//        @summary                                        Get a task
//        @description                                Get a task by its name and its workflow
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {object}        task.Task
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{workflow_name}/{task_name} [get]
func GetTaskByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        t, err := task.GetTaskByNames(cn, tn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if t == nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("Task %s/%s does not exist", cn, tn)})
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, *t)</span>
}

//        @summary                                        Get tasks
//        @description                                Get tasks by their workflow
//        @tags                                                manager
//        @tags                                                task
//        @produce                                        json
//        @success                                        200        {array}                task.Task
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{workflow_name} [get]
func GetTasksByWorkflow(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")

        t, err := task.GetTasksByWorkflow(cn)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, t)</span>
}

//        @summary                                        Update a task
//        @description                                Update a task from a JSON object
//        @tags                                                manager
//        @tags                                                task
//        @accept                                                json
//        @produce                                        json
//        @Param                                                task        body                task.Task        true        "Task Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{workflow_name}/{task_name} [put]
func UpdateTaskByNames(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        var t task.Task
        if err := ctx.ShouldBindJSON(&amp;t); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">err := task.UpdateTaskByNames(cn, tn, &amp;t)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Update a task
//        @description                                Update a task from a JSON object
//        @tags                                                manager
//        @tags                                                task
//        @success                                        201        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/task/{workflow_name}/{task_name}/enabled [put]
func ToggleTaskEnabled(ctx *gin.Context) <span class="cov0" title="0">{
        cn := ctx.Param("workflow")
        tn := ctx.Param("task")

        t, err := task.GetTaskByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">t.Disabled = !t.Disabled
        if err := task.UpdateTaskByNames(cn, tn, t); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">s, err := state.GetStateByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">s.Disabled = t.Disabled
        if err := state.UpdateStateByNames(cn, tn, s); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "fmt"
        "net/http"
        "scaffold/server/user"
        "scaffold/server/utils"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a user
//        @description                                Create a user from a JSON object
//        @tags                                                manager
//        @tags                                                user
//        @accept                                                json
//        @produce                                        json
//        @Param                                                user        body                user.User        true        "User Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user [post]
func CreateUser(ctx *gin.Context) <span class="cov10" title="10">{
        var u user.User
        if err := ctx.ShouldBindJSON(&amp;u); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="10">err := user.CreateUser(&amp;u)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="10">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a user
//        @description                                Delete a user by its username
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user/{username} [delete]
func DeleteUserByUsername(ctx *gin.Context) <span class="cov9" title="9">{
        username := ctx.Param("username")

        err := user.DeleteUserByUsername(username)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov9" title="9">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all users
//        @description                                Get all users
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {array}                user.User
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user [get]
func GetAllUsers(ctx *gin.Context) <span class="cov1" title="1">{
        users, err := user.GetAllUsers()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        <span class="cov1" title="1">usersOut := make([]user.User, len(users))
        for idx, u := range users </span><span class="cov3" title="2">{
                usersOut[idx] = *u
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, usersOut)</span>
}

//        @summary                                        Get a user
//        @description                                Get a user by its username
//        @tags                                                manager
//        @tags                                                user
//        @produce                                        json
//        @success                                        200        {array}                user.User
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user/{username} [get]
func GetUserByUsername(ctx *gin.Context) <span class="cov5" title="3">{
        username := ctx.Param("username")

        u, err := user.GetUserByUsername(username)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov5" title="3">if u == nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("User %s does not exist", username)})
                return
        }</span>

        <span class="cov5" title="3">ctx.JSON(http.StatusOK, *u)</span>
}

//        @summary                                        Update a user
//        @description                                Update a user from a JSON object
//        @tags                                                manager
//        @tags                                                user
//        @accept                                                json
//        @produce                                        json
//        @Param                                                user        body                user.User        true        "User Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/user/{user_name} [put]
func UpdateUserByUsername(ctx *gin.Context) <span class="cov1" title="1">{
        username := ctx.Param("username")

        var u user.User
        if err := ctx.ShouldBindJSON(&amp;u); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">uu, err := user.GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>
        <span class="cov1" title="1">uu.GivenName = u.GivenName
        uu.FamilyName = u.FamilyName
        uu.Email = u.Email
        uu.Groups = u.Groups
        uu.Roles = u.Roles

        if uu.Password != u.Password </span><span class="cov0" title="0">{
                uu.Password, err = user.HashAndSalt([]byte(u.Password))
                if err != nil </span><span class="cov0" title="0">{
                        utils.Error(err, ctx, http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov1" title="1">err = user.UpdateUserByUsername(username, uu)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "scaffold/server/constants"
        "scaffold/server/history"
        "scaffold/server/msg"
        "scaffold/server/rabbitmq"
        "scaffold/server/state"
        "scaffold/server/task"
        "scaffold/server/utils"
        "scaffold/server/workflow"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        logger "github.com/jfcarter2358/go-logger"
)

//        @summary                                        Trigger a webhook
//        @description                                Trigger a webhook with optional input data
//        @tags                                                manager
//        @tags                                                webhook
//        @accept                                                json
//        @produce                                        json
//        @Param                                                data        body                object        true        "Webhook input Data"
//        @success                                        201                {object}        object
//        @failure                                        500                {object}        object
//        @failure                                        401                {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/webhook/{workflow_name}/{webhook_id} [post]
func TriggerWebhookByID(ctx *gin.Context) <span class="cov0" title="0">{
        wName := ctx.Param("workflow")
        tName := ctx.Param("task")

        var data map[string]string
        if err := ctx.ShouldBindJSON(&amp;data); err != nil </span><span class="cov0" title="0">{
                logger.Warnf("", "No input data found for trigger on webhook %s", wName)
        }</span>

        <span class="cov0" title="0">w, err := workflow.GetWorkflowByName(wName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if w.Groups != nil </span><span class="cov0" title="0">{
                if !validateUserGroup(ctx, w.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                }</span>
        }

        <span class="cov0" title="0">t, err := task.GetTaskByNames(wName, tName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if t.Disabled </span><span class="cov0" title="0">{
                utils.Error(fmt.Errorf("task %s is disabled", t.Name), ctx, http.StatusServiceUnavailable)
                return
        }</span>

        <span class="cov0" title="0">runID := uuid.New().String()

        m := msg.TriggerMsg{
                Task:     tName,
                Workflow: wName,
                Action:   constants.ACTION_TRIGGER,
                Groups:   w.Groups,
                Number:   t.RunNumber + 1,
                RunID:    runID,
                Context:  data,
        }

        h := history.History{
                RunID:    runID,
                States:   make([]state.State, 0),
                Workflow: wName,
        }

        if err := history.CreateHistory(&amp;h); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">logger.Infof("", "Creating run with message %v", m)
        rabbitmq.ManagerPublish(m)

        ctx.JSON(http.StatusOK, gin.H{"message": "OK", "run_id": runID})</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "errors"
        "fmt"
        "net/http"
        "scaffold/server/utils"
        "scaffold/server/workflow"

        "github.com/gin-gonic/gin"
        "go.mongodb.org/mongo-driver/mongo"
)

//        @summary                                        Create a workflow
//        @description                                Create a workflow from a JSON object
//        @tags                                                manager
//        @tags                                                workflow
//        @accept                                                json
//        @produce                                        json
//        @Param                                                workflow        body                workflow.Workflow        true        "Workflow Data"
//        @success                                        201                        {object}        object
//        @failure                                        500                        {object}        object
//        @failure                                        401                        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/workflow [post]
func CreateWorkflow(ctx *gin.Context) <span class="cov10" title="5">{
        var c workflow.Workflow
        if err := ctx.ShouldBindJSON(&amp;c); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="5">if c.Groups != nil </span><span class="cov10" title="5">{
                if !validateUserGroup(ctx, c.Groups) </span><span class="cov0" title="0">{
                        utils.Error(errors.New("user is not part of required groups to access this resources"), ctx, http.StatusForbidden)
                }</span>
        }

        <span class="cov10" title="5">err := workflow.CreateWorkflow(&amp;c)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="5">ctx.JSON(http.StatusCreated, gin.H{"message": "Created"})</span>
}

//        @summary                                        Delete a workflow
//        @description                                Delete a workflow by its name
//        @tags                                                manager
//        @tags                                                workflow
//        @produce                                        json
//        @success                                        200        {object}        object
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/workflow/{workflow_name} [delete]
func DeleteWorkflowByName(ctx *gin.Context) <span class="cov10" title="5">{
        name := ctx.Param("name")

        err := workflow.DeleteWorkflowByName(name)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="5">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

//        @summary                                        Get all workflows
//        @description                                Get all workflows
//        @tags                                                manager
//        @tags                                                workflow
//        @produce                                        json
//        @success                                        200        {array}                workflow.Workflow
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/workflow [get]
func GetAllWorkflows(ctx *gin.Context) <span class="cov1" title="1">{
        workflows, err := workflow.GetAllWorkflows()

        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        ctx.JSON(http.StatusNoContent, []interface{}{})
                        return
                }</span>
                <span class="cov0" title="0">utils.Error(err, ctx, http.StatusInternalServerError)
                return</span>
        }

        // Need to copy each workflow from pointer to value since pointers are returned
        // weirdly (I think at least)
        <span class="cov1" title="1">workflowsOut := make([]workflow.Workflow, 0)
        for _, c := range workflows </span><span class="cov1" title="1">{
                if c.Groups != nil </span><span class="cov1" title="1">{
                        if validateUserGroup(ctx, c.Groups) </span><span class="cov1" title="1">{
                                workflowsOut = append(workflowsOut, *c)
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }
                <span class="cov0" title="0">workflowsOut = append(workflowsOut, *c)</span>
        }

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, workflowsOut)</span>
}

//        @summary                                        Get a workflow
//        @description                                Get a workflow by its name
//        @tags                                                manager
//        @tags                                                workflow
//        @produce                                        json
//        @success                                        200        {object}        workflow.Workflow
//        @failure                                        500        {object}        object
//        @failure                                        401        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/workflow/{workflow_name} [get]
func GetWorkflowByName(ctx *gin.Context) <span class="cov7" title="3">{
        name := ctx.Param("name")

        c, err := workflow.GetWorkflowByName(name)

        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov7" title="3">if c == nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusNotFound, gin.H{"message": fmt.Sprintf("Workflow %s does not exist", name)})
                return
        }</span>

        <span class="cov7" title="3">ctx.JSON(http.StatusOK, *c)</span>
}

//        @summary                                        Update a workflow
//        @description                                Update a workflow from a JSON object
//        @tags                                                manager
//        @tags                                                workflow
//        @accept                                                json
//        @produce                                        json
//        @Param                                                workflow        body                workflow.Workflow        true        "Workflow Data"
//        @success                                        201                        {object}        object
//        @failure                                        500                        {object}        object
//        @failure                                        401                        {object}        object
//        @securityDefinitions.apiKey        token
//        @in                                                        header
//        @name                                                Authorization
//        @security                                        X-Scaffold-API
//        @router                                                /api/v1/workflow/{workflow_name} [put]
func UpdateWorkflowByName(ctx *gin.Context) <span class="cov1" title="1">{
        name := ctx.Param("name")

        var c workflow.Workflow
        if err := ctx.ShouldBindJSON(&amp;c); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">err := workflow.UpdateWorkflowByName(name, &amp;c)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">ctx.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package auth

import (
        "crypto/tls"
        "net/http"
        "scaffold/server/config"
        "scaffold/server/user"
        "scaffold/server/utils"
        "scaffold/server/workflow"
        "strings"
        "sync"
        "time"

        logger "github.com/jfcarter2358/go-logger"

        "encoding/base64"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"
        "gopkg.in/gomail.v2"
)

type PasswordResetObject struct {
        Password        string `json:"password"`
        ConfirmPassword string `json:"confirm_password"`
        Email           string `json:"email"`
}

type NodeJoinObject struct {
        Name     string `json:"name"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
        WSPort   int    `json:"ws_port"`
        Protocol string `json:"protocol"`
        JoinKey  string `json:"join_key"`
        Version  string `json:"version"`
}

type NodeObject struct {
        Name      string `json:"name" bson:"name"`
        Host      string `json:"host" bson:"host"`
        Port      int    `json:"port" bson:"port"`
        WSPort    int    `json:"ws_port" bson:"ws_port"`
        Protocol  string `json:"protocol"`
        Healthy   bool   `json:"healthy" bson:"healthy"`
        Available bool   `json:"available" bson:"available"`
        Version   string `json:"version" bson:"version"`
        Ping      int    `json:"ping" bson:"ping"`
}

var Nodes = make(map[string]NodeObject)
var LastScheduledIdx = 0
var NodeLock = &amp;sync.RWMutex{}

// Do the actual login
// This takes the following in a posted form:
//   - username string
//   - password string
//   - remember_me boolean
func PerformLogin(c *gin.Context) <span class="cov0" title="0">{
        username := c.PostForm("username")
        password := c.PostForm("password")

        rememberMe := c.PostForm("remember_me")

        if username == "" || password == "" </span><span class="cov0" title="0">{
                if val, ok := c.Request.Header["Authorization"]; ok </span><span class="cov0" title="0">{
                        authToken := strings.Split(val[0], " ")[1]
                        authTokenBytes, _ := base64.StdEncoding.DecodeString(authToken)
                        authData := strings.Split(string(authTokenBytes), ":")

                        username = authData[0]
                        password = authData[1]

                        valid, _ := user.VerifyUser(username, password)
                        if valid </span><span class="cov0" title="0">{
                                // There's definitely better ways of doing this but it's fine for now
                                token := utils.GenerateToken(32)
                                c.SetCookie("scaffold_token", token, 3600, "", "", false, false)
                                u, _ := user.GetUserByUsername(username)
                                hashedToken, err := HashAndSalt([]byte(token))
                                if err != nil </span><span class="cov0" title="0">{
                                        c.HTML(http.StatusBadRequest, "login.html", gin.H{
                                                "ErrorTitle":   "Login Failed",
                                                "ErrorMessage": err.Error()})
                                }</span>
                                <span class="cov0" title="0">u.LoginToken = hashedToken
                                user.UpdateUserByUsername(username, u)
                                return</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                valid, err := user.VerifyUser(username, password)
                if valid </span><span class="cov0" title="0">{
                        token := utils.GenerateToken(32)
                        if rememberMe == "on" </span><span class="cov0" title="0">{
                                c.SetCookie("scaffold_token", token, 604800, "", "", false, false)
                        }</span> else<span class="cov0" title="0"> {
                                c.SetCookie("scaffold_token", token, 3600, "", "", false, false)
                        }</span>

                        <span class="cov0" title="0">u, _ := user.GetUserByUsername(username)
                        hashedToken, err := HashAndSalt([]byte(token))
                        if err != nil </span><span class="cov0" title="0">{
                                c.HTML(http.StatusBadRequest, "login.html", gin.H{
                                        "ErrorTitle":   "Login Failed",
                                        "ErrorMessage": err.Error()})
                        }</span>
                        <span class="cov0" title="0">u.LoginToken = hashedToken
                        user.UpdateUserByUsername(username, u)

                        c.Redirect(302, "/")
                        return</span>
                } else<span class="cov0" title="0"> {
                        c.HTML(http.StatusBadRequest, "login.html", gin.H{
                                "ErrorTitle":   "Login Failed",
                                "ErrorMessage": err.Error()})
                }</span>
        }
        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
}

// Clear the cookie on logout and redirect to login page
func PerformLogout(c *gin.Context) <span class="cov0" title="0">{
        token, err := c.Cookie("scaffold_token")

        if err != nil </span><span class="cov0" title="0">{
                u, err := user.GetUserByLoginToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        u.LoginToken = ""
                        user.UpdateUserByUsername(u.Username, u)
                }</span>
        }
        <span class="cov0" title="0">c.SetCookie("scaffold_token", "", -1, "", "", false, true)

        c.Redirect(http.StatusTemporaryRedirect, "/")</span>
}

// Send an email with a password reset link
// This is probably broken, I just haven't gotten to fixing it yet
//   but I also haven't tested it in a while so maybe it works
func RequestPasswordReset(c *gin.Context) <span class="cov0" title="0">{
        email := c.PostForm("email")

        u, _ := user.GetUserByEmail(email)

        if u != nil </span><span class="cov0" title="0">{
                token := utils.GenerateToken(32)
                currentTime := time.Now()

                hashedToken, err := HashAndSalt([]byte(token))
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">u.ResetToken = hashedToken
                u.ResetTokenCreated = currentTime.Format("2006-01-02 15:04:05")
                user.UpdateUserByUsername(u.Username, u)

                m := gomail.NewMessage()

                // Set E-Mail sender
                m.SetHeader("From", config.Config.Reset.Email)

                // Set E-Mail receivers
                m.SetHeader("To", email)

                // Set E-Mail subject
                m.SetHeader("Subject", "Scaffold Password Reset")

                // Set E-Mail body. You can set plain text or html with text/html
                m.SetBody("text/html", "&lt;p&gt;To reset your Scaffold account password, click on the following link or paste it into your browser:&lt;/p&gt;&lt;br&gt;&lt;a href=\""+config.Config.BaseURL+"/ui/reset_password/"+token+"\"&gt;"+config.Config.BaseURL+"/ui/reset_password/"+token+"&lt;/a&gt;&lt;br&gt;This link will expire after 24 hours.")

                // Settings for SMTP server
                d := gomail.NewDialer(config.Config.Reset.Host, config.Config.Reset.Port, config.Config.Reset.Email, config.Config.Reset.Password)

                // This is only needed when SSL/TLS certificate is not valid on server.
                // In production this should be set to false.
                d.TLSConfig = &amp;tls.Config{InsecureSkipVerify: true}

                // Now send E-Mail
                if err := d.DialAndSend(m); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("", err.Error())
                }</span>
                <span class="cov0" title="0">c.Redirect(302, "/ui/email_success")</span>
        } else<span class="cov0" title="0"> {
                c.Redirect(302, "/ui/email_failure")
        }</span>
}

// Send over the new password from the reset and save the salted/hashed password to the
//   user
func DoPasswordReset(c *gin.Context) <span class="cov0" title="0">{
        r := PasswordResetObject{}

        err := c.ShouldBindJSON(&amp;r)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">if r.Password != r.ConfirmPassword </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "passwords do not match"})
        }</span>
        <span class="cov0" title="0">u, err := user.GetUserByEmail(r.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">u.Password, err = HashAndSalt([]byte(r.Password))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        }</span>
        <span class="cov0" title="0">user.UpdateUserByUsername(u.Username, u)
        c.JSON(http.StatusOK, gin.H{})</span>
}

// Do the hash and salt
func HashAndSalt(pwd []byte) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword(pwd, bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return string(hash), nil</span>
}

// Have a worker join the manager
func JoinNode(ctx *gin.Context) <span class="cov10" title="3">{
        var n NodeJoinObject
        if err := ctx.ShouldBindJSON(&amp;n); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov10" title="3">if n.JoinKey == config.Config.Node.JoinKey </span><span class="cov10" title="3">{
                ipAddr := ctx.ClientIP()
                logger.Debugf("", "Joining node %s, %d, %d", ipAddr, n.Port, n.WSPort)
                if nd, ok := Nodes[n.Name]; ok </span><span class="cov0" title="0">{
                        nd.Ping = 0
                        Nodes[n.Name] = nd
                        ctx.Status(http.StatusOK)
                        return
                }</span>

                <span class="cov10" title="3">NodeLock.Lock()
                Nodes[n.Name] = NodeObject{
                        Name:     n.Name,
                        Host:     ipAddr,
                        Port:     n.Port,
                        WSPort:   n.WSPort,
                        Healthy:  true,
                        Version:  n.Version,
                        Protocol: n.Protocol,
                        Ping:     0,
                }
                NodeLock.Unlock()
                ctx.Status(http.StatusOK)
                return</span>
        }

        <span class="cov0" title="0">ctx.Status(http.StatusUnauthorized)</span>
}

// Get all the currently used groups
func GetAllGroups() ([]string, error) <span class="cov0" title="0">{
        groups := []string{}

        workflows, err := workflow.GetAllWorkflows()
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span> else<span class="cov0" title="0"> {
                for _, c := range workflows </span><span class="cov0" title="0">{
                        for _, group := range c.Groups </span><span class="cov0" title="0">{
                                if !utils.Contains(groups, group) </span><span class="cov0" title="0">{
                                        groups = append(groups, group)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">users, err := user.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span> else<span class="cov0" title="0"> {
                for _, u := range users </span><span class="cov0" title="0">{
                        for _, group := range u.Groups </span><span class="cov0" title="0">{
                                if !utils.Contains(groups, group) </span><span class="cov0" title="0">{
                                        groups = append(groups, group)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return groups, nil</span>
}

// Gather all allowed roles
func GetAllRoles() []string <span class="cov0" title="0">{
        return []string{"read", "write", "admin"}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "encoding/json"
        "errors"
        "io/ioutil"
        "log"
        "net"
        "net/url"
        "os"
        "reflect"
        "strconv"

        "github.com/jfcarter2358/go-logger"
)

const DEFAULT_CONFIG_PATH = "/home/scaffold/data/config.json"
const ENV_PREFIX = "SCAFFOLD_"

type ConfigObject struct {
        Host                     string          `json:"host"`
        Port                     int             `json:"port"`
        Protocol                 string          `json:"protocol"`
        WSPort                   int             `json:"ws_port" env:"WS_PORT"`
        LogLevel                 string          `json:"log_level" env:"LOG_LEVEL"`
        LogFormat                string          `json:"log_format" env:"LOG_FORMAT"`
        BaseURL                  string          `json:"base_url" env:"BASE_URL"`
        PodmanOpts               string          `json:"podman_opts" env:"PODMAN_OPTS"`
        Admin                    UserObject      `json:"admin" env:"ADMIN"`
        DBConnectionString       string          `json:"db_connection_string" env:"DB_CONNECTION_STRING"`
        DB                       DBObject        `json:"db"`
        Node                     NodeObject      `json:"node" env:"NODE"`
        HeartbeatInterval        int             `json:"heartbeat_interval" env:"HEARTBEAT_INTERVAL"`
        HeartbeatBackoff         int             `json:"heartbeat_backoff" env:"HEARTBEAT_BACKOFF"`
        Reset                    ResetObject     `json:"reset" env:"RESET"`
        FileStore                FileStoreObject `json:"file_store" env:"FILESTORE"`
        TLSEnabled               bool            `json:"tls_enabled" env:"TLS_ENABLED"`
        TLSSkipVerify            bool            `json:"tls_skip_verify" env:"TLS_SKIP_VERIFY"`
        TLSCrtPath               string          `json:"tls_crt_path" env:"TLS_CRT_PATH"`
        TLSKeyPath               string          `json:"tls_key_path" env:"TLS_KEY_PATH"`
        RabbitMQConnectionString string          `json:"rabbitmq_connection_string" env:"RABBITMQ_CONNECTION_STRING"`
        ManagerQueueName         string          `json:"manager_queue_name" env:"MANAGER_QUEUE_NAME"`
        WorkerQueueName          string          `json:"worker_queue_name" env:"WORKER_QUEUE_NAME"`
        KillQueueName            string          `json:"kill_queue_name" env:"KILL_QUEUE_NAME"`
        PingHealthyThreshold     int             `json:"ping_healthy_threshold" env:"PING_HEALTHY_THRESHOLD"`
        PingUnknownThreshold     int             `json:"ping_unknown_threshold" env:"PING_UNKNOWN_THRESHOLD"`
        PingDownThreshold        int             `json:"ping_down_threshold" env:"PING_DOWN_THRESHOLD"`
        CheckInterval            int             `json:"check_interval" env:"CHECK_INTERVAL"`
        RestartPeriod            int             `json:"restart_period" env:"RESTART_PERIOD"`
        RunPruneCron             string          `json:"run_prune_cron" env:"RUN_PRUNE_CRON"`
        RunPruneDuration         int             `json:"run_prune_duration" env:"RUN_PRUNE_DURATION"`
}

type FileStoreObject struct {
        AccessKey string `json:"access_key"`
        SecretKey string `json:"secret_key"`
        Host      string `json:"host"`
        Port      int    `json:"port"`
        Bucket    string `json:"bucket"`
        Region    string `json:"region"`
        Protocol  string `json:"protocol"`
        Type      string `json:"type"`
}

type UserObject struct {
        Username string `json:"username"`
        Password string `json:"password"`
        Email    string `json:"email"`
}

type DBObject struct {
        Protocol string `json:"protocol"`
        Username string `json:"username"`
        Password string `json:"password"`
        Name     string `json:"name"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
}

type ResetObject struct {
        Email    string `json:"email"`
        Password string `json:"password"`
        Host     string `json:"mail_host"`
        Port     int    `json:"mail_port"`
}

type NodeObject struct {
        Type            string `json:"type"`
        ManagerHost     string `json:"manager_host"`
        ManagerPort     int    `json:"manager_port"`
        JoinKey         string `json:"join_key"`
        PrimaryKey      string `json:"primary_key"`
        ManagerProtocol string `json:"manager_protocol"`
}

var Config ConfigObject

// Load configuration from either a local JSON file or via ENV variables
// ENV variables will override settings in the JSON file
func LoadConfig() <span class="cov2" title="2">{
        configPath := os.Getenv(ENV_PREFIX + "CONFIG_PATH")
        if configPath == "" </span><span class="cov2" title="2">{
                configPath = DEFAULT_CONFIG_PATH
        }</span>

        // Default configuration
        <span class="cov2" title="2">Config = ConfigObject{
                Host:              "",
                Port:              -1,
                Protocol:          "",
                BaseURL:           "http://localhost:2997",
                WSPort:            8080,
                LogLevel:          logger.LOG_LEVEL_INFO,
                LogFormat:         logger.LOG_FORMAT_CONSOLE,
                HeartbeatInterval: 1000,
                HeartbeatBackoff:  10,
                TLSEnabled:        false,
                TLSSkipVerify:     false,
                TLSCrtPath:        "/tmp/certs/cert.crt",
                TLSKeyPath:        "/tmp/certs/cert.key",
                PodmanOpts:        "--security-opt label=disabled --network=host",
                Admin: UserObject{
                        Username: "admin",
                        Password: "admin",
                },
                DBConnectionString: "mongodb://MyCoolMongoDBUsername:MyCoolMongoDBPassword@mongodb:27017/scaffold",
                DB:                 DBObject{},
                Reset: ResetObject{
                        Email:    "",
                        Password: "",
                        Host:     "smtp.gmail.com",
                        Port:     587,
                },
                Node: NodeObject{
                        Type:            "manager",
                        ManagerHost:     "scaffold-manager",
                        ManagerPort:     2997,
                        ManagerProtocol: "http",
                        JoinKey:         "MyCoolJoinKey12345",
                        PrimaryKey:      "MyCoolPrimaryKey12345",
                },
                FileStore: FileStoreObject{
                        AccessKey: "MyCoolMinIOAccessKey",
                        SecretKey: "MyCoolMinIOSecretKey",
                        Host:      "minio",
                        Port:      9000,
                        Bucket:    "scaffold",
                        Region:    "default-region",
                        Protocol:  "http",
                        Type:      "s3",
                },
                RabbitMQConnectionString: "amqp://guest:guest@rabbitmq:5672",
                ManagerQueueName:         "scaffold_manager",
                WorkerQueueName:          "scaffold_worker",
                KillQueueName:            "scaffold_kill",
                PingHealthyThreshold:     3,
                PingUnknownThreshold:     6,
                PingDownThreshold:        9,
                CheckInterval:            2000,
                RestartPeriod:            86400,         // 24 hours
                RunPruneCron:             "0 0 * * * *", // every day at midnight
                RunPruneDuration:         24,            // 24 hour run lifetime
        }

        // Load JSON if exists
        jsonFile, err := os.Open(configPath)
        if err == nil </span><span class="cov0" title="0">{
                log.Printf("Successfully Opened %v", configPath)

                byteValue, _ := ioutil.ReadAll(jsonFile)

                json.Unmarshal(byteValue, &amp;Config)
        }</span>

        <span class="cov2" title="2">v := reflect.ValueOf(Config)
        t := reflect.TypeOf(Config)

        // Go through config object fields and check for ENV variable existence/populate
        //   configuration with the present values
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov10" title="62">{
                field, found := t.FieldByName(v.Type().Field(i).Name)
                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov10" title="62">value := field.Tag.Get("env")
                if value != "" </span><span class="cov9" title="54">{
                        val, present := os.LookupEnv(ENV_PREFIX + value)
                        if present </span><span class="cov7" title="16">{
                                // log.Printf("Found ENV var %s with value %s", ENV_PREFIX+value, val)
                                w := reflect.ValueOf(&amp;Config).Elem().FieldByName(t.Field(i).Name)
                                x := getAttr(&amp;Config, t.Field(i).Name).Kind().String()
                                if w.IsValid() </span><span class="cov7" title="16">{
                                        switch x </span>{
                                        case "int", "int64":<span class="cov2" title="2">
                                                i, err := strconv.ParseInt(val, 10, 64)
                                                if err == nil </span><span class="cov2" title="2">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int8":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 8)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int16":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 16)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "int32":<span class="cov0" title="0">
                                                i, err := strconv.ParseInt(val, 10, 32)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetInt(i)
                                                }</span>
                                        case "string":<span class="cov5" title="8">
                                                w.SetString(val)</span>
                                        case "float32":<span class="cov0" title="0">
                                                i, err := strconv.ParseFloat(val, 32)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetFloat(i)
                                                }</span>
                                        case "float", "float64":<span class="cov0" title="0">
                                                i, err := strconv.ParseFloat(val, 64)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetFloat(i)
                                                }</span>
                                        case "bool":<span class="cov0" title="0">
                                                i, err := strconv.ParseBool(val)
                                                if err == nil </span><span class="cov0" title="0">{
                                                        w.SetBool(i)
                                                }</span>
                                        default:<span class="cov4" title="6">
                                                objValue := reflect.New(field.Type)
                                                objInterface := objValue.Interface()
                                                err := json.Unmarshal([]byte(val), objInterface)
                                                obj := reflect.ValueOf(objInterface)
                                                if err == nil </span><span class="cov4" title="6">{
                                                        w.Set(reflect.Indirect(obj).Convert(field.Type))
                                                }</span> else<span class="cov0" title="0"> {
                                                        log.Println(err)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov2" title="2">defer jsonFile.Close()

        breakConfigFields()</span>
}

// get object field by name
func getAttr(obj interface{}, fieldName string) reflect.Value <span class="cov7" title="16">{
        pointToStruct := reflect.ValueOf(obj) // addressable
        curStruct := pointToStruct.Elem()
        if curStruct.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                panic("not struct")</span>
        }
        <span class="cov7" title="16">curField := curStruct.FieldByName(fieldName) // type: reflect.Value
        if !curField.IsValid() </span><span class="cov0" title="0">{
                panic("not found:" + fieldName)</span>
        }
        <span class="cov7" title="16">return curField</span>
}

// Break the DB config and base URL into separate fields for ease of use later
func breakConfigFields() <span class="cov2" title="2">{
        baseURL, err := url.Parse(Config.BaseURL)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">baseHost, basePortString, err := net.SplitHostPort(baseURL.Host)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">basePort, err := strconv.Atoi(basePortString)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">baseProtocol := baseURL.Scheme

        Config.Host = baseHost
        Config.Port = basePort
        Config.Protocol = baseProtocol

        mongoURL, err := url.Parse(Config.DBConnectionString)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov2" title="2">mongoHost, mongoPortString, err := net.SplitHostPort(baseURL.Host)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov2" title="2">mongoPort, err := strconv.Atoi(mongoPortString)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov2" title="2">mongoProtocol := baseURL.Scheme

        mongoUsername := mongoURL.User.Username()
        mongoPassword, isSet := mongoURL.User.Password()
        if !isSet </span><span class="cov0" title="0">{
                panic(errors.New("credentials not provided to DB connection string"))</span>
        }

        <span class="cov2" title="2">mongoName := mongoURL.Path[1:len(mongoURL.Path)]

        Config.DB.Host = mongoHost
        Config.DB.Port = mongoPort
        Config.DB.Username = mongoUsername
        Config.DB.Password = mongoPassword
        Config.DB.Name = mongoName
        Config.DB.Protocol = mongoProtocol</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package scron

import (
        // "scaffold/server/bulwark"

        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/history"
        "scaffold/server/msg"
        "scaffold/server/rabbitmq"
        "scaffold/server/state"
        "scaffold/server/task"
        "scaffold/server/utils"
        "scaffold/server/workflow"
        "strconv"
        "strings"
        "time"

        "github.com/google/uuid"
        logger "github.com/jfcarter2358/go-logger"

        "github.com/robfig/cron"
)

// Start our cron manager to check for task crons every minute
func Start() <span class="cov1" title="1">{
        c := cron.New()
        c.AddFunc("* * * * * *", checkTaskCrons)
        c.AddFunc(config.Config.RunPruneCron, history.PruneHistories)
        go c.Start()
}</span>

// Get all tasks and check if they should be run according to their crontab
func checkTaskCrons() <span class="cov10" title="33">{
        ts, err := task.GetAllTasks()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Unable to get tasks: %s", err.Error())
        }</span>
        <span class="cov10" title="33">currentTime := time.Now()

        for _, t := range ts </span><span class="cov5" title="6">{
                if t.Cron != "" &amp;&amp; !t.Disabled </span><span class="cov0" title="0">{
                        c, err := workflow.GetWorkflowByName(t.Workflow)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error getting workflow: %s", err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">valid, err := task.VerifyDepends(t.Workflow, t.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error verify tasks parent statuses: %s", err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">checkCron(currentTime, t.Cron, t.Name, t.RunNumber, c)</span>
                }
        }
}

// check if a crontab meets the current time and should be run
func checkCron(currentTime time.Time, crontab, name string, runNumber int, c *workflow.Workflow) <span class="cov0" title="0">{
        second := currentTime.Second()
        month := currentTime.Month()
        day := currentTime.Day()
        hour := currentTime.Hour()
        minute := currentTime.Minute()
        dayOfWeek := currentTime.Weekday()

        parts := strings.Split(crontab, " ")
        isSecond := checkCronValue(int(second), 0, 59, parts[0])
        isMinute := checkCronValue(int(minute), 0, 59, parts[1])
        isHour := checkCronValue(int(hour), 0, 23, parts[2])
        isDay := checkCronValue(int(day), 0, 31, parts[3])
        isMonth := checkCronValue(int(month), 1, 12, parts[4])
        isDayOfWeek := checkCronValue(int(dayOfWeek), 0, 7, parts[5])

        if isSecond &amp;&amp; isMinute &amp;&amp; isHour &amp;&amp; isDay &amp;&amp; isMonth &amp;&amp; isDayOfWeek </span><span class="cov0" title="0">{
                t, err := task.GetTaskByNames(c.Name, name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error getting cron run task: %s", err.Error())
                        return
                }</span>
                <span class="cov0" title="0">if t.Disabled </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">for _, tt := range t.DependsOn.Success </span><span class="cov0" title="0">{
                        s, err := state.GetStateByNames(c.Name, tt)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error getting cron run state: %s", err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                                logger.Tracef("", "Cron status of %s does not match %s", s.Status, constants.STATE_STATUS_SUCCESS)
                                return
                        }</span>
                }
                <span class="cov0" title="0">for _, tt := range t.DependsOn.Error </span><span class="cov0" title="0">{
                        s, err := state.GetStateByNames(c.Name, tt)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error getting cron run state: %s", err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                                logger.Tracef("", "Cron status of %s does not match %s", s.Status, constants.STATE_STATUS_ERROR)
                                return
                        }</span>
                }
                <span class="cov0" title="0">for _, tt := range t.DependsOn.Always </span><span class="cov0" title="0">{
                        s, err := state.GetStateByNames(c.Name, tt)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error getting cron run state: %s", err.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_SUCCESS &amp;&amp; s.Status != constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                                logger.Tracef("", "Cron status of %s does not match %s or %s", s.Status, constants.STATE_STATUS_SUCCESS, constants.STATE_STATUS_ERROR)
                                return
                        }</span>
                }
                <span class="cov0" title="0">s, err := state.GetStateByNames(c.Name, name)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error getting cron run state: %s", err.Error())
                        return
                }</span>

                // Trigger a new run if valid
                <span class="cov0" title="0">runID := uuid.New().String()

                m := msg.TriggerMsg{
                        Task:     name,
                        Workflow: c.Name,
                        Action:   constants.ACTION_TRIGGER,
                        Groups:   c.Groups,
                        Number:   runNumber + 1,
                        Context:  s.Context,
                }
                h := history.History{
                        RunID:    runID,
                        States:   make([]state.State, 0),
                        Workflow: c.Name,
                }

                if err := history.CreateHistory(&amp;h); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error triggering cron run: %s", err.Error())
                        return
                }</span>

                <span class="cov0" title="0">logger.Infof("", "Triggering run with message %v", m)
                if err := rabbitmq.ManagerPublish(m); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error triggering cron run: %s", err.Error())
                }</span>
        }
}

// Breakdown the part of the crontab and compare its interval with the current value
func checkCronValue(t, start, end int, x string) bool <span class="cov0" title="0">{
        step := 1
        vals := []int{}

        parts_slash := strings.Split(x, "/")
        if len(parts_slash) == 2 </span><span class="cov0" title="0">{
                step, _ = strconv.Atoi(parts_slash[1])
                x = parts_slash[0]
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(x, "*") </span><span class="cov0" title="0">{
                for i := start; i &lt; end+1; i += step </span><span class="cov0" title="0">{
                        vals = append(vals, i)
                }</span>
        } else<span class="cov0" title="0"> {
                parts_dash := strings.Split(x, "-")
                if len(parts_dash) == 2 </span><span class="cov0" title="0">{
                        start, _ = strconv.Atoi(parts_dash[0])
                        end, _ = strconv.Atoi(parts_dash[1])
                        for i := start; i &lt; end+1; i += step </span><span class="cov0" title="0">{
                                vals = append(vals, i)
                        }</span>
                } else<span class="cov0" title="0"> {
                        parts_comma := strings.Split(x, ",")
                        if len(parts_comma) &gt; 1 </span><span class="cov0" title="0">{
                                for _, i := range parts_comma </span><span class="cov0" title="0">{
                                        ii, _ := strconv.Atoi(i)
                                        vals = append(vals, ii)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                ii, _ := strconv.Atoi(x)
                                vals = append(vals, ii)
                        }</span>
                }
        }
        <span class="cov0" title="0">return utils.ContainsInt(vals, t)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package datastore

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/input"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"

        logger "github.com/jfcarter2358/go-logger"
)

type DataStore struct {
        Name    string            `json:"name" bson:"name" yaml:"name"`
        Env     map[string]string `json:"env" bson:"env" yaml:"env"`
        Files   []string          `json:"files" bson:"files" yaml:"files"`
        Created string            `json:"created" bson:"created" yaml:"created"`
        Updated string            `json:"updated" bson:"updated" yaml:"updated"`
}

// Create datastore object
func CreateDataStore(d *DataStore) error <span class="cov10" title="6">{
        currentTime := time.Now().UTC()
        d.Created = currentTime.Format("2006-01-02T15:04:05Z")
        d.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        dd, err := GetDataStoreByWorkflow(d.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting datastores: %s", err.Error())
        }</span>
        <span class="cov10" title="6">if dd != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("datastore already exists with name %s", d.Name)
        }</span>

        <span class="cov10" title="6">_, err = mongodb.Collections[constants.MONGODB_DATASTORE_COLLECTION_NAME].InsertOne(mongodb.Ctx, d)
        return err</span>
}

// Delete a datastore according to the associated workflow
func DeleteDataStoreByWorkflow(name string) error <span class="cov10" title="6">{
        filter := bson.M{"name": name}

        collection := mongodb.Collections[constants.MONGODB_DATASTORE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="6">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no datastore found with name %s", name)
        }</span>

        <span class="cov10" title="6">return nil</span>

}

// Get all the datastores
func GetAllDataStores() ([]*DataStore, error) <span class="cov0" title="0">{
        filter := bson.D{{}}

        datastores, err := FilterDataStores(filter)

        return datastores, err
}</span>

// Get a datastore by its associated workflow
func GetDataStoreByWorkflow(name string) (*DataStore, error) <span class="cov10" title="6">{
        filter := bson.M{"name": name}

        datastores, err := FilterDataStores(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="6">if len(datastores) == 0 </span><span class="cov10" title="6">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if len(datastores) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple datastores found with name %s", name)
        }</span>

        <span class="cov0" title="0">return datastores[0], nil</span>
}

// Update a datastore for a particular workflow
func UpdateDataStoreByWorkflow(name string, d *DataStore, is []input.Input) error <span class="cov0" title="0">{
        filter := bson.M{"name": name}

        currentTime := time.Now().UTC()
        d.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        toChange := []string{}
        old, err := GetDataStoreByWorkflow(name)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error getting datastore %s: %s\n", name, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">for key, val := range d.Env </span><span class="cov0" title="0">{
                if old.Env[key] != val </span><span class="cov0" title="0">{
                        toChange = append(toChange, key)
                }</span>
        }
        <span class="cov0" title="0">postBody, _ := json.Marshal(toChange)
        postBodyBuffer := bytes.NewBuffer(postBody)

        httpClient := http.Client{}
        requestURL := fmt.Sprintf("%s://%s:%d/api/v1/input/%s/update", config.Config.Node.ManagerProtocol, config.Config.Node.ManagerHost, config.Config.Node.ManagerPort, d.Name)
        req, _ := http.NewRequest("POST", requestURL, postBodyBuffer)
        req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return fmt.Errorf("received input update status code %d", resp.StatusCode)
        }</span>
        // }

        <span class="cov0" title="0">collection := mongodb.Collections[constants.MONGODB_DATASTORE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, d, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return CreateDataStore(d)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Filter the MongoDB response from a query
func FilterDataStores(filter interface{}) ([]*DataStore, error) <span class="cov10" title="6">{
        // A slice of tasks for storing the decoded documents
        var datastores []*DataStore

        collection := mongodb.Collections[constants.MONGODB_DATASTORE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return datastores, err
        }</span>

        <span class="cov10" title="6">for cur.Next(ctx) </span><span class="cov0" title="0">{
                var d DataStore
                err := cur.Decode(&amp;d)
                if err != nil </span><span class="cov0" title="0">{
                        return datastores, err
                }</span>

                <span class="cov0" title="0">datastores = append(datastores, &amp;d)</span>
        }

        <span class="cov10" title="6">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return datastores, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov10" title="6">cur.Close(ctx)

        return datastores, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "John Carter",
            "url": "https://github.com/jfcarter2358/scaffold/issues",
            "email": "jfcarter2358@gmail.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/license/mit/"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/datastore": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all datastores",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Get all datastores",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/datastore.DataStore"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a datastore from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Create a datastore",
                "parameters": [
                    {
                        "description": "DataStore Data",
                        "name": "datastore",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/datastore.DataStore"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/datastore/{workflow_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a datastore by its name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Get a datastore",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/datastore.DataStore"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a datastore from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Update a datastore",
                "parameters": [
                    {
                        "description": "DataStore Data",
                        "name": "datastore",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/datastore.DataStore"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a datastore by its name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "datastore"
                ],
                "summary": "Delete a datastore",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/file": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all files",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "file"
                ],
                "summary": "Get all files",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/filestore.ObjectMetadata"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/file/{datastore_name}": {
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Upload a file to a workflow",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "file"
                ],
                "summary": "Upload a file",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "400": {
                        "description": "Bad Request"
                    },
                    "401": {
                        "description": "Unauthorized"
                    },
                    "404": {
                        "description": "Not Found"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/api/v1/file/{workflow_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get files by workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "file"
                ],
                "summary": "Get files",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/filestore.ObjectMetadata"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/file/{workflow_name}/{file_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get file by workflow and name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "file"
                ],
                "summary": "Get file",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/filestore.ObjectMetadata"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/file/{workflow_name}/{file_name}/download": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Download a file from a workflow",
                "produces": [
                    "application/text"
                ],
                "tags": [
                    "manager",
                    "file"
                ],
                "summary": "Download a file",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "Unauthorized"
                    },
                    "404": {
                        "description": "Not Found"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/api/v1/history/{run_id}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a run history by a run ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "history"
                ],
                "summary": "Get a history",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/history.History"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all inputs",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Get all inputs",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/input.Input"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a input from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Create a input",
                "parameters": [
                    {
                        "description": "Input Data",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/input.Input"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input/{input_name}": {
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a input by its name and its workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Delete a input",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input/{workflow_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get inputs by their workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Get inputs",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/input.Input"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete inputs by their workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Delete inputs",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input/{workflow_name}/update": {
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Trigger updates of states for dependent tasks",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Trigger update to dependent tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/input/{workflow_name}/{input_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a input by its name and its workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Get a input",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/input.Input"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a input from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "input"
                ],
                "summary": "Update a input",
                "parameters": [
                    {
                        "description": "Input Data",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/input.Input"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/kill/{workflow_name}/{task_name}": {
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Kill a run on a worker",
                "tags": [
                    "worker",
                    "run"
                ],
                "summary": "Kill a run",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "Unauthorized"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/api/v1/run/{run_id}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get status of a run by ID",
                "tags": [
                    "manager",
                    "run"
                ],
                "summary": "Get run status",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/run/{workflow_name}/{task_name}": {
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a run from a workflow and task",
                "tags": [
                    "manager",
                    "run"
                ],
                "summary": "Create a run",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/run/{workflow_name}/{task_name}/{task_number}": {
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Instruct a manager to kill a run",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "run"
                ],
                "summary": "Kill a run",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/state": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all states",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Get all states",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/state.State"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a state from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Create a state",
                "parameters": [
                    {
                        "description": "State Data",
                        "name": "state",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/state.State"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/state/{workflow_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get states by their workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Get states",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/state.State"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete states by their workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Delete states",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/state/{workflow_name}/{state_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a state by its name and its workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Get a state",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/state.State"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a state from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Update a state",
                "parameters": [
                    {
                        "description": "State Data",
                        "name": "state",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/state.State"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a state by its name and its workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "state"
                ],
                "summary": "Delete a state",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all tasks",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Get all tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/task.Task"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a task from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Create a task",
                "parameters": [
                    {
                        "description": "Task Data",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/task.Task"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task/{task_name}": {
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a task by its name and its workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Delete a task",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task/{workflow_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get tasks by their workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Get tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/task.Task"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete tasks by their workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Delete tasks",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task/{workflow_name}/{task_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a task by its name and its workflow",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Get a task",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/task.Task"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a task from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Update a task",
                "parameters": [
                    {
                        "description": "Task Data",
                        "name": "task",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/task.Task"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/task/{workflow_name}/{task_name}/enabled": {
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a task from a JSON object",
                "tags": [
                    "manager",
                    "task"
                ],
                "summary": "Update a task",
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/user": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all users",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Get all users",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/user.User"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a user from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Create a user",
                "parameters": [
                    {
                        "description": "User Data",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/user/{user_name}": {
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a user from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Update a user",
                "parameters": [
                    {
                        "description": "User Data",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/user.User"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/user/{username}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a user by its username",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Get a user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/user.User"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a user by its username",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Delete a user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/webhook/{workflow_name}/{webhook_id}": {
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Trigger a webhook with optional input data",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "webhook"
                ],
                "summary": "Trigger a webhook",
                "parameters": [
                    {
                        "description": "Webhook input Data",
                        "name": "data",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/workflow": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get all workflows",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "workflow"
                ],
                "summary": "Get all workflows",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/workflow.Workflow"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Create a workflow from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "workflow"
                ],
                "summary": "Create a workflow",
                "parameters": [
                    {
                        "description": "Workflow Data",
                        "name": "workflow",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/workflow.Workflow"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/workflow/{workflow_name}": {
            "get": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Get a workflow by its name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "workflow"
                ],
                "summary": "Get a workflow",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/workflow.Workflow"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Update a workflow from a JSON object",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "workflow"
                ],
                "summary": "Update a workflow",
                "parameters": [
                    {
                        "description": "Workflow Data",
                        "name": "workflow",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/workflow.Workflow"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Delete a workflow by its name",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "workflow"
                ],
                "summary": "Delete a workflow",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/auth/token/{username}/{token_name}": {
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Generate an API token for a user",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Generate API Token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Revoke an API token for a user",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "manager",
                    "user"
                ],
                "summary": "Revoke API Token",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/health/available": {
            "get": {
                "description": "Get status from node succeeding if not containers are running",
                "tags": [
                    "worker",
                    "health"
                ],
                "summary": "Check if a worker node is available",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "503": {
                        "description": "Service Unavailable"
                    }
                }
            }
        },
        "/health/healthy": {
            "get": {
                "description": "Get node health",
                "tags": [
                    "manager",
                    "worker",
                    "health"
                ],
                "summary": "Check if a node is healthy",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "503": {
                        "description": "Service Unavailable"
                    }
                }
            }
        },
        "/health/ping/{name}": {
            "post": {
                "security": [
                    {
                        "X-Scaffold-API": []
                    }
                ],
                "description": "Ping manager to reset node age",
                "tags": [
                    "manager",
                    "health"
                ],
                "summary": "Ping manager",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "401": {
                        "description": "Unauthorized"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/health/ready": {
            "get": {
                "description": "Get node readiness",
                "tags": [
                    "manager",
                    "worker",
                    "health"
                ],
                "summary": "Check if a node is ready",
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "503": {
                        "description": "Service Unavailable"
                    }
                }
            }
        }
    },
    "definitions": {
        "datastore.DataStore": {
            "type": "object",
            "properties": {
                "created": {
                    "type": "string"
                },
                "env": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "files": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "updated": {
                    "type": "string"
                }
            }
        },
        "filestore.ObjectMetadata": {
            "type": "object",
            "properties": {
                "modified": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "workflow": {
                    "type": "string"
                }
            }
        },
        "history.History": {
            "type": "object",
            "properties": {
                "created": {
                    "type": "string"
                },
                "run_id": {
                    "type": "string"
                },
                "states": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/state.State"
                    }
                },
                "updated": {
                    "type": "string"
                },
                "workflow": {
                    "type": "string"
                }
            }
        },
        "input.Input": {
            "type": "object",
            "properties": {
                "default": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "workflow": {
                    "type": "string"
                }
            }
        },
        "state.State": {
            "type": "object",
            "properties": {
                "context": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "disabled": {
                    "type": "boolean"
                },
                "display": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "additionalProperties": true
                    }
                },
                "finished": {
                    "type": "string"
                },
                "history": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "killed": {
                    "type": "boolean"
                },
                "number": {
                    "type": "integer"
                },
                "output": {
                    "type": "string"
                },
                "output_checksum": {
                    "type": "string"
                },
                "pid": {
                    "type": "integer"
                },
                "started": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "task": {
                    "type": "string"
                },
                "worker": {
                    "type": "string"
                },
                "workflow": {
                    "type": "string"
                }
            }
        },
        "task.Task": {
            "type": "object",
            "properties": {
                "auto_execute": {
                    "type": "boolean"
                },
                "container_login_command": {
                    "description": "Check                 TaskCheck         ` + "`" + `json:\"check\" bson:\"check\" yaml:\"check\"` + "`" + `",
                    "type": "string"
                },
                "cron": {
                    "type": "string"
                },
                "depends_on": {
                    "$ref": "#/definitions/task.TaskDependsOn"
                },
                "disabled": {
                    "type": "boolean"
                },
                "env": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "image": {
                    "type": "string"
                },
                "inputs": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "kind": {
                    "type": "string"
                },
                "load": {
                    "$ref": "#/definitions/task.TaskLoadStore"
                },
                "name": {
                    "type": "string"
                },
                "run": {
                    "type": "string"
                },
                "run_number": {
                    "type": "integer"
                },
                "should_rm": {
                    "type": "boolean"
                },
                "store": {
                    "$ref": "#/definitions/task.TaskLoadStore"
                },
                "updated": {
                    "type": "string"
                },
                "workflow": {
                    "type": "string"
                }
            }
        },
        "task.TaskDependsOn": {
            "type": "object",
            "properties": {
                "always": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "error": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "success": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "task.TaskLoadStore": {
            "type": "object",
            "properties": {
                "env": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "env_passthrough": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "file": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "mounts": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "user.APIToken": {
            "type": "object",
            "properties": {
                "created": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "user.User": {
            "type": "object",
            "properties": {
                "api_tokens": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/user.APIToken"
                    }
                },
                "created": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "family_name": {
                    "type": "string"
                },
                "given_name": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "login_token": {
                    "type": "string"
                },
                "password": {
                    "type": "string"
                },
                "reset_token": {
                    "type": "string"
                },
                "reset_token_created": {
                    "type": "string"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "updated": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "workflow.Workflow": {
            "type": "object",
            "properties": {
                "created": {
                    "type": "string"
                },
                "groups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "inputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/input.Input"
                    }
                },
                "links": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "tasks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/task.Task"
                    }
                },
                "updated": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "2.0",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "Scaffold Swagger API",
        Description:      "Scaffold workflow tool",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov10" title="2">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package filestore

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "mime/multipart"
        "net/http"
        "os"
        "path/filepath"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/workflow"
        "strings"

        logger "github.com/jfcarter2358/go-logger"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
)

var S3Config *aws.Config

type ObjectMetadata struct {
        Name     string `json:"name" bson:"name" yaml:"name"`
        Modified string `json:"modified" bson:"modified" yaml:"modified"`
        Workflow string `json:"workflow" bson:"workflow" yaml:"workflow"`
}

func InitBucket() <span class="cov10" title="2">{
        if config.Config.FileStore.Type == constants.FILESTORE_TYPE_S3 </span><span class="cov10" title="2">{
                bucket := aws.String(config.Config.FileStore.Bucket)

                // Configure to use MinIO Server
                if config.Config.FileStore.AccessKey != "" &amp;&amp; config.Config.FileStore.SecretKey != "" </span><span class="cov10" title="2">{
                        logger.Tracef("", "logging in with access and secret keys")
                        S3Config = &amp;aws.Config{
                                Credentials:      credentials.NewStaticCredentials(config.Config.FileStore.AccessKey, config.Config.FileStore.SecretKey, ""),
                                Endpoint:         aws.String(fmt.Sprintf("%s://%s:%d", config.Config.FileStore.Protocol, config.Config.FileStore.Host, config.Config.FileStore.Port)),
                                Region:           aws.String(config.Config.FileStore.Region),
                                DisableSSL:       aws.Bool(false),
                                S3ForcePathStyle: aws.Bool(true),
                        }
                }</span> else<span class="cov0" title="0"> {
                        logger.Tracef("", "logging in with AWS credentials")
                        S3Config = &amp;aws.Config{
                                Endpoint:         aws.String(fmt.Sprintf("%s://%s:%d", config.Config.FileStore.Protocol, config.Config.FileStore.Host, config.Config.FileStore.Port)),
                                Region:           aws.String(config.Config.FileStore.Region),
                                DisableSSL:       aws.Bool(false),
                                S3ForcePathStyle: aws.Bool(true),
                        }
                }</span>
                <span class="cov10" title="2">session, err := session.NewSession(S3Config)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov10" title="2">client := s3.New(session)

                cparams := &amp;s3.CreateBucketInput{
                        Bucket: bucket, // Required
                }

                buckets, err := client.ListBuckets(nil)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov10" title="2">alreadyExists := false
                for _, bucket := range buckets.Buckets </span><span class="cov1" title="1">{
                        if *bucket.Name == config.Config.FileStore.Bucket </span><span class="cov1" title="1">{
                                alreadyExists = true
                                break</span>
                        }
                }

                <span class="cov10" title="2">if !alreadyExists </span><span class="cov1" title="1">{
                        // Create a new bucket using the CreateBucket call.
                        _, err := client.CreateBucket(cparams)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Encountered error with creating bucket: %v", err)
                                // panic(err)
                        }</span>
                }
        }
}

func GetFile(inputPath, outputPath string) error <span class="cov0" title="0">{
        switch config.Config.FileStore.Type </span>{
        case constants.FILESTORE_TYPE_S3:<span class="cov0" title="0">
                return doS3Download(inputPath, outputPath)</span>
        case constants.FILESTORE_TYPE_ARTIFACTORY:<span class="cov0" title="0">
                return doArtifactoryDownload(inputPath, outputPath)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid filestore type: %s", config.Config.FileStore.Type)</span>
}

func UploadFile(inputPath, outputPath string) error <span class="cov0" title="0">{
        switch config.Config.FileStore.Type </span>{
        case constants.FILESTORE_TYPE_S3:<span class="cov0" title="0">
                return doS3Upload(inputPath, outputPath)</span>
        case constants.FILESTORE_TYPE_ARTIFACTORY:<span class="cov0" title="0">
                return doArtifactoryUpload(inputPath, outputPath)</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("invalid filestore type: %s", config.Config.FileStore.Type)</span>
}

func ListObjects() (map[string]ObjectMetadata, error) <span class="cov0" title="0">{
        switch config.Config.FileStore.Type </span>{
        case constants.FILESTORE_TYPE_S3:<span class="cov0" title="0">
                return doS3List()</span>
        case constants.FILESTORE_TYPE_ARTIFACTORY:<span class="cov0" title="0">
                return doArtifactoryList()</span>
        }
        <span class="cov0" title="0">return map[string]ObjectMetadata{}, fmt.Errorf("invalid filestore type: %s", config.Config.FileStore.Type)</span>
}

func doArtifactoryDownload(inputPath, outputPath string) error <span class="cov0" title="0">{
        uri := fmt.Sprintf("%s://%s:%d/artifactory/%s", config.Config.FileStore.Protocol, config.Config.FileStore.Host, config.Config.FileStore.Port, config.Config.FileStore.Bucket)

        // Create the file
        out, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">defer out.Close()

        // Get the data
        httpClient := &amp;http.Client{}
        requestURL := fmt.Sprintf("%s/%s", uri, inputPath)
        req, _ := http.NewRequest("GET", requestURL, nil)
        req.SetBasicAuth(config.Config.FileStore.AccessKey, config.Config.FileStore.SecretKey)
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return fmt.Errorf("got status code %d on file download", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("", "Encountered error reading body: %s", err.Error())
        }</span>
        <span class="cov0" title="0">strBody := string(body)
        lines := strings.Split(strBody, "\n")
        lines = lines[4 : len(lines)-2]
        data := []byte(strings.Join(lines, "\n"))

        // Writer the body to file
        // _, err = io.Copy(out, resp.Body)
        _, err = out.Write(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func doArtifactoryList() (map[string]ObjectMetadata, error) <span class="cov0" title="0">{
        output := make(map[string]ObjectMetadata)
        workflows, _ := workflow.GetAllWorkflows()
        uri := fmt.Sprintf("%s://%s:%d/artifactory/%s", config.Config.FileStore.Protocol, config.Config.FileStore.Host, config.Config.FileStore.Port, config.Config.FileStore.Bucket)
        for _, c := range workflows </span><span class="cov0" title="0">{
                // Get the data
                httpClient := &amp;http.Client{}
                requestURL := fmt.Sprintf("%s/%s", uri, c.Name)
                req, _ := http.NewRequest("GET", requestURL, nil)
                req.SetBasicAuth(config.Config.FileStore.AccessKey, config.Config.FileStore.SecretKey)
                resp, err := httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return map[string]ObjectMetadata{}, err
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                        return map[string]ObjectMetadata{}, fmt.Errorf("got status code %d on file list", resp.StatusCode)
                }</span>

                <span class="cov0" title="0">var data map[string]interface{}
                //Read the response body
                body, err := ioutil.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return map[string]ObjectMetadata{}, err
                }</span>
                <span class="cov0" title="0">json.Unmarshal(body, &amp;data)
                resp.Body.Close()

                logger.Debugf("", "Artifactory list response: %v", data)

                if data["children"] != nil </span><span class="cov0" title="0">{
                        for _, item := range data["children"].([]interface{}) </span><span class="cov0" title="0">{
                                itemMap := item.(map[string]interface{})
                                path := itemMap["uri"].(string)
                                name := path[1:]
                                lastModified, err := getArtifactoryLastModified(fmt.Sprintf("%s/%s", requestURL, name))
                                if err != nil </span><span class="cov0" title="0">{
                                        return map[string]ObjectMetadata{}, err
                                }</span>
                                <span class="cov0" title="0">output[name] = ObjectMetadata{
                                        Name:     fmt.Sprintf("%s/%s", c.Name, name),
                                        Modified: lastModified,
                                        Workflow: c.Name,
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return output, nil</span>
}

func getArtifactoryLastModified(url string) (string, error) <span class="cov0" title="0">{
        httpClient := &amp;http.Client{}
        req, _ := http.NewRequest("GET", url, nil)
        req.SetBasicAuth(config.Config.FileStore.AccessKey, config.Config.FileStore.SecretKey)
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("got status code %d on file last modified get", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var data map[string]interface{}
        //Read the response body
        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">json.Unmarshal(body, &amp;data)
        resp.Body.Close()

        return data["lastModified"].(string), nil</span>
}

func doArtifactoryUpload(inputPath, outputPath string) error <span class="cov0" title="0">{
        uri := fmt.Sprintf("%s://%s:%d/artifactory/%s", config.Config.FileStore.Protocol, config.Config.FileStore.Host, config.Config.FileStore.Port, config.Config.FileStore.Bucket)

        file, _ := os.Open(inputPath)
        defer file.Close()

        body := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(body)
        part, _ := writer.CreateFormFile("file", filepath.Base(file.Name()))
        io.Copy(part, file)
        writer.Close()

        httpClient := &amp;http.Client{}
        requestURL := fmt.Sprintf("%s/%s", uri, outputPath)
        req, _ := http.NewRequest("PUT", requestURL, body)
        req.SetBasicAuth(config.Config.FileStore.AccessKey, config.Config.FileStore.SecretKey)
        req.Header.Add("Content-Type", writer.FormDataContentType())

        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return fmt.Errorf("got status code %d on file upload", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func doS3Download(inputPath, outputPath string) error <span class="cov0" title="0">{
        session, err := session.NewSession(S3Config)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">downloader := s3manager.NewDownloader(session)
        file, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer file.Close()

        _, err = downloader.Download(
                file,
                &amp;s3.GetObjectInput{
                        Bucket: aws.String(config.Config.FileStore.Bucket),
                        Key:    aws.String(inputPath),
                },
        )

        return err</span>
}

func doS3List() (map[string]ObjectMetadata, error) <span class="cov0" title="0">{
        session, err := session.NewSession(S3Config)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">svc := s3.New(session)

        resp, err := svc.ListObjectsV2(&amp;s3.ListObjectsV2Input{Bucket: aws.String(config.Config.FileStore.Bucket)})
        if err != nil </span><span class="cov0" title="0">{
                return map[string]ObjectMetadata{}, err
        }</span>

        <span class="cov0" title="0">output := make(map[string]ObjectMetadata)

        for _, item := range resp.Contents </span><span class="cov0" title="0">{
                workflow := strings.Split(*item.Key, "/")[0]
                output[*item.Key] = ObjectMetadata{
                        Name:     *item.Key,
                        Modified: (*item.LastModified).Format("2006-01-02T15:04:05Z"),
                        Workflow: workflow,
                }
        }</span>
        <span class="cov0" title="0">return output, nil</span>
}

func doS3Upload(inputPath, outputPath string) error <span class="cov0" title="0">{
        session, err := session.NewSession(S3Config)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">uploader := s3manager.NewUploader(session)
        file, err := os.Open(inputPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer file.Close()

        _, err = uploader.Upload(&amp;s3manager.UploadInput{
                Bucket: aws.String(config.Config.FileStore.Bucket),
                Key:    aws.String(outputPath),
                Body:   file,
        })

        return err</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package history

import (
        "fmt"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/state"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"

        logger "github.com/jfcarter2358/go-logger"
)

type History struct {
        RunID    string        `json:"run_id" bson:"run_id" yaml:"run_id"`
        States   []state.State `json:"states" bson:"states" yaml:"states"`
        Workflow string        `json:"workflow" bson:"workflow" yaml:"workflow"`
        Created  string        `json:"created" bson:"created" yaml:"created"`
        Updated  string        `json:"updated" bson:"updated" yaml:"updated"`
}

func PruneHistories() <span class="cov0" title="0">{
        now := time.Now()
        histories, err := GetAllHistories()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot get histories: %s", err.Error())
                return
        }</span>
        <span class="cov0" title="0">for _, h := range histories </span><span class="cov0" title="0">{
                t, err := time.Parse(h.Updated, "2006-01-02 15:04:05")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Cannot parse history updated timestamp of %s: %s", h.Updated, err.Error())
                }</span>
                <span class="cov0" title="0">diff := now.Sub(t)
                if diff.Hours() &gt; float64(config.Config.RunPruneDuration) </span><span class="cov0" title="0">{
                        if err := DeleteHistoryByRunID(h.RunID); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Cannot delete history with run ID %s: %s", h.RunID, err.Error())
                        }</span>
                }
        }
}

func AddStateToHistory(runID string, s state.State) error <span class="cov0" title="0">{
        h, err := GetHistoryByRunID(runID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if h == nil </span><span class="cov0" title="0">{
                h = &amp;History{
                        Workflow: s.Workflow,
                        States:   make([]state.State, 0),
                        RunID:    runID,
                }
        }</span>
        <span class="cov0" title="0">for idx, ss := range h.States </span><span class="cov0" title="0">{
                if ss.Workflow == s.Workflow &amp;&amp; ss.Task == s.Task </span><span class="cov0" title="0">{
                        h.States[idx] = s
                        if err := UpdateHistoryByRunID(runID, h); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }
        <span class="cov0" title="0">h.States = append(h.States, s)
        err = UpdateHistoryByRunID(runID, h)
        return err</span>
}

func CreateHistory(h *History) error <span class="cov0" title="0">{
        currentTime := time.Now().UTC()
        h.Created = currentTime.Format("2006-01-02T15:04:05Z")
        h.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        logger.Errorf("", "Creating history for %s", h.RunID)

        hh, err := GetHistoryByRunID(h.RunID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting histories: %s", err.Error())
        }</span>
        <span class="cov0" title="0">if hh != nil </span><span class="cov0" title="0">{
                logger.Errorf("history already exists with run ID %s", hh.RunID)
                return UpdateHistoryByRunID(h.RunID, h)
        }</span>

        <span class="cov0" title="0">_, err = mongodb.Collections[constants.MONGODB_HISTORY_COLLECTION_NAME].InsertOne(mongodb.Ctx, h)
        return err</span>
}

func DeleteHistoryByRunID(runID string) error <span class="cov0" title="0">{
        filter := bson.M{"run_id": runID}

        collection := mongodb.Collections[constants.MONGODB_HISTORY_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no history found with run ID %s", runID)
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func GetAllHistories() ([]*History, error) <span class="cov0" title="0">{
        filter := bson.D{{}}

        datastores, err := FilterHistories(filter)

        return datastores, err
}</span>

func GetHistoryByRunID(runID string) (*History, error) <span class="cov0" title="0">{
        filter := bson.M{"run_id": runID}

        histories, err := FilterHistories(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(histories) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if len(histories) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple history found with run ID %s", runID)
        }</span>

        <span class="cov0" title="0">return histories[0], nil</span>
}

func UpdateHistoryByRunID(runID string, h *History) error <span class="cov0" title="0">{
        filter := bson.M{"run_id": runID}

        currentTime := time.Now().UTC()
        h.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        collection := mongodb.Collections[constants.MONGODB_HISTORY_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        _, err := collection.ReplaceOne(ctx, filter, h, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logger.Errorf("", "Inserted history with runID %s", runID)

        hh, err := GetAllHistories()
        logger.Errorf("", "Current histories: %v", hh)

        // if result.ModifiedCount == 0 {
        //         return CreateHistory(h)
        //         // return fmt.Errorf("no datastore found with name %s", name)
        // }

        return err</span>
}

func FilterHistories(filter interface{}) ([]*History, error) <span class="cov0" title="0">{
        // A slice of tasks for storing the decoded documents
        var histories []*History

        collection := mongodb.Collections[constants.MONGODB_HISTORY_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return histories, err
        }</span>

        <span class="cov0" title="0">for cur.Next(ctx) </span><span class="cov0" title="0">{
                var h History
                err := cur.Decode(&amp;h)
                if err != nil </span><span class="cov0" title="0">{
                        return histories, err
                }</span>

                <span class="cov0" title="0">histories = append(histories, &amp;h)</span>
        }

        <span class="cov0" title="0">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return histories, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov0" title="0">cur.Close(ctx)

        return histories, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package input

import (
        "fmt"
        "scaffold/server/constants"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"
)

type Input struct {
        Name        string `json:"name" bson:"name" yaml:"name"`
        Workflow    string `json:"workflow" bson:"workflow" yaml:"workflow"`
        Description string `json:"description" bson:"description" yaml:"description"`
        Default     string `json:"default" bson:"default" yaml:"default"`
        Type        string `json:"type" bson:"type" yaml:"type"`
}

func CreateInput(i *Input) error <span class="cov10" title="12">{
        ii, err := GetInputByNames(i.Workflow, i.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting inputs: %s", err.Error())
        }</span>
        <span class="cov10" title="12">if ii != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("input already exists with names %s, %s", i.Workflow, i.Name)
        }</span>

        <span class="cov10" title="12">_, err = mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME].InsertOne(mongodb.Ctx, i)
        return err</span>
}

func DeleteInputByNames(workflow, name string) error <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "name": name}

        collection := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no input found with names %s, %s", workflow, name)
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func DeleteInputsByWorkflow(workflow string) error <span class="cov7" title="6">{
        filter := bson.M{"workflow": workflow}

        collection := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteMany(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="6">if result.DeletedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no inputs found with workflow %s", workflow)
        }</span>

        <span class="cov7" title="6">return nil</span>

}

func GetAllInputs() ([]*Input, error) <span class="cov0" title="0">{
        filter := bson.D{{}}

        inputs, err := FilterInputs(filter)

        return inputs, err
}</span>

func GetInputByNames(workflow, name string) (*Input, error) <span class="cov10" title="12">{
        filter := bson.M{"workflow": workflow, "name": name}

        inputs, err := FilterInputs(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="12">if len(inputs) == 0 </span><span class="cov10" title="12">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if len(inputs) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple inputs found with names %s, %s", workflow, name)
        }</span>

        <span class="cov0" title="0">return inputs[0], nil</span>
}

func GetInputsByWorkflow(workflow string) ([]*Input, error) <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow}

        inputs, err := FilterInputs(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return inputs, nil</span>
}

func UpdateInputByNames(workflow, name string, i *Input) error <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "name": name}

        collection := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, i, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return CreateInput(i)
                // return fmt.Errorf("no input found with names %s, %s", workflow, name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func FilterInputs(filter interface{}) ([]*Input, error) <span class="cov10" title="12">{
        // A slice of inputs for storing the decoded documents
        var inputs []*Input

        collection := mongodb.Collections[constants.MONGODB_INPUT_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return inputs, err
        }</span>

        <span class="cov10" title="12">for cur.Next(ctx) </span><span class="cov0" title="0">{
                var s Input
                err := cur.Decode(&amp;s)
                if err != nil </span><span class="cov0" title="0">{
                        return inputs, err
                }</span>

                <span class="cov0" title="0">inputs = append(inputs, &amp;s)</span>
        }

        <span class="cov10" title="12">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return inputs, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov10" title="12">cur.Close(ctx)

        return inputs, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// main.go

package main

import (
        "context"
        "crypto/tls"
        "fmt"
        "math/rand"
        "net/http"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/filestore"
        "scaffold/server/manager"
        "scaffold/server/mongodb"
        "scaffold/server/rabbitmq"
        "scaffold/server/worker"
        "time"

        logger "github.com/jfcarter2358/go-logger"

        "github.com/gin-gonic/gin"
)

var router *gin.Engine

func run(ctx context.Context, channel chan struct{}) <span class="cov10" title="2">{
        // Set Gin to production mode
        gin.SetMode(gin.ReleaseMode)

        config.LoadConfig()
        logger.SetLevel(config.Config.LogLevel)
        logger.SetFormat(config.Config.LogFormat)

        http.DefaultTransport.(*http.Transport).TLSClientConfig = &amp;tls.Config{InsecureSkipVerify: config.Config.TLSSkipVerify}

        router = gin.New()
        router.Use(gin.LoggerWithFormatter(logger.ConsoleLogFormatter))
        router.Use(gin.Recovery())

        logger.Infof("", "Running with port: %d", config.Config.Port)

        initializeRoutes()

        rand.Seed(time.Now().UnixNano())

        mongodb.InitCollections()
        filestore.InitBucket()

        if config.Config.Node.Type == constants.NODE_TYPE_MANAGER </span><span class="cov1" title="1">{
                rabbitmq.RunManagerProducer()
                go manager.Run()
                go rabbitmq.RunConsumer(manager.QueueDataReceive, config.Config.ManagerQueueName)
        }</span> else<span class="cov1" title="1"> {
                rabbitmq.RunWorkerProducer()
                go worker.Run()
                go rabbitmq.RunConsumer(worker.QueueDataReceive, config.Config.WorkerQueueName)
                // go rabbitmq.RunConsumer(worker.)
        }</span>

        <span class="cov10" title="2">routerPort := fmt.Sprintf(":%d", config.Config.Port)
        if config.Config.TLSEnabled </span><span class="cov0" title="0">{
                logger.Infof("", "Running with TLS loaded from %s and %s", config.Config.TLSCrtPath, config.Config.TLSKeyPath)
                router.RunTLS(routerPort, config.Config.TLSCrtPath, config.Config.TLSKeyPath)
        }</span> else<span class="cov10" title="2"> {
                router.Run(routerPort)
        }</span>
        // for {
        //         select {
        //         case &lt;-ctx.Done(): // if cancel() execute
        //                 channel &lt;- struct{}{}
        //                 return
        //         default:
        //                 // foobar
        //         }

        //         time.Sleep(1 * time.Second)
        // }
}

//        @title                        Scaffold Swagger API
//        @version                2.0
//        @description        Scaffold workflow tool
//        @termsOfService        http://swagger.io/terms/

//        @contact.name        John Carter
//        @contact.url        https://github.com/jfcarter2358/scaffold/issues
//        @contact.email        jfcarter2358@gmail.com

//        @license.name        MIT
//        @license.url        https://opensource.org/license/mit/
func main() <span class="cov0" title="0">{
        channel := make(chan struct{})
        ctx, _ := context.WithCancel(context.Background())
        run(ctx, channel)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package manager

import (
        "encoding/json"
        "fmt"
        "log"
        "net"
        "net/http"
        "scaffold/server/auth"
        "scaffold/server/config"
        "scaffold/server/constants"
        scron "scaffold/server/cron"
        "scaffold/server/health"
        "scaffold/server/history"
        "scaffold/server/msg"
        "scaffold/server/proxy"
        "scaffold/server/rabbitmq"
        "scaffold/server/state"
        "scaffold/server/task"
        "scaffold/server/user"
        "scaffold/server/utils"
        "scaffold/server/workflow"
        "time"

        "github.com/google/uuid"
        logger "github.com/jfcarter2358/go-logger"

        "github.com/gorilla/mux"
)

var toKill []string

type UINode struct {
        Status  string
        Name    string
        IP      string
        Version string
        Color   string
        Text    string
        Icon    string
}

func Run() <span class="cov1" title="1">{
        // r := http.NewServeMux()
        r := mux.NewRouter()
        // mux.Handle("/ws", websocket.Handler(run))
        r.HandleFunc("/{host}/{port}/{workflow}/{run}/{version}",
                func(w http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                        proxy.NewProxy().ServeHTTP(w, req)
                }</span>)

        // http.Handle("/api/someAPI", apiHandler)
        // go http.ListenAndServe(fmt.Sprintf(":%d", config.Config.WSPort), proxy.NewProxy())

        <span class="cov1" title="1">server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", config.Config.WSPort),
                Handler: r,
        }

        go func() </span><span class="cov1" title="1">{
                if config.Config.TLSEnabled </span><span class="cov0" title="0">{
                        if serverErr := server.ListenAndServeTLS(config.Config.TLSCrtPath, config.Config.TLSKeyPath); serverErr != nil </span><span class="cov0" title="0">{
                                logger.Fatalf("", "Error running websocket server: %s", serverErr)
                        }</span>
                } else<span class="cov1" title="1"> {
                        if serverErr := server.ListenAndServe(); serverErr != nil </span><span class="cov0" title="0">{
                                logger.Fatalf("", "Error running websocket server: %s", serverErr)
                        }</span>
                }
        }()

        <span class="cov1" title="1">toKill = make([]string, 0)

        health.IsHealthy = true

        if err := user.VerifyAdmin(); err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("", "Unable to create admin user: %s", err.Error())
        }</span>
        <span class="cov1" title="1">auth.Nodes = make(map[string]auth.NodeObject)

        health.IsReady = true

        go healthCheck()

        ws, err := workflow.GetAllWorkflows()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov1" title="1">workflow.SetCache(ws)

        scron.Start()</span>
}

func QueueDataReceive(data []byte) error <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var m msg.RunMsg
        if err := json.Unmarshal([]byte(data), &amp;m); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error processing queue message: %s", err.Error())
                return err
        }</span>
        <span class="cov0" title="0">switch m.Status </span>{
        case constants.STATE_STATUS_SUCCESS:<span class="cov0" title="0">
                logger.Debugf("", "Task %s has completed with status success", m.Task)
                if err := history.AddStateToHistory(m.RunID, m.State); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error updating history: %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">stateChange(m.Workflow, m.Task, constants.STATE_STATUS_SUCCESS, m.Context, m.RunID)
                autoTrigger(m.Workflow, m.Task, constants.STATUS_TRIGGER_SUCCESS, m.Context, m.RunID)
                autoTrigger(m.Workflow, m.Task, constants.STATUS_TRIGGER_ALWAYS, m.Context, m.RunID)</span>
        case constants.STATE_STATUS_ERROR:<span class="cov0" title="0">
                logger.Debugf("", "Task %s has completed with status error", m.Task)
                if err := history.AddStateToHistory(m.RunID, m.State); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error updating history: %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">stateChange(m.Workflow, m.Task, constants.STATE_STATUS_ERROR, m.Context, m.RunID)
                autoTrigger(m.Workflow, m.Task, constants.STATUS_TRIGGER_ERROR, m.Context, m.RunID)
                autoTrigger(m.Workflow, m.Task, constants.STATUS_TRIGGER_ALWAYS, m.Context, m.RunID)</span>
        case constants.STATE_STATUS_KILLED:<span class="cov0" title="0">
                logger.Debugf("", "Task %s has completed with status killed", m.Task)
                if err := history.AddStateToHistory(m.RunID, m.State); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error updating history: %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">id := fmt.Sprintf("%s-%s", m.Workflow, m.Task)
                toKill = utils.Remove(toKill, id)
                if err := rabbitmq.KillPublish(map[string]string{"id": id}); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error publishing kill id: %s", err.Error())
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func BufferDataReceive(endpoint, data string) error <span class="cov0" title="0">{
        // if len(data) == 0 {
        //         return nil
        // }
        // var m msg.RunMsg
        // if err := json.Unmarshal([]byte(data), &amp;m); err != nil {
        //         logger.Errorf("", "Error processing buffer message: %s", err.Error())
        //         return err
        // }

        // if m.Status == constants.STATE_STATUS_SUCCESS {
        //         logger.Debugf("", "Task %s has completed with success", m.Task)
        //         stateChange(m.Workflow, m.Task, constants.STATUS_TRIGGER_SUCCESS)
        //         stateChange(m.Workflow, m.Task, constants.STATUS_TRIGGER_ALWAYS)
        // } else if m.Status == constants.STATE_STATUS_ERROR {
        //         logger.Debugf("", "Task %s has completed with error", m.Task)
        //         stateChange(m.Workflow, m.Task, constants.STATUS_TRIGGER_ERROR)
        //         stateChange(m.Workflow, m.Task, constants.STATUS_TRIGGER_ALWAYS)
        // }
        return nil
}</span>

func healthCheck() <span class="cov1" title="1">{
        for </span><span class="cov8" title="34">{
                for key, n := range auth.Nodes </span><span class="cov10" title="66">{
                        if n.Ping &gt; config.Config.HeartbeatBackoff </span><span class="cov6" title="12">{
                                ss, err := state.GetStatesByWorker(n.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("", "Unable to get states by worker: %s", n.Name)
                                }</span>
                                <span class="cov6" title="12">for _, s := range ss </span><span class="cov0" title="0">{
                                        switch s.Status </span>{
                                        case constants.STATE_STATUS_RUNNING:<span class="cov0" title="0">
                                                DoKill(s.Workflow, s.Task)</span>
                                        case constants.STATE_STATUS_WAITING:<span class="cov0" title="0">
                                                DoKill(s.Workflow, s.Task)</span>
                                        }
                                }
                        }
                        <span class="cov10" title="66">n.Ping += 1
                        auth.NodeLock.Lock()
                        auth.Nodes[key] = n
                        auth.NodeLock.Unlock()</span>
                }
                <span class="cov8" title="34">time.Sleep(time.Duration(config.Config.HeartbeatInterval) * time.Millisecond)</span>
        }
}

func stateChange(cn, tn, status string, context map[string]string, runID string) error <span class="cov0" title="0">{
        ss, err := state.GetStateByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot get state for %s", cn)
                return err
        }</span>
        <span class="cov0" title="0">ss.Context = utils.MergeDict(ss.Context, context)
        if err := state.UpdateStateByNames(cn, tn, ss); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ts, err := task.GetTasksByWorkflow(cn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot change state for %s", cn)
                return err
        }</span>
        <span class="cov0" title="0">switch status </span>{
        case constants.STATE_STATUS_SUCCESS:<span class="cov0" title="0">
                for _, t := range ts </span><span class="cov0" title="0">{
                        shouldExecute := false
                        sss, err := state.GetStateByNames(cn, t.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">for _, n := range t.DependsOn.Always </span><span class="cov0" title="0">{

                                if n == tn </span><span class="cov0" title="0">{
                                        sss.Context = utils.MergeDict(sss.Context, context)
                                        if err := state.UpdateStateByNames(cn, t.Name, sss); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if t.AutoExecute </span><span class="cov0" title="0">{
                                                shouldExecute = true
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">s, err := state.GetStateByNames(cn, n)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_ERROR &amp;&amp; s.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">for _, n := range t.DependsOn.Success </span><span class="cov0" title="0">{
                                if n == tn </span><span class="cov0" title="0">{
                                        sss.Context = utils.MergeDict(sss.Context, context)
                                        if err := state.UpdateStateByNames(cn, t.Name, sss); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if t.AutoExecute </span><span class="cov0" title="0">{
                                                shouldExecute = true
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">s, err := state.GetStateByNames(cn, n)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if s == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">if shouldExecute </span><span class="cov0" title="0">{
                                if err := stateChange(cn, t.Name, constants.STATE_STATUS_NOT_STARTED, context, runID); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        case constants.STATE_STATUS_ERROR:<span class="cov0" title="0">
                for _, t := range ts </span><span class="cov0" title="0">{
                        shouldExecute := false
                        sss, err := state.GetStateByNames(cn, t.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">for _, n := range t.DependsOn.Always </span><span class="cov0" title="0">{

                                if n == tn </span><span class="cov0" title="0">{
                                        sss.Context = utils.MergeDict(sss.Context, context)
                                        if err := state.UpdateStateByNames(cn, t.Name, sss); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if t.AutoExecute </span><span class="cov0" title="0">{
                                                shouldExecute = true
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">s, err := state.GetStateByNames(cn, n)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_ERROR &amp;&amp; s.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">for _, n := range t.DependsOn.Error </span><span class="cov0" title="0">{
                                if n == tn </span><span class="cov0" title="0">{
                                        sss.Context = utils.MergeDict(sss.Context, context)
                                        if err := state.UpdateStateByNames(cn, t.Name, sss); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if t.AutoExecute </span><span class="cov0" title="0">{
                                                shouldExecute = true
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">s, err := state.GetStateByNames(cn, n)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if s == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                        <span class="cov0" title="0">if shouldExecute </span><span class="cov0" title="0">{
                                if err := stateChange(cn, t.Name, constants.STATE_STATUS_NOT_STARTED, context, runID); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        case constants.STATE_STATUS_NOT_STARTED:<span class="cov0" title="0">
                for _, t := range ts </span><span class="cov0" title="0">{
                        for _, n := range t.DependsOn.Always </span><span class="cov0" title="0">{
                                if n == tn </span><span class="cov0" title="0">{
                                        s, err := state.GetStateByNames(cn, t.Name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">s.Status = constants.STATE_STATUS_NOT_STARTED
                                        if err := state.UpdateStateByNames(cn, t.Name, s); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if err := stateChange(cn, t.Name, constants.STATE_STATUS_NOT_STARTED, context, runID); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">for _, n := range t.DependsOn.Error </span><span class="cov0" title="0">{
                                if n == tn </span><span class="cov0" title="0">{
                                        s, err := state.GetStateByNames(cn, t.Name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">s.Status = constants.STATE_STATUS_NOT_STARTED
                                        if err := state.UpdateStateByNames(cn, t.Name, s); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if err := stateChange(cn, t.Name, constants.STATE_STATUS_NOT_STARTED, context, runID); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">for _, n := range t.DependsOn.Success </span><span class="cov0" title="0">{
                                if n == tn </span><span class="cov0" title="0">{
                                        s, err := state.GetStateByNames(cn, t.Name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">s.Status = constants.STATE_STATUS_NOT_STARTED
                                        if err := state.UpdateStateByNames(cn, t.Name, s); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if err := stateChange(cn, t.Name, constants.STATE_STATUS_NOT_STARTED, context, runID); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func checkDeps(cn string, t *task.Task) (bool, error) <span class="cov0" title="0">{
        for _, n := range t.DependsOn.Success </span><span class="cov0" title="0">{
                s, err := state.GetStateByNames(cn, n)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">for _, n := range t.DependsOn.Error </span><span class="cov0" title="0">{
                s, err := state.GetStateByNames(cn, n)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">for _, n := range t.DependsOn.Always </span><span class="cov0" title="0">{
                s, err := state.GetStateByNames(cn, n)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_SUCCESS &amp;&amp; s.Status != constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func autoTrigger(cn, tn, status string, context map[string]string, runID string) error <span class="cov0" title="0">{
        logger.Debugf("", "Doing auto trigger for %s %s with status %s", cn, tn, status)
        ts, err := task.GetTasksByWorkflow(cn)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot perform auto trigger for %s", cn)
                return err
        }</span>
        <span class="cov0" title="0">toTrigger := []string{}

        switch status </span>{
        case constants.STATUS_TRIGGER_SUCCESS:<span class="cov0" title="0">
                for _, t := range ts </span><span class="cov0" title="0">{
                        if utils.Contains(t.DependsOn.Success, tn) &amp;&amp; t.AutoExecute </span><span class="cov0" title="0">{
                                trigger, err := checkDeps(cn, t)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("", "Error checking dependency states: %s", err.Error())
                                        return err
                                }</span>
                                <span class="cov0" title="0">if trigger </span><span class="cov0" title="0">{
                                        toTrigger = append(toTrigger, t.Name)
                                }</span>
                        }
                }
        case constants.STATUS_TRIGGER_ERROR:<span class="cov0" title="0">
                for _, t := range ts </span><span class="cov0" title="0">{
                        if utils.Contains(t.DependsOn.Error, tn) &amp;&amp; t.AutoExecute </span><span class="cov0" title="0">{
                                trigger, err := checkDeps(cn, t)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("", "Error checking dependency states: %s", err.Error())
                                        return err
                                }</span>
                                <span class="cov0" title="0">if trigger </span><span class="cov0" title="0">{
                                        toTrigger = append(toTrigger, t.Name)
                                }</span>
                        }
                }
        case constants.STATUS_TRIGGER_ALWAYS:<span class="cov0" title="0">
                for _, t := range ts </span><span class="cov0" title="0">{
                        if utils.Contains(t.DependsOn.Always, tn) &amp;&amp; t.AutoExecute </span><span class="cov0" title="0">{
                                trigger, err := checkDeps(cn, t)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("", "Error checking dependency states: %s", err.Error())
                                        return err
                                }</span>
                                <span class="cov0" title="0">if trigger </span><span class="cov0" title="0">{
                                        toTrigger = append(toTrigger, t.Name)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">for _, t := range toTrigger </span><span class="cov0" title="0">{
                if err := DoTrigger(cn, t, context, runID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func DoTrigger(wn, tn string, context map[string]string, runID string) error <span class="cov0" title="0">{
        if runID == "" </span><span class="cov0" title="0">{
                runID = uuid.New().String()
                h := history.History{
                        RunID:    runID,
                        States:   make([]state.State, 0),
                        Workflow: wn,
                }

                if err := history.CreateHistory(&amp;h); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">c, err := workflow.GetWorkflowByName(wn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">t, err := task.GetTaskByNames(wn, tn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if t.Disabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, s := range t.DependsOn.Success </span><span class="cov0" title="0">{
                ss, err := state.GetStateByNames(wn, s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if ss.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">for _, s := range t.DependsOn.Error </span><span class="cov0" title="0">{
                ss, err := state.GetStateByNames(wn, s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if ss.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        // for _, s := range t.DependsOn.Always {
        //         ss, err := state.GetStateByNames(cn, s)
        //         if err != nil {
        //                 return err
        //         }
        //         if ss.Status == constants.STATE_STATUS_NOT_STARTED {
        //                 return nil
        //         }
        // }

        <span class="cov0" title="0">s, err := state.GetStateByNames(wn, tn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.Status = constants.STATE_STATUS_WAITING
        if err := state.UpdateStateByNames(wn, tn, s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := history.AddStateToHistory(runID, *s); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error updating history: %s", err.Error())
                return err
        }</span>

        // if err := DoKill(cn, tn); err != nil {
        //         return err
        // }

        <span class="cov0" title="0">m := msg.TriggerMsg{
                Task:     tn,
                Workflow: wn,
                Action:   constants.ACTION_TRIGGER,
                Groups:   c.Groups,
                Number:   t.RunNumber + 1,
                RunID:    runID,
                Context:  context,
        }

        logger.Infof("", "Triggering run with message %v", m)
        return rabbitmq.ManagerPublish(m)</span>
        // return bulwark.QueuePush(bulwark.WorkerClient, m)
}

func DoKill(cn, tn string) error <span class="cov0" title="0">{
        // id := fmt.Sprintf("%s-%s", cn, tn)
        // toKill = append(toKill, id)
        // toKill = utils.RemoveDuplicateValues(toKill)
        // return bulwark.BufferSet(bulwark.BufferClient, toKill)
        logger.Tracef("", "Killing run %s.%s", cn, tn)
        // return stateChange(cn, tn, constants.STATE_STATUS_KILLED)
        // return state.UpdateStateKilledByNames(cn, tn, true)

        for _, node := range auth.Nodes </span><span class="cov0" title="0">{
                uri := fmt.Sprintf("%s://%s:%d", node.Protocol, node.Host, node.Port)
                httpClient := &amp;http.Client{}
                requestURL := fmt.Sprintf("%s/api/v1/run/%s/%s", uri, cn, tn)
                req, _ := http.NewRequest("DELETE", requestURL, nil)
                req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", config.Config.Node.PrimaryKey))
                req.Header.Set("Content-Type", "application/json")
                resp, err := httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Encountered error killing run: %v", err)
                        return err
                }</span>
                <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                        logger.Debugf("", "Got status code %d when trying to kill run", resp.StatusCode)
                        return fmt.Errorf("got status code %d when trying to kill run", resp.StatusCode)
                }</span>
                <span class="cov0" title="0">logger.Debugf("", "Run kill successfully triggered at %s", uri)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func InputChangeStateChange(name string, changed []string) error <span class="cov0" title="0">{
        c, err := workflow.GetWorkflowByName(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, t := range c.Tasks </span><span class="cov0" title="0">{
                for _, i := range changed </span><span class="cov0" title="0">{
                        if utils.Contains(utils.Keys(t.Inputs), i) </span><span class="cov0" title="0">{
                                stateChange(name, t.Name, constants.STATE_STATUS_NOT_STARTED, map[string]string{}, "")
                                // state.CopyStatesByNames(name, t.Name, fmt.Sprintf("SCAFFOLD_PREVIOUS-%s", t.Name))
                                state.ClearStateByNames(name, t.Name, t.RunNumber)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func GetStatus() (bool, []UINode) <span class="cov0" title="0">{
        conn, err := net.Dial("udp", "8.8.8.8:80")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        localAddress := conn.LocalAddr().(*net.UDPAddr)
        ip := localAddress.IP.String()

        nodes := make([]UINode, 0)
        managerStatus := "healthy"
        if !health.IsHealthy </span><span class="cov0" title="0">{
                managerStatus = "degraded"
        }</span>
        <span class="cov0" title="0">toRemove := []string{}
        downCount := 0
        n := UINode{
                Name:    config.Config.Host,
                IP:      ip,
                Status:  constants.NODE_HEALTHY,
                Version: constants.VERSION,
                Color:   constants.UI_HEALTH_COLORS[managerStatus],
                Text:    constants.UI_HEALTH_TEXT[managerStatus],
                Icon:    constants.UI_HEALTH_ICONS[managerStatus],
        }
        nodes = append(nodes, n)
        for id, node := range auth.Nodes </span><span class="cov0" title="0">{
                if node.Ping &lt; config.Config.PingHealthyThreshold </span><span class="cov0" title="0">{
                        status := constants.NODE_HEALTHY
                        n := UINode{
                                Name:    node.Name,
                                IP:      node.Host,
                                Status:  constants.NODE_HEALTHY,
                                Version: node.Version,
                                Color:   constants.UI_HEALTH_COLORS[status],
                                Text:    constants.UI_HEALTH_TEXT[status],
                                Icon:    constants.UI_HEALTH_ICONS[status],
                        }
                        nodes = append(nodes, n)
                        continue</span>
                }
                <span class="cov0" title="0">if node.Ping &lt; config.Config.PingUnknownThreshold </span><span class="cov0" title="0">{
                        status := constants.NODE_UNKNOWN
                        n := UINode{
                                Name:    node.Name,
                                IP:      node.Host,
                                Status:  constants.NODE_HEALTHY,
                                Version: node.Version,
                                Color:   constants.UI_HEALTH_COLORS[status],
                                Text:    constants.UI_HEALTH_TEXT[status],
                                Icon:    constants.UI_HEALTH_ICONS[status],
                        }
                        nodes = append(nodes, n)
                        downCount += 1
                        continue</span>
                }
                <span class="cov0" title="0">status := constants.NODE_UNHEALTHY
                n := UINode{
                        Name:    node.Name,
                        IP:      node.Host,
                        Status:  constants.NODE_HEALTHY,
                        Version: node.Version,
                        Color:   constants.UI_HEALTH_COLORS[status],
                        Text:    constants.UI_HEALTH_TEXT[status],
                        Icon:    constants.UI_HEALTH_ICONS[status],
                }
                nodes = append(nodes, n)
                if node.Ping &gt; config.Config.PingDownThreshold </span><span class="cov0" title="0">{
                        toRemove = append(toRemove, id)
                }</span>
                <span class="cov0" title="0">downCount += 1</span>
        }

        <span class="cov0" title="0">auth.NodeLock.Lock()
        for _, id := range toRemove </span><span class="cov0" title="0">{
                delete(auth.Nodes, id)
        }</span>
        <span class="cov0" title="0">auth.NodeLock.Unlock()

        return downCount == 0, nodes</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "net/http"
        "scaffold/server/config"
        "scaffold/server/user"
        "scaffold/server/utils"
        "scaffold/server/workflow"
        "strings"

        "github.com/gin-gonic/gin"
)

// This middleware ensures that a request will be aborted with an error
// if the user is not logged in
func EnsureLoggedIn() gin.HandlerFunc <span class="cov9" title="60">{
        return func(c *gin.Context) </span><span class="cov10" title="75">{
                var token string
                var err error

                baUsername, baPassword, hasAuth := c.Request.BasicAuth()
                if hasAuth </span><span class="cov0" title="0">{
                        _, err := user.GetUserByUsername(baUsername)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">verified, err := user.VerifyUser(baUsername, baPassword)
                        if err != nil || !verified </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov10" title="75">authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov2" title="2">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov2" title="2">{
                                c.Redirect(307, "/ui/login")
                                return
                        }</span>
                } else<span class="cov9" title="73"> {
                        token = strings.Split(authString, " ")[1]
                }</span>
                <span class="cov9" title="73">if token == config.Config.Node.PrimaryKey </span><span class="cov9" title="73">{
                        return
                }</span>

                <span class="cov0" title="0">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr == nil </span><span class="cov0" title="0">{
                        if authString == "" </span><span class="cov0" title="0">{
                                c.Redirect(307, "/ui/login")
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }
        }
}

func EnsureLoggedInAPI() gin.HandlerFunc <span class="cov1" title="1">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var token string
                var err error

                baUsername, baPassword, hasAuth := c.Request.BasicAuth()
                if hasAuth </span><span class="cov0" title="0">{
                        _, err := user.GetUserByUsername(baUsername)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">verified, err := user.VerifyUser(baUsername, baPassword)
                        if err != nil || !verified </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusForbidden)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        token = strings.Split(authString, " ")[1]
                }</span>
                <span class="cov0" title="0">if token == config.Config.Node.PrimaryKey </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr == nil </span><span class="cov0" title="0">{
                        if authString == "" </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusForbidden)
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }
        }
}

func EnsureNotLoggedIn() gin.HandlerFunc <span class="cov5" title="8">{
        return func(c *gin.Context) </span><span class="cov2" title="2">{
                var token string
                var err error

                authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov2" title="2">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov2" title="2">{
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        token = strings.Split(authString, " ")[1]
                }</span>

                <span class="cov0" title="0">if token == config.Config.Node.PrimaryKey </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusUnauthorized)
                }</span>

                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusUnauthorized)
                }</span>
        }
}

// This middleware ensures that a request will be aborted with an error
// if the user is not logged in
func EnsureWorkflowGroup(paramName string) gin.HandlerFunc <span class="cov8" title="30">{
        return func(c *gin.Context) </span><span class="cov5" title="9">{
                var token string
                var err error
                isUI := false
                workflowName := c.Param(paramName)
                cs, _ := workflow.GetWorkflowByName(workflowName)
                if err != nil </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusUnauthorized)
                }</span>
                <span class="cov5" title="9">if cs == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov5" title="9">authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov0" title="0">{
                                c.Redirect(http.StatusUnauthorized, "/ui/401")
                                return
                        }</span>
                        <span class="cov0" title="0">isUI = true</span>
                } else<span class="cov5" title="9"> {
                        token = strings.Split(authString, " ")[1]
                }</span>
                <span class="cov5" title="9">if token == config.Config.Node.PrimaryKey </span><span class="cov5" title="9">{
                        return
                }</span>

                <span class="cov0" title="0">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        if utils.Contains(usr.Groups, "admin") </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">if cs.Groups == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">for _, group := range cs.Groups </span><span class="cov0" title="0">{
                                if utils.Contains(usr.Groups, group) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">if isUI </span><span class="cov0" title="0">{
                                c.Redirect(http.StatusUnauthorized, "/ui/401")
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }

                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        if utils.Contains(usr.Groups, "admin") </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">for _, group := range cs.Groups </span><span class="cov0" title="0">{
                                if utils.Contains(usr.Groups, group) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">if isUI </span><span class="cov0" title="0">{
                                c.Redirect(http.StatusUnauthorized, "/ui/401")
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }
                <span class="cov0" title="0">if isUI </span><span class="cov0" title="0">{
                        c.Redirect(http.StatusUnauthorized, "/ui/401")
                        return
                }</span>
                <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
        }
}

func EnsureSelf() gin.HandlerFunc <span class="cov2" title="2">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                username := c.Param("username")

                var token string
                var err error

                baUsername, baPassword, hasAuth := c.Request.BasicAuth()
                if hasAuth </span><span class="cov0" title="0">{
                        if baUsername != username </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                        }</span>
                        <span class="cov0" title="0">_, err := user.GetUserByUsername(baUsername)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">verified, err := user.VerifyUser(baUsername, baPassword)
                        if err != nil || !verified </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        token, err = c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov0" title="0">{
                                c.Redirect(307, "/ui/login")
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        token = strings.Split(authString, " ")[1]
                }</span>
                <span class="cov0" title="0">if token == config.Config.Node.PrimaryKey </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">usr, _ := user.GetUserByAPIToken(token)
                if usr != nil </span><span class="cov0" title="0">{
                        if usr.Username == username || StringSliceContains(usr.Groups, "admin") || StringSliceContains(usr.Roles, "admin") </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                <span class="cov0" title="0">usr, _ = user.GetUserByLoginToken(token)
                if usr == nil </span><span class="cov0" title="0">{
                        if authString == "" </span><span class="cov0" title="0">{
                                c.Redirect(307, "/ui/login")
                                return
                        }</span>
                        <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
                }
                <span class="cov0" title="0">if usr.Username == username || StringSliceContains(usr.Groups, "admin") || StringSliceContains(usr.Roles, "admin") </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">if authString == "" </span><span class="cov0" title="0">{
                        c.Redirect(307, "/ui/login")
                        return
                }</span>
                <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
        }
}

func EnsureGroupsAllowed(groups []string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var usr *user.User
                authString := c.Request.Header.Get("Authorization")
                found := false
                if authString == "" </span><span class="cov0" title="0">{
                        token, err := c.Cookie("scaffold_token")
                        if err == nil </span><span class="cov0" title="0">{
                                usr, err = user.GetUserByLoginToken(token)
                                if err != nil </span><span class="cov0" title="0">{
                                        found = true
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        if !found </span><span class="cov0" title="0">{
                                token := strings.Split(authString, " ")[1]
                                if token == config.Config.Node.PrimaryKey </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">var err error
                                usr, err = user.GetUserByAPIToken(token)
                                if err != nil </span><span class="cov0" title="0">{
                                        c.AbortWithStatus(http.StatusUnauthorized)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if usr != nil </span><span class="cov0" title="0">{
                        for _, group := range usr.Groups </span><span class="cov0" title="0">{
                                if StringSliceContains(groups, group) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
        }
}

func EnsureRolesAllowed(roles []string) gin.HandlerFunc <span class="cov9" title="47">{
        return func(c *gin.Context) </span><span class="cov8" title="41">{
                var usr *user.User
                var err error

                authString := c.Request.Header.Get("Authorization")
                if authString == "" </span><span class="cov2" title="2">{
                        token, err := c.Cookie("scaffold_token")
                        if err != nil </span><span class="cov2" title="2">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                        <span class="cov0" title="0">usr, err = user.GetUserByLoginToken(token)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                } else<span class="cov8" title="39"> {
                        token := strings.Split(authString, " ")[1]
                        if token == config.Config.Node.PrimaryKey </span><span class="cov8" title="39">{
                                return
                        }</span>
                        <span class="cov0" title="0">usr, err = user.GetUserByAPIToken(token)
                        if err != nil </span><span class="cov0" title="0">{
                                c.AbortWithStatus(http.StatusUnauthorized)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if usr != nil </span><span class="cov0" title="0">{
                        for _, role := range usr.Roles </span><span class="cov0" title="0">{
                                if StringSliceContains(roles, role) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov0" title="0">c.AbortWithStatus(http.StatusUnauthorized)</span>
        }
}

func EnsureBasicAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span>{<span class="cov0" title="0">

        }</span>
}

func StringSliceContains(list []string, item string) bool <span class="cov0" title="0">{
        for _, v := range list </span><span class="cov0" title="0">{
                if v == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// middleware.cors.go

package middleware

import (
        "github.com/gin-gonic/gin"
)

func CORSMiddleware() gin.HandlerFunc <span class="cov4" title="7">{
        return func(c *gin.Context) </span><span class="cov10" title="80">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With, X-Scaffold-API")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE, UPGRADE, HEAD, CONNECT, PATCH, TRACE")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov9" title="79">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package mongodb

import (
        "context"
        "log"
        "scaffold/server/config"
        "scaffold/server/constants"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

var collectionNames = []string{
        constants.MONGODB_WORKFLOW_COLLECTION_NAME,
        constants.MONGODB_DATASTORE_COLLECTION_NAME,
        constants.MONGODB_STATE_COLLECTION_NAME,
        constants.MONGODB_USER_COLLECTION_NAME,
        constants.MONGODB_TASK_COLLECTION_NAME,
        constants.MONGODB_INPUT_COLLECTION_NAME,
        constants.MONGODB_WEBHOOK_COLLECTION_NAME,
        constants.MONGODB_HISTORY_COLLECTION_NAME,
}
var Collections map[string]*mongo.Collection
var Ctx = context.TODO()

func InitCollections() <span class="cov3" title="2">{
        clientOptions := options.Client().ApplyURI(config.Config.DBConnectionString)
        client, err := mongo.Connect(Ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov3" title="2">err = client.Ping(Ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov3" title="2">Collections = make(map[string]*mongo.Collection)

        for _, collection := range collectionNames </span><span class="cov10" title="16">{
                Collections[collection] = client.Database(config.Config.DB.Name).Collection(collection)
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package common

import (
        "bytes"
        _ "embed"
        "html/template"
        "net/http"
        "scaffold/server/constants"
        "scaffold/server/manager"
        "scaffold/server/user"

        "github.com/gin-gonic/gin"
        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

//go:embed status.html
var statusHTML string
var statusTemplate *template.Template

//go:embed sidebar.html
var sidebarHTML string
var sidebarTemplate *template.Template

//go:embed error.html
var errorHTML string
var errorTemplate *template.Template

//go:embed success.html
var successHTML string
var successTemplate *template.Template

//go:embed 401.html
var code401HTML string
var code401Template *template.Template

//go:embed 403.html
var code403HTML string
var code403Template *template.Template

//go:embed 404.html
var code404HTML string
var code404Template *template.Template

//go:embed 500.html
var code500HTML string
var code500Template *template.Template

//go:embed header.html
var headerHTML string
var headerTemplate *template.Template

func Init() error <span class="cov0" title="0">{
        var err error
        statusTemplate, err = template.New("common__status").Parse(statusHTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sidebarTemplate, err = template.New("common__sidebar").Parse(sidebarHTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">errorTemplate, err = template.New("common__error").Parse(errorHTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">successTemplate, err = template.New("common__success").Parse(successHTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">headerTemplate, err = template.New("common__header").Parse(headerHTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">code401Template, err = template.New("common__401").Parse(code401HTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">code403Template, err = template.New("common__403").Parse(code403HTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">code404Template, err = template.New("common__404").Parse(code404HTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">code500Template, err = template.New("common__500").Parse(code500HTML)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func StatusEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        isHealthy, nodes := manager.GetStatus()
        var markdown bytes.Buffer
        type Data struct {
                IsHealthy bool
                Nodes     []manager.UINode
        }
        statusTemplate.Execute(&amp;markdown, Data{IsHealthy: isHealthy, Nodes: nodes})
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())
}</span>

func SidebarEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        var markdown bytes.Buffer
        type Data struct {
                Version string
        }
        sidebarTemplate.Execute(&amp;markdown, Data{Version: constants.VERSION})
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())
}</span>

func ErrorEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        var markdown bytes.Buffer
        type Data struct{}
        errorTemplate.Execute(&amp;markdown, Data{})
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())
}</span>

func SuccessEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        var markdown bytes.Buffer
        type Data struct{}
        successTemplate.Execute(&amp;markdown, Data{})
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())
}</span>

func Code401Endpoint(ctx *gin.Context) <span class="cov0" title="0">{
        var markdown bytes.Buffer
        type Data struct{}
        code401Template.Execute(&amp;markdown, Data{})
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())
}</span>

func Code403Endpoint(ctx *gin.Context) <span class="cov0" title="0">{
        var markdown bytes.Buffer
        type Data struct{}
        code403Template.Execute(&amp;markdown, Data{})
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())
}</span>

func Code404Endpoint(ctx *gin.Context) <span class="cov0" title="0">{
        var markdown bytes.Buffer
        type Data struct{}
        code404Template.Execute(&amp;markdown, Data{})
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())
}</span>

func Code500Endpoint(ctx *gin.Context) <span class="cov0" title="0">{
        var markdown bytes.Buffer
        type Data struct{}
        code500Template.Execute(&amp;markdown, Data{})
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())
}</span>

func HeaderEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        link, ok := ctx.GetQuery("link")
        if !ok </span><span class="cov0" title="0">{
                ctx.Redirect(http.StatusTemporaryRedirect, "/ui/404")
        }</span>
        <span class="cov0" title="0">caser := cases.Title(language.English)
        title := caser.String(link)

        var markdown bytes.Buffer
        type Data struct {
                Title      string
                Link       string
                GivenName  string
                FamilyName string
        }
        token, _ := ctx.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        familyName := ""
        givenName := ""
        if u != nil </span><span class="cov0" title="0">{
                familyName = u.FamilyName
                givenName = u.GivenName
        }</span>
        <span class="cov0" title="0">headerTemplate.Execute(&amp;markdown, Data{
                Title:      title,
                Link:       link,
                FamilyName: familyName,
                GivenName:  givenName,
        })
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown.Bytes())</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package page

import (
        "fmt"
        "net/http"
        "scaffold/server/constants"
        "scaffold/server/state"
        "scaffold/server/user"
        "scaffold/server/workflow"
        "sort"
        "strings"

        "github.com/jfcarter2358/ui"
        "github.com/jfcarter2358/ui/breadcrumb"
        "github.com/jfcarter2358/ui/elements/br"
        "github.com/jfcarter2358/ui/elements/div"
        "github.com/jfcarter2358/ui/elements/link"
        "github.com/jfcarter2358/ui/page"
        "github.com/jfcarter2358/ui/sidebar"
        "github.com/jfcarter2358/ui/table"
        "github.com/jfcarter2358/ui/table/cell"
        "github.com/jfcarter2358/ui/table/header"
        "github.com/jfcarter2358/ui/topbar"

        _ "embed"

        "github.com/gin-gonic/gin"
        logger "github.com/jfcarter2358/go-logger"
)

func DashboardSearchEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        searchTerm, ok := ctx.GetQuery("search")
        if !ok </span><span class="cov0" title="0">{
                ctx.Status(http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">query := strings.TrimSpace(searchTerm)

        workflows := workflow.GetCacheAll()

        filtered := []workflow.Workflow{}

        for name, w := range workflows </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(name), strings.ToLower(query)) </span><span class="cov0" title="0">{
                        filtered = append(filtered, w)
                }</span>
        }

        <span class="cov0" title="0">markdown := dashboardBuildTable(filtered, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func DashboardTableEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflows := workflow.GetCacheAll()
        filtered := []workflow.Workflow{}

        for _, w := range workflows </span><span class="cov0" title="0">{
                filtered = append(filtered, w)
        }</span>

        <span class="cov0" title="0">markdown := dashboardBuildTable(filtered, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func DashboardPageEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        markdown := dashboardBuildPage(ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func dashboardBuildPage(ctx *gin.Context) []byte <span class="cov0" title="0">{
        p := page.Page{
                ID:             "page",
                SidebarEnabled: true,
                Sidebar: sidebar.Sidebar{
                        ID:      "sidebar",
                        Classes: "theme-light",
                        Components: []ui.Component{
                                link.Link{
                                        Title: "Dashboard",
                                        HRef:  "/ui/dashboard",
                                },
                                link.Link{
                                        Title: "Runs",
                                        HRef:  "/ui/runs",
                                },
                                link.Link{
                                        Title: "Users",
                                        HRef:  "/ui/users",
                                },
                                link.Link{
                                        Title: "Workflows",
                                        HRef:  "/ui/workflows",
                                },
                        },
                },
                Components: []ui.Component{
                        topbar.Topbar{
                                Title:   "Scaffold",
                                Classes: "ui-green",
                                Buttons: []ui.Component{
                                        link.Link{
                                                Title:   "Logout",
                                                HRef:    "/auth/logout",
                                                Style:   "passing:12px;",
                                                Classes: "theme-dark rounded-md",
                                        },
                                },
                                MenuClasses: "theme-light",
                        },
                        div.Div{
                                Classes: "theme-light rounded-md",
                                Components: []ui.Component{
                                        div.Div{
                                                Classes: "ui-green rounded-md",
                                                Components: []ui.Component{
                                                        breadcrumb.Breadcrumb{
                                                                Components: []ui.Component{
                                                                        link.Link{
                                                                                Title: "Dashboard",
                                                                                HRef:  "/ui/dashboard",
                                                                        },
                                                                },
                                                                Style: "margin-left:16px;",
                                                        },
                                                },
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;input id="search" class="w3-input w3-round search-bar theme-light" type="text"
                            name="search" placeholder="Search Workflows"
                            style="margin-top:8px;margin-bottom:8px;margin-left:1%;width:98%" hx-get="/htmx/dashboard/search"
                            hx-trigger="keyup changed delay:250ms" hx-target="#dashboard-table-div" /&gt;`,
                                        },
                                        div.Div{
                                                ID:        "dashboard-table-div",
                                                HXTrigger: "load",
                                                HXGet:     "/htmx/dashboard/table",
                                        },
                                },
                                Style: "margin:64px;",
                        },
                        br.BR{},
                },
        }
        html, err := p.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render dashboard page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func dashboardBuildTable(ws []workflow.Workflow, ctx *gin.Context) []byte <span class="cov0" title="0">{
        sort.Slice(ws, func(i, j int) bool </span><span class="cov0" title="0">{
                return ws[i].Created &lt; ws[j].Created
        }</span>)

        <span class="cov0" title="0">t := table.Table{
                ID: "dashboard_table",
                Headers: []header.Header{
                        {
                                Contents: "Name",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Task States",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "",
                                Classes:  "text-lg",
                        },
                },
                Rows:          make([][]cell.Cell, 0),
                Classes:       "theme-light",
                Style:         "width:100%;",
                HeaderClasses: "rounded-md ui-green",
        }

        token, _ := ctx.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        for _, w := range ws </span><span class="cov0" title="0">{
                isInGroup := false
                for _, ug := range u.Groups </span><span class="cov0" title="0">{
                        if ug == "admin" </span><span class="cov0" title="0">{
                                isInGroup = true
                                break</span>
                        }
                        <span class="cov0" title="0">for _, wg := range w.Groups </span><span class="cov0" title="0">{
                                if ug == wg </span><span class="cov0" title="0">{
                                        isInGroup = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isInGroup </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">ss, err := state.GetAllStates()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Cannot render dashboard table: %s", err.Error())
                        ctx.AbortWithStatus(http.StatusInternalServerError)
                        return []byte{}
                }</span>
                <span class="cov0" title="0">runningCount := 0
                waitingCount := 0
                successCount := 0
                errorCount := 0
                notStartedCount := 0
                killedCount := 0
                // TODO: Figure out something better so this isn't running in O(n^2) time
                for _, s := range ss </span><span class="cov0" title="0">{
                        if s.Workflow == w.Name </span><span class="cov0" title="0">{
                                switch s.Status </span>{
                                case constants.STATE_STATUS_ERROR:<span class="cov0" title="0">
                                        errorCount += 1</span>
                                case constants.STATE_STATUS_KILLED:<span class="cov0" title="0">
                                        killedCount += 1</span>
                                case constants.STATE_STATUS_NOT_STARTED:<span class="cov0" title="0">
                                        notStartedCount += 1</span>
                                case constants.STATE_STATUS_RUNNING:<span class="cov0" title="0">
                                        runningCount += 1</span>
                                case constants.STATE_STATUS_SUCCESS:<span class="cov0" title="0">
                                        successCount += 1</span>
                                case constants.STATE_STATUS_WAITING:<span class="cov0" title="0">
                                        waitingCount += 1</span>
                                }
                        }
                }
                <span class="cov0" title="0">total := runningCount + waitingCount + successCount + errorCount + notStartedCount + killedCount
                percentRunning := int(float64(runningCount) / float64(total) * 80.0)
                percentWaiting := int(float64(waitingCount) / float64(total) * 80.0)
                percentSuccess := int(float64(successCount) / float64(total) * 80.0)
                percentError := int(float64(errorCount) / float64(total) * 80.0)
                percentNotStarted := int(float64(notStartedCount) / float64(total) * 80.0)
                percentKilled := int(float64(killedCount) / float64(total) * 80.0)
                r := []cell.Cell{
                        {
                                Contents: w.Name,
                        },
                        {
                                Contents: fmt.Sprintf(`
                                &lt;div class="ui-charcoal" style="width:%d%%;height:20px;display:inline-block;margin-top:8px;margin-left:-4px;"&gt;&lt;/div&gt;
                                &lt;div class="ui-yellow" style="width:%d%%;height:20px;display:inline-block;margin-top:8px;margin-left:-4px;"&gt;&lt;/div&gt;
                                &lt;div class="ui-blue" style="width:%d%%;height:20px;display:inline-block;margin-top:8px;margin-left:-4px;"&gt;&lt;/div&gt;
                                &lt;div class="ui-green" style="width:%d%%;height:20px;display:inline-block;margin-top:8px;margin-left:-4px;"&gt;&lt;/div&gt;
                                &lt;div class="ui-red" style="width:%d%%;height:20px;display:inline-block;margin-top:8px;margin-left:-4px;"&gt;&lt;/div&gt;
                                &lt;div class="ui-orange" style="width:%d%%;height:20px;display:inline-block;margin-top:8px;margin-left:-4px;"&gt;&lt;/div&gt;
                                `, percentNotStarted, percentWaiting, percentRunning, percentSuccess, percentError, percentKilled),
                        },
                        {
                                Contents: `&lt;a href="/ui/workflows/` + w.Name + `" class="table-link-link w3-right-align dark theme-text"
                    style="float:right;margin-right:16px;"&gt;
                    &lt;i class="fa-solid fa-link"&gt;&lt;/i&gt;
                &lt;/a&gt;`,
                        },
                }
                t.Rows = append(t.Rows, r)</span>
        }

        <span class="cov0" title="0">html, err := t.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render dashboard table: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package page

import (
        "net/http"
        "scaffold/server/history"
        "scaffold/server/user"
        "scaffold/server/workflow"
        "sort"
        "strings"

        "github.com/jfcarter2358/ui"
        "github.com/jfcarter2358/ui/breadcrumb"
        "github.com/jfcarter2358/ui/elements/br"
        "github.com/jfcarter2358/ui/elements/div"
        "github.com/jfcarter2358/ui/elements/link"
        "github.com/jfcarter2358/ui/page"
        "github.com/jfcarter2358/ui/sidebar"
        "github.com/jfcarter2358/ui/table"
        "github.com/jfcarter2358/ui/table/cell"
        "github.com/jfcarter2358/ui/table/header"
        "github.com/jfcarter2358/ui/topbar"

        _ "embed"

        "github.com/gin-gonic/gin"
        logger "github.com/jfcarter2358/go-logger"
)

func HistoriesSearchEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        searchTerm, ok := ctx.GetQuery("search")
        if !ok </span><span class="cov0" title="0">{
                ctx.Status(http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">query := strings.TrimSpace(searchTerm)

        histories, err := history.GetAllHistories()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render histories page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">filtered := []history.History{}

        for _, h := range histories </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(h.RunID), strings.ToLower(query)) || strings.Contains(strings.ToLower(h.Workflow), strings.ToLower(query)) </span><span class="cov0" title="0">{
                        filtered = append(filtered, *h)
                }</span>
        }

        <span class="cov0" title="0">markdown := historiesBuildTable(filtered, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func HistoriesTableEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        histories, err := history.GetAllHistories()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render histories page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">filtered := []history.History{}

        for _, h := range histories </span><span class="cov0" title="0">{
                filtered = append(filtered, *h)
        }</span>

        <span class="cov0" title="0">markdown := historiesBuildTable(filtered, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func HistoriesPageEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        markdown := historiesBuildPage(ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func historiesBuildPage(ctx *gin.Context) []byte <span class="cov0" title="0">{
        p := page.Page{
                ID:             "page",
                SidebarEnabled: true,
                Sidebar: sidebar.Sidebar{
                        ID:      "sidebar",
                        Classes: "theme-light",
                        Components: []ui.Component{
                                link.Link{
                                        Title: "Dashboard",
                                        HRef:  "/ui/dashboard",
                                },
                                link.Link{
                                        Title: "Runs",
                                        HRef:  "/ui/runs",
                                },
                                link.Link{
                                        Title: "Users",
                                        HRef:  "/ui/users",
                                },
                                link.Link{
                                        Title: "Workflows",
                                        HRef:  "/ui/workflows",
                                },
                        },
                },
                Components: []ui.Component{
                        topbar.Topbar{
                                Title:   "Scaffold",
                                Classes: "ui-green",
                                Buttons: []ui.Component{
                                        link.Link{
                                                Title:   "Logout",
                                                HRef:    "/auth/logout",
                                                Style:   "passing:12px;",
                                                Classes: "theme-dark rounded-md",
                                        },
                                },
                                MenuClasses: "theme-light",
                        },
                        div.Div{
                                Classes: "theme-light rounded-md",
                                Components: []ui.Component{
                                        div.Div{
                                                Classes: "ui-green rounded-md",
                                                Components: []ui.Component{
                                                        breadcrumb.Breadcrumb{
                                                                Components: []ui.Component{
                                                                        link.Link{
                                                                                Title: "Runs",
                                                                                HRef:  "/ui/runs",
                                                                        },
                                                                },
                                                                Style: "margin-left:16px;",
                                                        },
                                                },
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;input id="search" class="w3-input w3-round search-bar theme-light" type="text"
                            name="search" placeholder="Search Runs"
                            style="margin-top:8px;margin-bottom:8px;margin-left:1%;width:98%" hx-get="/htmx/runs/search"
                            hx-trigger="keyup changed delay:250ms" hx-target="#histories-table-div" /&gt;`,
                                        },
                                        div.Div{
                                                ID:        "histories-table-div",
                                                HXTrigger: "load",
                                                HXGet:     "/htmx/runs/table",
                                        },
                                },
                                Style: "margin:64px;",
                        },
                        br.BR{},
                },
        }
        html, err := p.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render runs page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func historiesBuildTable(hs []history.History, ctx *gin.Context) []byte <span class="cov0" title="0">{
        sort.Slice(hs, func(i, j int) bool </span><span class="cov0" title="0">{
                return hs[i].RunID &lt; hs[j].RunID
        }</span>)

        <span class="cov0" title="0">t := table.Table{
                ID: "histories_table",
                Headers: []header.Header{
                        {
                                Contents: "Name",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Workflow",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Created",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Updated",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Last Task",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Last Status",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "",
                                Classes:  "text-lg",
                        },
                },
                Rows:          make([][]cell.Cell, 0),
                Classes:       "theme-light",
                Style:         "width:100%;",
                HeaderClasses: "rounded-md ui-green",
        }

        token, _ := ctx.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)
        ws := workflow.GetCacheAll()
        groups := []string{}
        for _, w := range ws </span><span class="cov0" title="0">{
                if w.Name == hs[0].Workflow </span><span class="cov0" title="0">{
                        groups = w.Groups
                }</span>
        }

        <span class="cov0" title="0">for _, h := range hs </span><span class="cov0" title="0">{
                isInGroup := false
                for _, ug := range u.Groups </span><span class="cov0" title="0">{
                        if ug == "admin" </span><span class="cov0" title="0">{
                                isInGroup = true
                                break</span>
                        }
                        <span class="cov0" title="0">for _, wg := range groups </span><span class="cov0" title="0">{
                                if ug == wg </span><span class="cov0" title="0">{
                                        isInGroup = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isInGroup </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">for _, ur := range u.Roles </span><span class="cov0" title="0">{
                        if ur == "admin" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if ur == "write" </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">logger.Errorf("", "Current history check: %s", h.RunID)
                logger.Errorf("", "Current history states: %v", h.States)
                if len(h.States) &gt; 0 </span><span class="cov0" title="0">{
                        lastTask := h.States[len(h.States)-1].Task
                        lastStatus := h.States[len(h.States)-1].Status
                        r := []cell.Cell{
                                {
                                        Contents: h.RunID,
                                },
                                {
                                        Contents: h.Workflow,
                                },
                                {
                                        Contents: h.Created,
                                },
                                {
                                        Contents: h.Updated,
                                },
                                {
                                        Contents: lastTask,
                                },
                                {
                                        Contents: lastStatus,
                                },
                                {
                                        Contents: `&lt;a href="/ui/runs/` + h.RunID + `" class="table-link-link w3-right-align dark theme-text"
                    style="float:right;margin-right:16px;"&gt;
                    &lt;i class="fa-solid fa-link"&gt;&lt;/i&gt;
                &lt;/a&gt;`,
                                },
                        }
                        t.Rows = append(t.Rows, r)
                }</span>
        }

        <span class="cov0" title="0">html, err := t.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render runs table: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package page

import (
        "fmt"
        "net/http"
        "scaffold/server/constants"
        "scaffold/server/history"

        "github.com/jfcarter2358/ui"
        "github.com/jfcarter2358/ui/breadcrumb"
        "github.com/jfcarter2358/ui/elements/br"
        "github.com/jfcarter2358/ui/elements/div"
        "github.com/jfcarter2358/ui/elements/link"
        "github.com/jfcarter2358/ui/elements/pre"
        "github.com/jfcarter2358/ui/page"
        "github.com/jfcarter2358/ui/sidebar"
        "github.com/jfcarter2358/ui/timeline"
        "github.com/jfcarter2358/ui/timeline/item"
        "github.com/jfcarter2358/ui/topbar"

        _ "embed"

        "github.com/gin-gonic/gin"
        logger "github.com/jfcarter2358/go-logger"
        "gopkg.in/yaml.v3"
)

func HistoryStateEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        markdown := historyBuildState(ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func HistoryTimelineEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        runID := ctx.Param("run_id")
        h, err := history.GetHistoryByRunID(runID)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render run timeline page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">markdown := historyBuildTimeline(*h, runID, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func HistoryPageEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        markdown := historyBuildPage(ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func historyBuildState(ctx *gin.Context) []byte <span class="cov0" title="0">{
        runID := ctx.Param("run_id")
        stateName := ctx.Param("state_name")

        h, err := history.GetHistoryByRunID(runID)
        if err != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Cannot render run state page: %s", err.Error())
                        ctx.AbortWithStatus(http.StatusInternalServerError)
                        return []byte{}
                }</span>
        }

        <span class="cov0" title="0">for _, s := range h.States </span><span class="cov0" title="0">{
                if s.Task == stateName </span><span class="cov0" title="0">{
                        bytes, err := yaml.Marshal(s)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Cannot marshal state to yaml: %s", err.Error())
                                ctx.AbortWithStatus(http.StatusInternalServerError)
                                return []byte{}
                        }</span>
                        <span class="cov0" title="0">return bytes</span>
                }
        }

        <span class="cov0" title="0">logger.Errorf("", "No state exists with name %s in run %s: %s", stateName, runID, err.Error())
        ctx.AbortWithStatus(http.StatusInternalServerError)
        return []byte{}</span>
}

func historyBuildPage(ctx *gin.Context) []byte <span class="cov0" title="0">{
        runID := ctx.Param("run_id")
        p := page.Page{
                ID:             "page",
                SidebarEnabled: true,
                Sidebar: sidebar.Sidebar{
                        ID:      "sidebar",
                        Classes: "theme-light",
                        Components: []ui.Component{
                                link.Link{
                                        Title: "Dashboard",
                                        HRef:  "/ui/dashboard",
                                },
                                link.Link{
                                        Title: "Runs",
                                        HRef:  "/ui/runs",
                                },
                                link.Link{
                                        Title: "Users",
                                        HRef:  "/ui/users",
                                },
                                link.Link{
                                        Title: "Workflows",
                                        HRef:  "/ui/workflows",
                                },
                        },
                },
                Components: []ui.Component{
                        topbar.Topbar{
                                Title:   "Scaffold",
                                Classes: "ui-green",
                                Buttons: []ui.Component{
                                        link.Link{
                                                Title:   "Logout",
                                                HRef:    "/auth/logout",
                                                Style:   "passing:12px;",
                                                Classes: "theme-dark rounded-md",
                                        },
                                },
                                MenuClasses: "theme-light",
                        },
                        div.Div{
                                Classes: "theme-light rounded-md",
                                Components: []ui.Component{
                                        div.Div{
                                                Classes: "ui-green rounded-md",
                                                Components: []ui.Component{
                                                        breadcrumb.Breadcrumb{
                                                                Components: []ui.Component{
                                                                        link.Link{
                                                                                Title: "Runs",
                                                                                HRef:  "/ui/runs",
                                                                        },
                                                                        link.Link{
                                                                                Title: runID,
                                                                                HRef:  fmt.Sprintf("/ui/runs/%s", runID),
                                                                        },
                                                                },
                                                                Style: "margin-left:16px;",
                                                        },
                                                },
                                        },
                                        div.Div{
                                                ID:        "history-state-div",
                                                HXTrigger: "load, every 2s",
                                                HXGet:     fmt.Sprintf("/htmx/runs/timeline/%s", runID),
                                                Style:     "padding-left:64px;",
                                        },
                                        ui.Raw{
                                                HTMLString: "&lt;hr&gt;",
                                        },
                                        pre.Pre{
                                                ID:    "history-state-pre",
                                                Style: "margin-bottom:64px;padding:32px;",
                                        },
                                },
                                Style: "margin:64px;",
                        },
                        br.BR{},
                },
        }
        html, err := p.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render run page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func historyBuildTimeline(h history.History, runID string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        t := timeline.Timeline{
                ID:    "history_timeline",
                Items: make([]item.Item, 0),
                Style: "margin-bottom:64px;",
        }

        for idx, s := range h.States </span><span class="cov0" title="0">{
                t.Items = append(t.Items, item.Item{
                        ID:          fmt.Sprintf("item-%s-%s", s.Workflow, s.Task),
                        IsFirst:     idx == 0,
                        IsLast:      idx == len(h.States)-1,
                        BoxContents: s.Task,
                        IconClasses: func(status string) string </span><span class="cov0" title="0">{
                                switch status </span>{
                                case constants.STATE_STATUS_RUNNING:<span class="cov0" title="0">
                                        return "fa-solid fa-spinner fa-pause ui-text-blue"</span>
                                case constants.STATE_STATUS_ERROR:<span class="cov0" title="0">
                                        return "fa-solid fa-circle-xmark ui-text-red"</span>
                                case constants.STATE_STATUS_KILLED:<span class="cov0" title="0">
                                        return "fa-solid fa-skull ui-text-orange"</span>
                                case constants.STATE_STATUS_NOT_STARTED:<span class="cov0" title="0">
                                        return "fa-regular fa-circle ui-text-charcoal"</span>
                                case constants.STATE_STATUS_WAITING:<span class="cov0" title="0">
                                        return "fa-solid fa-clock ui-text-yellow"</span>
                                case constants.STATE_STATUS_SUCCESS:<span class="cov0" title="0">
                                        return "fa-solid fa-circle-check ui-text-green"</span>
                                }
                                <span class="cov0" title="0">return "fa-solid fa-circle-question ui-text-charcoal"</span>
                        }(s.Status),
                        LineColor: func(status string) string <span class="cov0" title="0">{
                                switch status </span>{
                                case constants.STATE_STATUS_RUNNING:<span class="cov0" title="0">
                                        return "ui-blue"</span>
                                case constants.STATE_STATUS_ERROR:<span class="cov0" title="0">
                                        return "ui-red"</span>
                                case constants.STATE_STATUS_KILLED:<span class="cov0" title="0">
                                        return "ui-orange"</span>
                                case constants.STATE_STATUS_NOT_STARTED:<span class="cov0" title="0">
                                        return "ui-charcoal"</span>
                                case constants.STATE_STATUS_WAITING:<span class="cov0" title="0">
                                        return "ui-yellow"</span>
                                case constants.STATE_STATUS_SUCCESS:<span class="cov0" title="0">
                                        return "ui-green"</span>
                                }
                                <span class="cov0" title="0">return "ui-charcoal"</span>
                        }(s.Status),
                        HXTrigger: "click",
                        HXGet:     fmt.Sprintf("/htmx/runs/timeline/%s/status/%s", runID, s.Task),
                        HXTarget:  "#history-state-pre",
                })
        }

        <span class="cov0" title="0">html, err := t.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render run timeline: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package page

import (
        "net/http"
        "scaffold/server/constants"

        "github.com/jfcarter2358/ui"
        "github.com/jfcarter2358/ui/elements/br"
        "github.com/jfcarter2358/ui/page"

        "github.com/gin-gonic/gin"
        logger "github.com/jfcarter2358/go-logger"
)

func LoginPageEndpoint(ctx *gin.Context) <span class="cov10" title="2">{
        markdown := loginBuildPage("", ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func loginBuildPage(errorMessage string, ctx *gin.Context) []byte <span class="cov10" title="2">{
        p := page.Page{
                ID: "page",
                Components: []ui.Component{
                        br.BR{},
                        br.BR{},
                        br.BR{},
                        br.BR{},
                        ui.Raw{
                                HTMLString: `
&lt;div class="modal-content dark theme-light animate w3-border w3-border-black w3-card w3-round" style="width:40%;margin-left:30%;margin-right:30%;"&gt;
&lt;div class="w3-container ui-green w3-round"&gt;
        &lt;div class="w3-center"&gt;
                &lt;h1 class="header-text"&gt;&lt;b&gt;Scaffold&lt;/b&gt;&lt;/h1&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;br&gt;
&lt;form class="w3-container" action="/auth/login" id="login_form" method="POST"&gt;
        &lt;div class="form-group"&gt;
                &lt;label for="username" class="label-text ui-text-green"&gt;Username&lt;/label&gt;
                &lt;input type="text" class="form-control w3-round w3-input dark theme-light" id="username" name="username" placeholder="Username"&gt;
        &lt;/div&gt;
        &lt;div class="form-group"&gt;
                &lt;label for="password" class="label-text ui-text-green"&gt;Password&lt;/label&gt;
                &lt;input type="password" class="form-control w3-round w3-input dark theme-light" id="password" name="password"
                        placeholder="Password"&gt;
        &lt;/div&gt;
        &lt;br&gt;
        &lt;p class="ui-text-red"&gt;` +
                                        errorMessage +
                                        `&lt;/p&gt;
        &lt;br&gt;
        &lt;label class="container ui-text-green"&gt;Remember Me
                &lt;input type="checkbox" id="remember_me" name="remember_me" &gt;
                &lt;span class="checkmark"&gt;&lt;/span&gt;
        &lt;/label&gt;
        &lt;br&gt;
        &lt;div&gt;
                &lt;button type="submit" class="w3-button ui-green w3-round diagonal-shadow-grey"&gt;&lt;b&gt;Login&lt;/b&gt;&lt;/button&gt;
                &lt;a href="/ui/forgot_password" style="padding-left:8px;"&gt;
                        &lt;div class="w3-button dark theme-light ui-text-green w3-round ui-border-grey w3-border"&gt;&lt;b&gt;Forgot Password&lt;/b&gt;&lt;/div&gt;
                &lt;/a&gt;
        &lt;/div&gt;
&lt;/form&gt;
&lt;br&gt;
&lt;div class="w3-container ui-green w3-round"&gt;
        &lt;p style="float: right;" class="footer-text w3-text-white"&gt;&lt;b&gt;v` + constants.VERSION + `&lt;/b&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;`,
                        },
                },
        }
        html, err := p.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render login page : %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov10" title="2">return []byte(html)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package page

import (
        "encoding/json"
        "fmt"
        "net/http"
        "scaffold/server/auth"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/datastore"
        "scaffold/server/filestore"
        "scaffold/server/user"
        "scaffold/server/utils"
        "scaffold/server/workflow"
        "time"

        logger "github.com/jfcarter2358/go-logger"

        "github.com/gin-gonic/gin"
)

func RedirectIndexPage(c *gin.Context) <span class="cov0" title="0">{
        c.Redirect(301, "/ui/dashboard")
}</span>

func ShowForgotPasswordPage(c *gin.Context) <span class="cov0" title="0">{
        showPage(c, "forgot_password.html", gin.H{"version": constants.VERSION})
}</span>

func ShowEmailSuccessPage(c *gin.Context) <span class="cov0" title="0">{
        showPage(c, "email_success.html", gin.H{"version": constants.VERSION})
}</span>

func ShowEmailFailurePage(c *gin.Context) <span class="cov0" title="0">{
        showPage(c, "email_failure.html", gin.H{"version": constants.VERSION})
}</span>

func ShowResetPasswordPage(c *gin.Context) <span class="cov0" title="0">{
        resetToken := c.Param("reset_token")
        u, _ := user.GetUserByResetToken(resetToken)

        if u == nil </span><span class="cov0" title="0">{
                showPage(c, "reset_password.html", gin.H{"title": "Reset Password", "Email": "N/A", "InvalidToken": "Your password reset link is invalid or expired"})
        }</span> else<span class="cov0" title="0"> {
                t, err := time.Parse("2006-01-02 15:04:05", u.ResetTokenCreated)
                if err != nil </span><span class="cov0" title="0">{
                        showPage(c, "reset_password.html", gin.H{"title": "Reset Password", "Email": "N/A", "InvalidToken": "Your password reset link is invalid or expired"})
                }</span> else<span class="cov0" title="0"> {
                        currentTime := time.Now()
                        difference := currentTime.Sub(t).Hours()
                        if difference &gt; 24 </span><span class="cov0" title="0">{
                                showPage(c, "reset_password.html", gin.H{"title": "Reset Password", "Email": "N/A", "InvalidToken": "Your password reset link is invalid or expired"})
                        }</span> else<span class="cov0" title="0"> {
                                showPage(c, "reset_password.html", gin.H{"title": "Reset Password", "Email": u.Email})
                        }</span>
                }
        }
}

func ShowFilesPage(c *gin.Context) <span class="cov0" title="0">{
        token, _ := c.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        if u == nil </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, "/ui/401")
                return
        }</span>

        <span class="cov0" title="0">objects := []filestore.ObjectMetadata{}
        fileMetadata, err := filestore.ListObjects()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Unable to get filestore objects: %s", err.Error())
                utils.DynamicAPIResponse(c, "/ui/500", http.StatusInternalServerError, gin.H{})
        }</span>

        <span class="cov0" title="0">workflowList := []string{}
        inGroups := map[string]bool{}

        datastores, _ := datastore.GetAllDataStores()
        workflows, _ := workflow.GetAllWorkflows()
        for idx, d := range datastores </span><span class="cov0" title="0">{
                workflowList = append(workflowList, d.Name)

                for _, f := range d.Files </span><span class="cov0" title="0">{
                        path := fmt.Sprintf("%s/%s", d.Name, f)
                        fm := filestore.ObjectMetadata{
                                Name:     f,
                                Workflow: d.Name,
                                Modified: fileMetadata[path].Modified,
                        }
                        objects = append(objects, fm)
                }</span>
                <span class="cov0" title="0">isInGroup := false
                for _, ug := range u.Groups </span><span class="cov0" title="0">{
                        if ug == "admin" </span><span class="cov0" title="0">{
                                isInGroup = true
                                break</span>
                        }
                        <span class="cov0" title="0">for _, cg := range workflows[idx].Groups </span><span class="cov0" title="0">{
                                if ug == cg </span><span class="cov0" title="0">{
                                        isInGroup = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isInGroup </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">inGroups[d.Name] = isInGroup</span>
        }

        <span class="cov0" title="0">showPage(c, "files.html", gin.H{"objects": objects, "workflows": workflowList, "in_groups": inGroups})</span>
}

func ShowUsersPage(c *gin.Context) <span class="cov0" title="0">{
        token, _ := c.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        if u == nil </span><span class="cov0" title="0">{
                c.Redirect(http.StatusTemporaryRedirect, "/ui/401")
                return
        }</span>

        <span class="cov0" title="0">isAdmin := false
        if utils.Contains(u.Groups, "admin") || utils.Contains(u.Roles, "admin") </span><span class="cov0" title="0">{
                isAdmin = true
        }</span>

        <span class="cov0" title="0">groups, _ := auth.GetAllGroups()
        roles := auth.GetAllRoles()

        var users []user.User
        if isAdmin </span><span class="cov0" title="0">{
                userPointers, _ := user.GetAllUsers()
                users = make([]user.User, len(userPointers))
                for idx, obj := range userPointers </span><span class="cov0" title="0">{
                        users[idx] = *obj
                }</span>
        } else<span class="cov0" title="0"> {
                users = []user.User{*u}
        }</span>

        <span class="cov0" title="0">showPage(c, "users.html", gin.H{"users": users, "is_admin": isAdmin, "admin_username": config.Config.Admin.Username, "groups": groups, "roles": roles})</span>
}

func ShowUserPage(c *gin.Context) <span class="cov0" title="0">{
        username := c.Param("username")
        u, _ := user.GetUserByUsername(username)
        if u == nil </span><span class="cov0" title="0">{
                c.HTML(http.StatusNotFound, "/ui/404", gin.H{})
        }</span>

        <span class="cov0" title="0">groupObj := make([]map[string]string, len(u.Groups))
        for idx, val := range u.Groups </span><span class="cov0" title="0">{
                groupObj[idx] = map[string]string{
                        "value": val,
                }
        }</span>
        <span class="cov0" title="0">groupJSON, _ := json.Marshal(groupObj)

        roleObj := make([]map[string]string, len(u.Roles))
        for idx, val := range u.Roles </span><span class="cov0" title="0">{
                roleObj[idx] = map[string]string{
                        "value": val,
                }
        }</span>
        <span class="cov0" title="0">roleJSON, _ := json.Marshal(roleObj)

        logger.Debugf("", "group json: %s", string(groupJSON))
        logger.Debugf("", "role json: %s", string(roleJSON))

        showPage(c, "user.html", gin.H{"user": &amp;u, "role_tag_json": string(roleJSON), "group_tag_json": string(groupJSON)})</span>
}

func showPage(c *gin.Context, page string, header gin.H) <span class="cov0" title="0">{
        token, _ := c.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        familyName := ""
        givenName := ""
        if u != nil </span><span class="cov0" title="0">{
                familyName = u.FamilyName
                givenName = u.GivenName
        }</span>

        <span class="cov0" title="0">header["family_name"] = familyName
        header["given_name"] = givenName
        header["version"] = constants.VERSION

        render(c, header, page)</span>
}

func render(c *gin.Context, data gin.H, templateName string) <span class="cov0" title="0">{
        switch c.Request.Header.Get("Accept") </span>{
        case "application/json":<span class="cov0" title="0">
                c.JSON(http.StatusOK, data["payload"])</span>
        case "application/xml":<span class="cov0" title="0">
                c.XML(http.StatusOK, data["payload"])</span>
        default:<span class="cov0" title="0">
                c.HTML(http.StatusOK, templateName, data)</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package page

import (
        "fmt"
        "net/http"
        "scaffold/server/user"
        "strings"

        "github.com/jfcarter2358/ui"
        "github.com/jfcarter2358/ui/breadcrumb"
        "github.com/jfcarter2358/ui/button"
        "github.com/jfcarter2358/ui/card"
        "github.com/jfcarter2358/ui/elements/br"
        "github.com/jfcarter2358/ui/elements/div"
        "github.com/jfcarter2358/ui/elements/h1"
        "github.com/jfcarter2358/ui/elements/link"
        "github.com/jfcarter2358/ui/modal"
        "github.com/jfcarter2358/ui/page"
        "github.com/jfcarter2358/ui/sidebar"
        "github.com/jfcarter2358/ui/table"
        "github.com/jfcarter2358/ui/table/cell"
        "github.com/jfcarter2358/ui/table/header"
        "github.com/jfcarter2358/ui/topbar"

        _ "embed"

        "github.com/gin-gonic/gin"
        logger "github.com/jfcarter2358/go-logger"
)

func UserPageEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        markdown := userBuildPage(ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func userBuildPage(ctx *gin.Context) []byte <span class="cov0" title="0">{
        username := ctx.Param("username")
        u, err := user.GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render user page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>

        <span class="cov0" title="0">p := page.Page{
                ID:             "page",
                SidebarEnabled: true,
                Sidebar: sidebar.Sidebar{
                        ID:      "sidebar",
                        Classes: "theme-light",
                        Components: []ui.Component{
                                link.Link{
                                        Title: "Dashboard",
                                        HRef:  "/ui/dashboard",
                                },
                                link.Link{
                                        Title: "Runs",
                                        HRef:  "/ui/runs",
                                },
                                link.Link{
                                        Title: "Users",
                                        HRef:  "/ui/users",
                                },
                                link.Link{
                                        Title: "Workflows",
                                        HRef:  "/ui/workflows",
                                },
                        },
                },
                Components: []ui.Component{
                        topbar.Topbar{
                                Title:   "Scaffold",
                                Classes: "ui-green",
                                Components: []ui.Component{
                                        button.Button{
                                                ID:      "generate_api_token_button",
                                                OnClick: "api_token_modal.showModal()",
                                                Title:   `Generate API Token`,
                                                Classes: "theme-base rounded-md",
                                                Style:   "margin-right:16px;",
                                        },
                                        button.Button{
                                                ID:      "save_user_button",
                                                OnClick: "saveUser()",
                                                Title:   `Save User`,
                                                Classes: "theme-base rounded-md",
                                                Style:   "margin-right:16px;",
                                        },
                                },
                                Buttons: []ui.Component{
                                        link.Link{
                                                Title:   "Logout",
                                                HRef:    "/auth/logout",
                                                Classes: "rounded-md",
                                        },
                                },
                                MenuClasses: "theme-light",
                        },
                        div.Div{
                                Classes: "theme-light rounded-md",
                                Components: []ui.Component{
                                        div.Div{
                                                Classes: "ui-green rounded-md",
                                                Components: []ui.Component{
                                                        breadcrumb.Breadcrumb{
                                                                Components: []ui.Component{
                                                                        link.Link{
                                                                                Title: "Users",
                                                                                HRef:  "/ui/users",
                                                                                Style: "margin-top:8px;",
                                                                        },
                                                                        link.Link{
                                                                                Title: username,
                                                                                HRef:  fmt.Sprintf("/ui/users/%s", username),
                                                                                Style: "margin-top:8px;",
                                                                        },
                                                                },
                                                                Style: "margin-left:16px;height:56px;",
                                                        },
                                                },
                                        },
                                        br.BR{},
                                        ui.Raw{
                                                HTMLString: `&lt;label style="padding-left:32px;padding-right:32px;"&gt;Username&lt;/label&gt;`,
                                        },
                                        ui.Raw{
                                                HTMLString: fmt.Sprintf(`&lt;input style="padding-left:32px;padding-right:32px;" class="w3-input w3-round theme-light" type="text" id="user-add-username" value="%s" disabled&gt;`, username),
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;label style="padding-left:32px;padding-right:32px;"&gt;Password&lt;/label&gt;`,
                                        },
                                        ui.Raw{
                                                HTMLString: fmt.Sprintf(`&lt;input style="padding-left:32px;padding-right:32px;" class="w3-input w3-round theme-light" type="password" id="user-add-password" value="%s"&gt;`, u.Password),
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;label style="padding-left:32px;padding-right:32px;"&gt;Given Name&lt;/label&gt;`,
                                        },
                                        ui.Raw{
                                                HTMLString: fmt.Sprintf(`&lt;input style="padding-left:32px;padding-right:32px;" class="w3-input w3-round theme-light" type="text" id="user-add-given-name" value="%s"&gt;`, u.GivenName),
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;label style="padding-left:32px;padding-right:32px;"&gt;Family Name&lt;/label&gt;`,
                                        },
                                        ui.Raw{
                                                HTMLString: fmt.Sprintf(`&lt;input style="padding-left:32px;padding-right:32px;" class="w3-input w3-round theme-light" type="text" id="user-add-family-name" value="%s"&gt;`, u.FamilyName),
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;label style="padding-left:32px;padding-right:32px;"&gt;Email&lt;/label&gt;`,
                                        },
                                        ui.Raw{
                                                HTMLString: fmt.Sprintf(`&lt;input style="padding-left:32px;padding-right:32px;" class="w3-input w3-round dark theme-light" type="text" id="user-add-email" value="%s"&gt;`, u.Email),
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;label style="padding-left:32px;padding-right:32px;"&gt;Groups&lt;/label&gt;`,
                                        },
                                        ui.Raw{
                                                HTMLString: fmt.Sprintf(`&lt;input style="padding-left:32px;padding-right:32px;" class="w3-input w3-round theme-light" type="text" id="group-tags" value="%s"&gt;`, strings.Join(u.Groups, ",")),
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;label style="padding-left:32px;padding-right:32px;"&gt;Roles&lt;/label&gt;`,
                                        },
                                        ui.Raw{
                                                HTMLString: fmt.Sprintf(`&lt;input style="padding-left:32px;padding-right:32px;" class="w3-input w3-round theme-light" type="text" id="role-tags" value="%s"&gt;`, strings.Join(u.Roles, ",")),
                                        },
                                        br.BR{},
                                        h1.H1{
                                                Contents: `
                                                &lt;h1 id="api-token-header" class="text-xl" style="float:left;padding-top:8px;padding-left:32px;"&gt;API Tokens&lt;/h1&gt;
                                                `,
                                                Classes: "ui-green rounded-md",
                                                Style:   "width:100%;",
                                        },
                                        br.BR{},
                                        br.BR{},
                                        table.Table{
                                                ID: "api-token-table",
                                                Headers: []header.Header{
                                                        {
                                                                Classes:  "text-lg",
                                                                Contents: "Name",
                                                        },
                                                        {
                                                                Classes:  "text-lg",
                                                                Contents: "Created",
                                                        },
                                                        {
                                                                Contents: "",
                                                                Classes:  "text-lg",
                                                        },
                                                },
                                                Rows: func(u user.User) [][]cell.Cell </span><span class="cov0" title="0">{
                                                        output := make([][]cell.Cell, 0)
                                                        for _, token := range u.APITokens </span><span class="cov0" title="0">{
                                                                r := []cell.Cell{
                                                                        {
                                                                                Contents: token.Name,
                                                                        },
                                                                        {
                                                                                Contents: token.Created,
                                                                        },
                                                                        {
                                                                                Contents: fmt.Sprintf(`&lt;div class="icon"&gt;&lt;i class="fa-solid fa-trash-can w3-large pointer-cursor" onclick="revokeAPIToken('%s')"&gt;&lt;/i&gt;&lt;/div&gt;`, token.Name),
                                                                        },
                                                                }
                                                                output = append(output, r)
                                                        }</span>
                                                        <span class="cov0" title="0">return output</span>
                                                }(*u),
                                        },
                                        br.BR{},
                                },
                                Style: "margin:64px;",
                        },
                        br.BR{},
                        ui.Raw{
                                HTMLString: `
                                &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt;
                                &lt;script src="/static/js/user.js"&gt;&lt;/script&gt;
                                &lt;script src="https://malsup.github.io/jquery.form.js"&gt;&lt;/script&gt; 
                                `,
                        },
                        modal.Modal{
                                ID: "api_token_modal",
                                Components: []ui.Component{
                                        h1.H1{
                                                Contents: `
                                                Generate API Token
                                                `,
                                                Classes: "ui-green rounded-md text-3xl",
                                                Style:   "width:100%;",
                                        },
                                        br.BR{},
                                        br.BR{},
                                        br.BR{},
                                        ui.Raw{
                                                HTMLString: `&lt;label&gt;Name&lt;/label&gt;`,
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;input class="w3-input w3-round theme-light" type="text" id="user-generate-api-token-name"&gt;`,
                                        },
                                        br.BR{},
                                        card.Card{
                                                Classes: "ui-green",
                                                Components: []ui.Component{
                                                        div.Div{
                                                                ID: "api-token-field",
                                                        },
                                                },
                                        },
                                        br.BR{},
                                        br.BR{},
                                        button.Button{
                                                ID:      "do_generate_api_token_button",
                                                OnClick: "generateAPIToken()",
                                                Title:   `Generate`,
                                                Style:   "",
                                                Classes: "theme-base",
                                        },
                                },
                                Classes: "",
                        },
                },
        }
        <span class="cov0" title="0">html, err := p.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render users page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package page

import (
        "net/http"
        "scaffold/server/user"
        "scaffold/server/utils"
        "sort"
        "strings"

        "github.com/jfcarter2358/ui"
        "github.com/jfcarter2358/ui/breadcrumb"
        "github.com/jfcarter2358/ui/button"
        "github.com/jfcarter2358/ui/elements/br"
        "github.com/jfcarter2358/ui/elements/div"
        "github.com/jfcarter2358/ui/elements/h1"
        "github.com/jfcarter2358/ui/elements/input"
        "github.com/jfcarter2358/ui/elements/label"
        "github.com/jfcarter2358/ui/elements/link"
        "github.com/jfcarter2358/ui/modal"
        "github.com/jfcarter2358/ui/page"
        "github.com/jfcarter2358/ui/sidebar"
        "github.com/jfcarter2358/ui/table"
        "github.com/jfcarter2358/ui/table/cell"
        "github.com/jfcarter2358/ui/table/header"
        "github.com/jfcarter2358/ui/topbar"

        _ "embed"

        "github.com/gin-gonic/gin"
        logger "github.com/jfcarter2358/go-logger"
)

func UsersSearchEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        searchTerm, ok := ctx.GetQuery("search")
        if !ok </span><span class="cov0" title="0">{
                ctx.Status(http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">query := strings.TrimSpace(searchTerm)

        users, err := user.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render users page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">filtered := []user.User{}

        for _, u := range users </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(u.FamilyName), strings.ToLower(query)) || strings.Contains(strings.ToLower(u.GivenName), strings.ToLower(query)) </span><span class="cov0" title="0">{
                        filtered = append(filtered, *u)
                }</span>
        }

        <span class="cov0" title="0">markdown := usersBuildTable(filtered, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func UsersTableEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        users, err := user.GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render users page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">filtered := []user.User{}

        for _, u := range users </span><span class="cov0" title="0">{
                filtered = append(filtered, *u)
        }</span>

        <span class="cov0" title="0">markdown := usersBuildTable(filtered, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func UsersPageEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        markdown := usersBuildPage(ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func usersBuildPage(ctx *gin.Context) []byte <span class="cov0" title="0">{
        p := page.Page{
                ID:             "page",
                SidebarEnabled: true,
                Sidebar: sidebar.Sidebar{
                        ID:      "sidebar",
                        Classes: "theme-light",
                        Components: []ui.Component{
                                link.Link{
                                        Title: "Dashboard",
                                        HRef:  "/ui/dashboard",
                                },
                                link.Link{
                                        Title: "Runs",
                                        HRef:  "/ui/runs",
                                },
                                link.Link{
                                        Title: "Users",
                                        HRef:  "/ui/users",
                                },
                                link.Link{
                                        Title: "Workflows",
                                        HRef:  "/ui/workflows",
                                },
                        },
                },
                Components: []ui.Component{
                        topbar.Topbar{
                                Title:   "Scaffold",
                                Classes: "ui-green",
                                Buttons: []ui.Component{
                                        link.Link{
                                                Title:   "Logout",
                                                HRef:    "/auth/logout",
                                                Style:   "passing:12px;",
                                                Classes: "theme-dark rounded-md",
                                        },
                                },
                                MenuClasses: "theme-light",
                        },
                        div.Div{
                                Classes: "theme-light rounded-md",
                                Components: []ui.Component{
                                        div.Div{
                                                Classes: "ui-green rounded-md",
                                                Style:   "height:64px;",
                                                Components: []ui.Component{
                                                        breadcrumb.Breadcrumb{
                                                                Components: []ui.Component{
                                                                        link.Link{
                                                                                Title: "Users",
                                                                                HRef:  "/ui/users",
                                                                        },
                                                                },
                                                                Style: "margin-left:16px;",
                                                        },
                                                        button.Button{
                                                                ID:      "inputs_button",
                                                                OnClick: "create_user_modal.showModal()",
                                                                Title:   `Create User&amp;nbsp;&lt;i class="fa-solid fa-user-plus"&gt;&lt;/i&gt;`,
                                                                Style:   "float:right;display:inline-block;margin-right:8px;margin-top:-32px;margin-bottom:8px;",
                                                                Classes: "theme-base",
                                                        },
                                                },
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;input id="search" class="w3-input w3-round search-bar theme-light" type="text"
                            name="search" placeholder="Search Users"
                            style="margin-top:8px;margin-bottom:8px;margin-left:1%;width:98%" hx-get="/htmx/users/search"
                            hx-trigger="keyup changed delay:250ms" hx-target="#users-table-div" /&gt;`,
                                        },
                                        div.Div{
                                                ID:        "users-table-div",
                                                HXTrigger: "load",
                                                HXGet:     "/htmx/users/table",
                                        },
                                },
                                Style: "margin:64px;",
                        },
                        br.BR{},
                        modal.Modal{
                                ID: "create_user_modal",
                                Components: []ui.Component{
                                        h1.H1{
                                                Contents: `&lt;h1 id="create-user-header" class="text-3xl" style="float:left;padding-top:8px;"&gt;Create User&lt;/h1&gt;`,
                                                Classes:  "ui-green rounded-md",
                                                Style:    "width:100%;",
                                        },
                                        br.BR{},
                                        br.BR{},
                                        label.Label{
                                                Contents: "Username",
                                        },
                                        input.Input{
                                                Classes: "w3-input w3-round theme-light",
                                                Type:    "text",
                                                ID:      "users-add-username",
                                        },
                                        label.Label{
                                                Contents: "Password",
                                        },
                                        input.Input{
                                                Classes: "w3-input w3-round theme-light",
                                                Type:    "password",
                                                ID:      "users-add-password",
                                        },
                                        label.Label{
                                                Contents: "Given Name",
                                        },
                                        input.Input{
                                                Classes: "w3-input w3-round theme-light",
                                                Type:    "text",
                                                ID:      "users-add-given-name",
                                        },
                                        label.Label{
                                                Contents: "Family Name",
                                        },
                                        input.Input{
                                                Classes: "w3-input w3-round theme-light",
                                                Type:    "text",
                                                ID:      "users-add-family-name",
                                        },
                                        label.Label{
                                                Contents: "Email",
                                        },
                                        input.Input{
                                                Classes: "w3-input w3-round theme-light",
                                                Type:    "text",
                                                ID:      "users-add-email",
                                        },
                                        label.Label{
                                                Contents: "Groups",
                                        },
                                        input.Input{
                                                Classes: "w3-input w3-round theme-light",
                                                Type:    "text",
                                                ID:      "users-add-groups",
                                        },
                                        label.Label{
                                                Contents: "Roles",
                                        },
                                        input.Input{
                                                Classes: "w3-input w3-round theme-light",
                                                Type:    "text",
                                                ID:      "users-add-roles",
                                        },
                                        button.Button{
                                                ID:      "do_add_user_button",
                                                OnClick: "addUser()",
                                                Title:   `Add User`,
                                                Style:   "",
                                                Classes: "theme-base",
                                        },
                                },
                        },
                        ui.Raw{
                                HTMLString: `
                                        &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt;
                                        &lt;script src="/static/js/users.js"&gt;&lt;/script&gt;
                                        `,
                        },
                },
        }
        html, err := p.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render users page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func usersBuildTable(us []user.User, ctx *gin.Context) []byte <span class="cov0" title="0">{
        sort.Slice(us, func(i, j int) bool </span><span class="cov0" title="0">{
                return us[i].GivenName &lt; us[j].GivenName
        }</span>)

        <span class="cov0" title="0">t := table.Table{
                ID: "users_table",
                Headers: []header.Header{
                        {
                                Contents: "Username",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Given Name",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Family Name",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Email",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Groups",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Roles",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Created",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Updated",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "",
                                Classes:  "text-lg",
                        },
                },
                Rows:          make([][]cell.Cell, 0),
                Classes:       "theme-light",
                Style:         "width:100%;",
                HeaderClasses: "rounded-md ui-green",
        }

        token, _ := ctx.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        isAdmin := false
        if utils.Contains(u.Groups, "admin") || utils.Contains(u.Roles, "admin") </span><span class="cov0" title="0">{
                isAdmin = true
        }</span>

        <span class="cov0" title="0">if isAdmin </span><span class="cov0" title="0">{
                for _, uu := range us </span><span class="cov0" title="0">{
                        groups := strings.Join(uu.Groups, ",")
                        roles := strings.Join(uu.Roles, ",")
                        r := []cell.Cell{
                                {
                                        Contents: uu.Username,
                                },
                                {
                                        Contents: uu.GivenName,
                                },
                                {
                                        Contents: uu.FamilyName,
                                },
                                {
                                        Contents: uu.Email,
                                },
                                {
                                        Contents: groups,
                                },
                                {
                                        Contents: roles,
                                },
                                {
                                        Contents: uu.Created,
                                },
                                {
                                        Contents: uu.Updated,
                                },
                                {
                                        Contents: `&lt;a href="/ui/users/` + uu.Username + `" class="table-link-link w3-right-align dark theme-text"
                    style="float:right;margin-right:16px;"&gt;
                    &lt;i class="fa-solid fa-link"&gt;&lt;/i&gt;
                &lt;/a&gt;`,
                                },
                                {
                                        Contents: `&lt;div class="table-link-link w3-right-align dark theme-text" style="float:right;margin-right:16px;"&gt;
                    &lt;i class="fa-solid fa-trash" style="cursor:pointer;" onclick="deleteUser('` + uu.Username + `')"&gt;&lt;/i&gt;
                &lt;/div&gt;`,
                                },
                        }
                        t.Rows = append(t.Rows, r)
                }</span>
        } else<span class="cov0" title="0"> {
                groups := strings.Join(u.Groups, ",")
                roles := strings.Join(u.Roles, ",")
                r := []cell.Cell{
                        {
                                Contents: u.Username,
                        },
                        {
                                Contents: u.GivenName,
                        },
                        {
                                Contents: u.FamilyName,
                        },
                        {
                                Contents: u.Email,
                        },
                        {
                                Contents: groups,
                        },
                        {
                                Contents: roles,
                        },
                        {
                                Contents: u.Created,
                        },
                        {
                                Contents: u.Updated,
                        },
                        {
                                Contents: `&lt;a href="/ui/users/` + u.Username + `" class="table-link-link w3-right-align dark theme-text"
                    style="float:right;margin-right:16px;"&gt;
                    &lt;i class="fa-solid fa-link"&gt;&lt;/i&gt;
                &lt;/a&gt;`,
                        },
                        {
                                Contents: `&lt;div class="table-link-link w3-right-align dark theme-text" style="float:right;margin-right:16px;"&gt;
                    &lt;i class="fa-solid fa-trash" style="cursor:pointer;" onclick="deleteUser('` + u.Username + `')"&gt;&lt;/i&gt;
                &lt;/div&gt;`,
                        },
                }
                t.Rows = append(t.Rows, r)
        }</span>

        <span class="cov0" title="0">html, err := t.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render users table: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package page

import (
        "fmt"
        "net/http"
        "scaffold/server/constants"
        "scaffold/server/state"
        "scaffold/server/utils"

        "github.com/jfcarter2358/ui"
        "github.com/jfcarter2358/ui/breadcrumb"
        "github.com/jfcarter2358/ui/button"
        "github.com/jfcarter2358/ui/card"
        "github.com/jfcarter2358/ui/collapse"
        "github.com/jfcarter2358/ui/elements/br"
        "github.com/jfcarter2358/ui/elements/div"
        "github.com/jfcarter2358/ui/elements/h1"
        "github.com/jfcarter2358/ui/elements/link"
        "github.com/jfcarter2358/ui/elements/pre"
        "github.com/jfcarter2358/ui/modal"
        "github.com/jfcarter2358/ui/page"
        "github.com/jfcarter2358/ui/sidebar"
        "github.com/jfcarter2358/ui/table"
        "github.com/jfcarter2358/ui/table/cell"
        "github.com/jfcarter2358/ui/table/header"
        "github.com/jfcarter2358/ui/topbar"

        _ "embed"

        "github.com/gin-gonic/gin"
        logger "github.com/jfcarter2358/go-logger"
)

type OutputData struct {
        Count int `json:"count"`
}

func WorkflowPageEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflowName := ctx.Param("name")
        markdown := workflowBuildPage(workflowName, ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowBuildPage(workflowName string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        wName := ctx.Param("name")
        p := page.Page{
                ID:             "page",
                SidebarEnabled: true,
                Sidebar: sidebar.Sidebar{
                        ID:      "sidebar",
                        Classes: "theme-light",
                        Components: []ui.Component{
                                h1.H1{
                                        Contents: "Scaffold",
                                        Classes:  "ui-green",
                                },
                                link.Link{
                                        Title: "Dashboard",
                                        HRef:  "/ui/dashboard",
                                },
                                link.Link{
                                        Title: "Runs",
                                        HRef:  "/ui/runs",
                                },
                                link.Link{
                                        Title: "Users",
                                        HRef:  "/ui/users",
                                },
                                link.Link{
                                        Title: "Workflows",
                                        HRef:  "/ui/workflows",
                                },
                        },
                },
                Components: []ui.Component{
                        topbar.Topbar{
                                Title:   "Scaffold",
                                Classes: "ui-green",
                                Buttons: []ui.Component{
                                        link.Link{
                                                Title:   "Logout",
                                                HRef:    "/auth/logout",
                                                Style:   "passing:12px;",
                                                Classes: "theme-dark rounded-md",
                                        },
                                },
                                MenuClasses: "theme-light",
                        },
                        div.Div{
                                Classes: "theme-dark rounded-md",
                                Components: []ui.Component{
                                        div.Div{
                                                Classes: "ui-green rounded-md",
                                                Style:   "padding-bottom:1px;",
                                                Components: []ui.Component{
                                                        breadcrumb.Breadcrumb{
                                                                Components: []ui.Component{
                                                                        link.Link{
                                                                                Title: "Workflows",
                                                                                HRef:  "/ui/workflows",
                                                                        },
                                                                        link.Link{
                                                                                Title: wName,
                                                                                HRef:  fmt.Sprintf("/ui/workflows/%s", wName),
                                                                        },
                                                                },
                                                                Style: "margin-left:16px;",
                                                        },
                                                        button.Button{
                                                                ID:      "auto_execute_button",
                                                                OnClick: "auto_execute_modal.showModal()",
                                                                Title:   `Auto Execute&amp;nbsp;&lt;i class="fa-solid fa-play"&gt;&lt;/i&gt;`,
                                                                Style:   "float:right;display:inline-block;margin-right:8px;margin-top:-32px;margin-bottom:8px;",
                                                                Classes: "theme-base",
                                                        },
                                                        button.Button{
                                                                ID:      "inputs_button",
                                                                OnClick: "inputs_modal.showModal()",
                                                                Title:   `Inputs&amp;nbsp;&lt;i class="fa-solid fa-pencil"&gt;&lt;/i&gt;`,
                                                                Style:   "float:right;display:inline-block;margin-right:8px;margin-top:-32px;margin-bottom:8px;",
                                                                Classes: "theme-base",
                                                        },
                                                        // button.Button{
                                                        //         ID:      "file_button",
                                                        //         OnClick: "file_modal.showModal()",
                                                        //         Title:   `Files&amp;nbsp;&lt;i class="fa-solid fa-file"&gt;&lt;/i&gt;`,
                                                        //         Style:   "float:right;display:inline-block;margin-right:8px;margin-top:-32px;margin-bottom:8px;",
                                                        //         Classes: "theme-base",
                                                        // },
                                                        ui.Raw{
                                                                HTMLString: `&lt;input id="search" class="w3-input w3-round search-bar dark theme-light" type="text" name="search" placeholder="Search Tasks" style="margin-left:5%;margin-top:8px;margin-bottom:8px;width:90%;" oninput="render()"&gt;`,
                                                        },
                                                },
                                        },
                                        card.Card{
                                                ID:      "workflow-card",
                                                Classes: "theme-light",
                                                Style:   "width:100%;padding:0px;height:100%;",
                                        },
                                        br.BR{},
                                        modal.Modal{
                                                ID: "auto_execute_modal",
                                                Components: []ui.Component{
                                                        h1.H1{
                                                                Contents: `&lt;h1 id="current-auto-execute-header" class="text-3xl" style="float:left;padding-top:8px;"&gt;Auto Execute&lt;/h1&gt;`,
                                                                Classes:  "ui-green rounded-md",
                                                                Style:    "width:100%;",
                                                        },
                                                        br.BR{},
                                                        br.BR{},
                                                        br.BR{},
                                                        div.Div{
                                                                ID: "auto-execute-div",
                                                        },
                                                },
                                        },
                                        modal.Modal{
                                                ID: "inputs_modal",
                                                Components: []ui.Component{
                                                        h1.H1{
                                                                Contents: `
                                                                &lt;h1 id="current-inputs-header" class="text-3xl" style="float:left;padding-top:8px;"&gt;Inputs&lt;/h1&gt;
                                                                &lt;span onclick="saveInputs()" class="w3-button dark theme-light w3-round" style="margin-top:5px;float:right;margin-right:8px;"&gt;&lt;i class="fa-solid fa-floppy-disk" id="save-icon"&gt;&lt;/i&gt;&lt;/span&gt;
                                                                `,
                                                                Classes: "ui-green rounded-md",
                                                                Style:   "width:100%;",
                                                        },
                                                        br.BR{},
                                                        br.BR{},
                                                        br.BR{},
                                                        div.Div{
                                                                ID: "current-input-div",
                                                        },
                                                },
                                        },
                                        // modal.Modal{
                                        //         ID:         "state_modal",
                                        //         Components: []ui.Component{},
                                        //         BoxClasses: "max-w-none w-4/5",
                                        // },
                                        modal.Modal{
                                                ID: "state_modal",
                                                Components: []ui.Component{
                                                        h1.H1{
                                                                Contents: `
                                                                &lt;h1 id="current-state-header" class="text-3xl" style="float:left;padding-top:8px;"&gt;&lt;/h1&gt;
                                                                &lt;span onclick="killRun()" class="w3-button dark theme-light w3-round" style="margin-top:5px;float:right;margin-right:8px;"&gt;&lt;i class="fa-solid fa-stop"&gt;&lt;/i&gt;&lt;/span&gt;
                                                                &lt;span onclick="triggerRun()" class="w3-button dark theme-light w3-round" style="margin-top:5px;float:right;margin-right:8px;"&gt;&lt;i class="fa-solid fa-play"&gt;&lt;/i&gt;&lt;/span&gt;
                                                                &lt;span onclick="toggleDisable()" class="w3-button dark theme-light w3-round" style="margin-top:5px;float:right;margin-right:8px;"&gt;&lt;i class="fa-solid fa-toggle-on" id="toggle-icon"&gt;&lt;/i&gt;&lt;/span&gt;
                                                                `,
                                                                Classes: fmt.Sprintf("%s rounded-md", "ui-green"),
                                                                Style:   "width:100%;",
                                                        },
                                                        br.BR{},
                                                        br.BR{},
                                                        br.BR{},
                                                        collapse.Collapse{
                                                                TitleID:      "state-status-collapse",
                                                                Classes:      "theme-light",
                                                                TitleClasses: "ui-green",
                                                                Title:        "Status",
                                                                Components: []ui.Component{
                                                                        br.BR{},
                                                                        div.Div{
                                                                                Components: []ui.Component{
                                                                                        ui.Raw{
                                                                                                HTMLString: `&lt;span id="state-status"&gt;&lt;/span&gt;`,
                                                                                        },
                                                                                        br.BR{},
                                                                                        ui.Raw{
                                                                                                HTMLString: `&lt;span id="state-started"&gt;&lt;/span&gt;`,
                                                                                        },
                                                                                        br.BR{},
                                                                                        ui.Raw{
                                                                                                HTMLString: `&lt;span id="state-finished"&gt;&lt;/span&gt;`,
                                                                                        },
                                                                                        br.BR{},
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                        br.BR{},
                                                        collapse.Collapse{
                                                                TitleID:      "state-context-collapse",
                                                                Classes:      "theme-light",
                                                                TitleClasses: "ui-green",
                                                                Title:        "Context",
                                                                Components: []ui.Component{
                                                                        br.BR{},
                                                                        div.Div{
                                                                                ID: "state-context",
                                                                        },
                                                                },
                                                        },
                                                        br.BR{},
                                                        collapse.Collapse{
                                                                TitleID:      "state-display-collapse",
                                                                Classes:      "theme-light",
                                                                TitleClasses: "ui-green",
                                                                Title:        "Display",
                                                                Components: []ui.Component{
                                                                        div.Div{
                                                                                ID: "state-current-display-data",
                                                                        },
                                                                },
                                                        },
                                                        br.BR{},
                                                        collapse.Collapse{
                                                                TitleID:      "state-output-collapse",
                                                                Classes:      "theme-light",
                                                                TitleClasses: "ui-green",
                                                                Title:        "Output",
                                                                Components: []ui.Component{
                                                                        pre.Pre{
                                                                                ID:    "state-output",
                                                                                Style: "font-family:monospace;overflow-x:scroll",
                                                                        },
                                                                },
                                                        },
                                                },
                                                BoxClasses: "max-w-none w-4/5",
                                        },
                                        ui.Raw{
                                                HTMLString: `
                                                &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt;
                                                &lt;script src="https://malsup.github.io/jquery.form.js"&gt;&lt;/script&gt;
                                                &lt;script src="/static/js/jquery-ui.min.js"&gt;&lt;/script&gt;
                                                &lt;script src="/static/js/dagre.min.js"&gt;&lt;/script&gt;
                                                &lt;script src="/static/js/workflow.js"&gt;&lt;/script&gt;
                                                `,
                                        },
                                },
                                Style: "margin:64px;height:200%;padding-bottom:150px;",
                        },
                        br.BR{},
                },
        }
        html, err := p.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render workflow page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func WorkflowModalEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflowName := ctx.Param("name")
        taskName := ctx.Param("task")
        markdown := workflowBuildModal(workflowName, taskName, ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowBuildModal(workflowName, taskName string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        s, err := state.GetStateByNames(workflowName, taskName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
                return []byte(fmt.Sprintf("Unable to access state for task %s in workflow %s", taskName, workflowName))
        }</span>
        <span class="cov0" title="0">color := getStateColor(*s)
        d := modal.Modal{
                ID: "state_modal",
                Components: []ui.Component{
                        h1.H1{
                                Contents: `
                                        &lt;h1 id="current-state-header" class="text-3xl" style="float:left;padding-top:8px;"&gt;&lt;/h1&gt;
                                        &lt;span onclick="killRun()" class="w3-button dark theme-light w3-round" style="margin-top:5px;float:right;margin-right:8px;"&gt;&lt;i class="fa-solid fa-stop"&gt;&lt;/i&gt;&lt;/span&gt;
                                        &lt;span onclick="triggerRun()" class="w3-button dark theme-light w3-round" style="margin-top:5px;float:right;margin-right:8px;"&gt;&lt;i class="fa-solid fa-play"&gt;&lt;/i&gt;&lt;/span&gt;
                                        &lt;span onclick="toggleDisable()" class="w3-button dark theme-light w3-round" style="margin-top:5px;float:right;margin-right:8px;"&gt;&lt;i class="fa-solid fa-toggle-on" id="toggle-icon"&gt;&lt;/i&gt;&lt;/span&gt;
                                `,
                                Classes: fmt.Sprintf("%s rounded-md", color),
                                Style:   "width:100%;",
                        },
                        br.BR{},
                        br.BR{},
                        br.BR{},
                        collapse.Collapse{
                                TitleID:      "state-status-collapse",
                                Classes:      "theme-light",
                                TitleClasses: color,
                                Title:        "Status",
                                Components: []ui.Component{
                                        br.BR{},
                                        div.Div{
                                                Components: []ui.Component{
                                                        ui.Raw{
                                                                HTMLString: fmt.Sprintf(`&lt;span id="state-status" hx-get="/htmx/workflow/%s/status/%s" hx-trigger="load, every 2s"&gt;&lt;/span&gt;`, workflowName, taskName),
                                                        },
                                                        br.BR{},
                                                        ui.Raw{
                                                                HTMLString: fmt.Sprintf(`&lt;span id="state-started" hx-get="/htmx/workflow/%s/started/%s" hx-trigger="load, every 2s"&gt;&lt;/span&gt;`, workflowName, taskName),
                                                        },
                                                        br.BR{},
                                                        ui.Raw{
                                                                HTMLString: fmt.Sprintf(`&lt;span id="state-finished" hx-get="/htmx/workflow/%s/finished/%s" hx-trigger="load, every 2s"&gt;&lt;/span&gt;`, workflowName, taskName),
                                                        },
                                                        br.BR{},
                                                },
                                        },
                                },
                        },
                        br.BR{},
                        collapse.Collapse{
                                TitleID:      "state-context-collapse",
                                Classes:      "theme-light",
                                TitleClasses: color,
                                Title:        "Context",
                                Components: []ui.Component{
                                        br.BR{},
                                        div.Div{
                                                ID:        "state-context",
                                                HXTrigger: "load",
                                                HXGet:     fmt.Sprintf("/htmx/workflow/%s/context/%s", workflowName, taskName),
                                        },
                                },
                        },
                        br.BR{},
                        collapse.Collapse{
                                TitleID:      "state-display-collapse",
                                Classes:      "theme-light",
                                TitleClasses: color,
                                Title:        "Display",
                                Components: []ui.Component{
                                        div.Div{
                                                ID:        "state-current-display-data",
                                                HXTrigger: "load, every 2s",
                                                HXGet:     fmt.Sprintf("/htmx/workflow/%s/display/%s", workflowName, taskName),
                                        },
                                },
                        },
                        br.BR{},
                        collapse.Collapse{
                                TitleID:      "state-output-collapse",
                                Classes:      "theme-light",
                                TitleClasses: color,
                                Title:        "Output",
                                Components: []ui.Component{
                                        ui.Raw{
                                                HTMLString: `
                                                &lt;pre 
                                                        id="state-output"
                                                        style="font-family:monospace;overflow-x:scroll"
                                                        hx-trigger="load, every 2s"
                                                        hx-post="/htmx/workflow/%s/output/%s",
                                                        hx-vals='js:{
                                                                "count": jQuery("#state-output").html().length
                                                        }'
                                                        hx-swap="beforeend"
                                                        &lt;/pre&gt;
                                                        `,
                                        },
                                },
                        },
                },
                BoxClasses: "max-w-none w-4/5",
        }
        html, err := d.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render dashboard table: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func WorkflowStatusEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflowName := ctx.Param("name")
        taskName := ctx.Param("task")
        markdown := workflowBuildStatus(workflowName, taskName, ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowBuildStatus(workflowName, taskName string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        s, err := state.GetStateByNames(workflowName, taskName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
                return []byte(fmt.Sprintf("Unable to access state for task %s in workflow %s", taskName, workflowName))
        }</span>
        <span class="cov0" title="0">return []byte(s.Status)</span>
}

func WorkflowStartedEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflowName := ctx.Param("name")
        taskName := ctx.Param("task")
        markdown := workflowBuildStarted(workflowName, taskName, ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowBuildStarted(workflowName, taskName string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        s, err := state.GetStateByNames(workflowName, taskName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
                return []byte(fmt.Sprintf("Unable to access state for task %s in workflow %s", taskName, workflowName))
        }</span>
        <span class="cov0" title="0">return []byte(s.Started)</span>
}

func WorkflowFinishedEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflowName := ctx.Param("name")
        taskName := ctx.Param("task")
        markdown := workflowBuildFinished(workflowName, taskName, ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowBuildFinished(workflowName, taskName string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        s, err := state.GetStateByNames(workflowName, taskName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
                return []byte(fmt.Sprintf("Unable to access state for task %s in workflow %s", taskName, workflowName))
        }</span>
        <span class="cov0" title="0">return []byte(s.Finished)</span>
}

func WorkflowContextEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflowName := ctx.Param("name")
        taskName := ctx.Param("task")
        markdown := workflowBuildContext(workflowName, taskName, ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowBuildContext(workflowName, taskName string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        s, err := state.GetStateByNames(workflowName, taskName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
                return []byte(fmt.Sprintf("Unable to access state for task %s in workflow %s", taskName, workflowName))
        }</span>
        <span class="cov0" title="0">return []byte(s.Finished)</span>
}

func WorkflowDisplayEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflowName := ctx.Param("name")
        taskName := ctx.Param("task")
        markdown := workflowBuildDisplay(workflowName, taskName, ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowBuildDisplay(workflowName, taskName string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        s, err := state.GetStateByNames(workflowName, taskName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
                return []byte(fmt.Sprintf("Unable to access state for task %s in workflow %s", taskName, workflowName))
        }</span>
        <span class="cov0" title="0">html := ""
        for _, currentDisplay := range s.Display </span><span class="cov0" title="0">{
                color := getStateColor(*s)
                textColor := getStateTextColor(*s)
                html += buildDisplayTable(currentDisplay, color, textColor, ctx)
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func buildDisplayTable(displayMap map[string]interface{}, color, textColor string, ctx *gin.Context) string <span class="cov0" title="0">{
        headers := []header.Header{}
        rows := [][]cell.Cell{}

        for _, h := range displayMap["header"].([]interface{}) </span><span class="cov0" title="0">{
                headers = append(headers, header.Header{
                        Contents: h.(string),
                        Classes:  "text-lg",
                })
        }</span>

        <span class="cov0" title="0">for _, data := range displayMap["data"].([]interface{}) </span><span class="cov0" title="0">{
                row := []cell.Cell{}
                for _, datum := range data.([]interface{}) </span><span class="cov0" title="0">{
                        row = append(row, cell.Cell{
                                Contents: datum.(string),
                        })
                }</span>
                <span class="cov0" title="0">rows = append(rows, row)</span>
        }

        <span class="cov0" title="0">c := card.Card{
                Classes: "theme-light theme-border-light",
                Components: []ui.Component{
                        ui.Raw{
                                HTMLString: fmt.Sprintf(`
            &lt;header class="w3-container %s"&gt;
                &lt;h4&gt;%s&lt;/h4&gt;
            &lt;/header&gt;
        `, color, displayMap["name"].(string)),
                        },
                        table.Table{
                                ID:            "workflows_table",
                                Headers:       headers,
                                Rows:          rows,
                                Classes:       "theme-light",
                                Style:         "width:100%;",
                                HeaderClasses: "rounded-md ui-green",
                        },
                },
        }

        html, err := c.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render display table: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return ""
        }</span>
        <span class="cov0" title="0">return html</span>
}

func WorkflowOutputEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflowName := ctx.Param("name")
        taskName := ctx.Param("task")
        markdown := workflowBuildOutput(workflowName, taskName, ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowBuildOutput(workflowName, taskName string, ctx *gin.Context) []byte <span class="cov0" title="0">{
        s, err := state.GetStateByNames(workflowName, taskName)
        if err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusNotFound)
                return []byte(fmt.Sprintf("Unable to access state for task %s in workflow %s", taskName, workflowName))
        }</span>

        <span class="cov0" title="0">var d OutputData
        if err := ctx.ShouldBindJSON(&amp;d); err != nil </span><span class="cov0" title="0">{
                utils.Error(err, ctx, http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">output := s.Output
        output = output[d.Count:]
        return []byte(output)</span>
}

func getStateColor(s state.State) string <span class="cov0" title="0">{
        switch s.Status </span>{
        case constants.STATE_STATUS_ERROR:<span class="cov0" title="0">
                return fmt.Sprintf("ui-%s", constants.UI_COLORS[constants.NODE_ERROR])</span>
        case constants.STATE_STATUS_KILLED:<span class="cov0" title="0">
                return fmt.Sprintf("ui-%s", constants.UI_COLORS[constants.NODE_KILLED])</span>
        case constants.STATE_STATUS_NOT_STARTED:<span class="cov0" title="0">
                return fmt.Sprintf("ui-%s", constants.UI_COLORS[constants.NODE_NOT_DEPLOYED])</span>
        case constants.STATE_STATUS_RUNNING:<span class="cov0" title="0">
                return fmt.Sprintf("ui-%s", constants.UI_COLORS[constants.NODE_RUNNING])</span>
        case constants.STATE_STATUS_SUCCESS:<span class="cov0" title="0">
                return fmt.Sprintf("ui-%s", constants.UI_COLORS[constants.NODE_SUCCESS])</span>
        case constants.STATE_STATUS_WAITING:<span class="cov0" title="0">
                return fmt.Sprintf("ui-%s", constants.UI_COLORS[constants.NODE_WAITING])</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("ui-%s", constants.UI_COLORS[constants.NODE_UNKNOWN])</span>
}

func getStateTextColor(s state.State) string <span class="cov0" title="0">{
        switch s.Status </span>{
        case constants.STATE_STATUS_ERROR:<span class="cov0" title="0">
                return fmt.Sprintf("ui-text-%s", constants.UI_COLORS[constants.NODE_ERROR])</span>
        case constants.STATE_STATUS_KILLED:<span class="cov0" title="0">
                return fmt.Sprintf("ui-text-%s", constants.UI_COLORS[constants.NODE_KILLED])</span>
        case constants.STATE_STATUS_NOT_STARTED:<span class="cov0" title="0">
                return fmt.Sprintf("ui-text-%s", constants.UI_COLORS[constants.NODE_NOT_DEPLOYED])</span>
        case constants.STATE_STATUS_RUNNING:<span class="cov0" title="0">
                return fmt.Sprintf("ui-text-%s", constants.UI_COLORS[constants.NODE_RUNNING])</span>
        case constants.STATE_STATUS_SUCCESS:<span class="cov0" title="0">
                return fmt.Sprintf("ui-text-%s", constants.UI_COLORS[constants.NODE_SUCCESS])</span>
        case constants.STATE_STATUS_WAITING:<span class="cov0" title="0">
                return fmt.Sprintf("ui-text-%s", constants.UI_COLORS[constants.NODE_WAITING])</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("ui-text-%s", constants.UI_COLORS[constants.NODE_UNKNOWN])</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package page

import (
        "net/http"
        "scaffold/server/user"
        "scaffold/server/workflow"
        "sort"
        "strings"

        "github.com/jfcarter2358/ui"
        "github.com/jfcarter2358/ui/breadcrumb"
        "github.com/jfcarter2358/ui/elements/br"
        "github.com/jfcarter2358/ui/elements/div"
        "github.com/jfcarter2358/ui/elements/link"
        "github.com/jfcarter2358/ui/page"
        "github.com/jfcarter2358/ui/sidebar"
        "github.com/jfcarter2358/ui/table"
        "github.com/jfcarter2358/ui/table/cell"
        "github.com/jfcarter2358/ui/table/header"
        "github.com/jfcarter2358/ui/topbar"

        _ "embed"

        "github.com/gin-gonic/gin"
        logger "github.com/jfcarter2358/go-logger"
)

func WorkflowsSearchEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        searchTerm, ok := ctx.GetQuery("search")
        if !ok </span><span class="cov0" title="0">{
                ctx.Status(http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">query := strings.TrimSpace(searchTerm)

        workflows := workflow.GetCacheAll()

        filtered := []workflow.Workflow{}

        for name, w := range workflows </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(name), strings.ToLower(query)) </span><span class="cov0" title="0">{
                        filtered = append(filtered, w)
                }</span>
        }

        <span class="cov0" title="0">markdown := workflowsBuildTable(filtered, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func WorkflowsTableEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        workflows := workflow.GetCacheAll()
        filtered := []workflow.Workflow{}

        for _, w := range workflows </span><span class="cov0" title="0">{
                filtered = append(filtered, w)
        }</span>

        <span class="cov0" title="0">markdown := workflowsBuildTable(filtered, ctx)

        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)</span>
}

func WorkflowsPageEndpoint(ctx *gin.Context) <span class="cov0" title="0">{
        markdown := workflowsBuildPage(ctx)
        ctx.Data(http.StatusOK, "text/html; charset=utf-8", markdown)
}</span>

func workflowsBuildPage(ctx *gin.Context) []byte <span class="cov0" title="0">{
        p := page.Page{
                ID:             "page",
                SidebarEnabled: true,
                Sidebar: sidebar.Sidebar{
                        ID:      "sidebar",
                        Classes: "theme-light",
                        Components: []ui.Component{
                                link.Link{
                                        Title: "Dashboard",
                                        HRef:  "/ui/dashboard",
                                },
                                link.Link{
                                        Title: "Runs",
                                        HRef:  "/ui/runs",
                                },
                                link.Link{
                                        Title: "Users",
                                        HRef:  "/ui/users",
                                },
                                link.Link{
                                        Title: "Workflows",
                                        HRef:  "/ui/workflows",
                                },
                        },
                },
                Components: []ui.Component{
                        topbar.Topbar{
                                Title:   "Scaffold",
                                Classes: "ui-green",
                                Buttons: []ui.Component{
                                        link.Link{
                                                Title:   "Logout",
                                                HRef:    "/auth/logout",
                                                Style:   "passing:12px;",
                                                Classes: "theme-dark rounded-md",
                                        },
                                },
                                MenuClasses: "theme-light",
                        },
                        div.Div{
                                Classes: "theme-light rounded-md",
                                Components: []ui.Component{
                                        div.Div{
                                                Classes: "ui-green rounded-md",
                                                Components: []ui.Component{
                                                        breadcrumb.Breadcrumb{
                                                                Components: []ui.Component{
                                                                        link.Link{
                                                                                Title: "Workflows",
                                                                                HRef:  "/ui/workflows",
                                                                        },
                                                                },
                                                                Style: "margin-left:16px;",
                                                        },
                                                },
                                        },
                                        ui.Raw{
                                                HTMLString: `&lt;input id="search" class="w3-input w3-round search-bar theme-light" type="text"
                            name="search" placeholder="Search Workflows"
                            style="margin-top:8px;margin-bottom:8px;margin-left:1%;width:98%" hx-get="/htmx/workflows/search"
                            hx-trigger="keyup changed delay:250ms" hx-target="#workflows-table-div" /&gt;`,
                                        },
                                        div.Div{
                                                ID:        "workflows-table-div",
                                                HXTrigger: "load",
                                                HXGet:     "/htmx/workflows/table",
                                        },
                                },
                                Style: "margin:64px;",
                        },
                        br.BR{},
                },
        }
        html, err := p.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render workflows page: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}

func workflowsBuildTable(ws []workflow.Workflow, ctx *gin.Context) []byte <span class="cov0" title="0">{
        sort.Slice(ws, func(i, j int) bool </span><span class="cov0" title="0">{
                return ws[i].Name &lt; ws[j].Name
        }</span>)

        <span class="cov0" title="0">t := table.Table{
                ID: "workflows_table",
                Headers: []header.Header{
                        {
                                Contents: "Name",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Created",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Updated",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "Version",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "",
                                Classes:  "text-lg",
                        },
                        {
                                Contents: "",
                                Classes:  "text-lg",
                        },
                },
                Rows:          make([][]cell.Cell, 0),
                Classes:       "theme-light",
                Style:         "width:100%;",
                HeaderClasses: "rounded-md ui-green",
        }

        token, _ := ctx.Cookie("scaffold_token")
        u, _ := user.GetUserByLoginToken(token)

        for _, w := range ws </span><span class="cov0" title="0">{
                isInGroup := false
                isAdmin := false
                for _, ug := range u.Groups </span><span class="cov0" title="0">{
                        if ug == "admin" </span><span class="cov0" title="0">{
                                isInGroup = true
                                isAdmin = true
                                break</span>
                        }
                        <span class="cov0" title="0">for _, wg := range w.Groups </span><span class="cov0" title="0">{
                                if ug == wg </span><span class="cov0" title="0">{
                                        isInGroup = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isInGroup </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">for _, ur := range u.Roles </span><span class="cov0" title="0">{
                        if ur == "admin" </span><span class="cov0" title="0">{
                                isAdmin = true
                                break</span>
                        }
                        <span class="cov0" title="0">if ur == "write" </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov0" title="0">r := []cell.Cell{
                        {
                                Contents: w.Name,
                        },
                        {
                                Contents: w.Created,
                        },
                        {
                                Contents: w.Updated,
                        },
                        {
                                Contents: w.Version,
                        },
                        {
                                Contents: `&lt;a href="/ui/workflows/` + w.Name + `" class="table-link-link w3-right-align dark theme-text"
                    style="float:right;margin-right:16px;"&gt;
                    &lt;i class="fa-solid fa-link"&gt;&lt;/i&gt;
                &lt;/a&gt;`,
                        },
                        {
                                Contents: "",
                        },
                }
                if isAdmin </span><span class="cov0" title="0">{
                        r[len(r)-1] = cell.Cell{
                                Contents: `&lt;div class="table-link-link w3-right-align dark theme-text" style="float:right;margin-right:16px;"&gt;
                    &lt;i class="fa-solid fa-trash" style="cursor:pointer;" onclick="deleteWorkflow('` + w.Name + `')"&gt;&lt;/i&gt;
                &lt;/div&gt;`,
                        }
                }</span>
                <span class="cov0" title="0">t.Rows = append(t.Rows, r)</span>
        }

        <span class="cov0" title="0">html, err := t.Render()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot render workflows table: %s", err.Error())
                ctx.AbortWithStatus(http.StatusInternalServerError)
                return []byte{}
        }</span>
        <span class="cov0" title="0">return []byte(html)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package proxy

import (
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "net/url"
        "scaffold/server/user"
        "scaffold/server/utils"
        "scaffold/server/workflow"
        "strings"

        logger "github.com/jfcarter2358/go-logger"

        "github.com/gorilla/mux"
        "github.com/gorilla/websocket"
)

var (
        // DefaultUpgrader specifies the parameters for upgrading an HTTP
        // connection to a WebSocket connection.
        DefaultUpgrader = &amp;websocket.Upgrader{
                ReadBufferSize:  1024,
                WriteBufferSize: 1024,
        }

        // DefaultDialer is a dialer with all fields set to the default zero values.
        DefaultDialer = websocket.DefaultDialer
)

// WebsocketProxy is an HTTP Handler that takes an incoming WebSocket
// connection and proxies it to another server.
type WebsocketProxy struct {
        // Director, if non-nil, is a function that may copy additional request
        // headers from the incoming WebSocket connection into the output headers
        // which will be forwarded to another server.
        Director func(incoming *http.Request, out http.Header)

        // Backend returns the backend URL which the proxy uses to reverse proxy
        // the incoming WebSocket connection. Request is the initial incoming and
        // unmodified request.
        Backend func(*http.Request) *url.URL

        // Upgrader specifies the parameters for upgrading a incoming HTTP
        // connection to a WebSocket connection. If nil, DefaultUpgrader is used.
        Upgrader *websocket.Upgrader

        //  Dialer contains options for connecting to the backend WebSocket server.
        //  If nil, DefaultDialer is used.
        Dialer *websocket.Dialer
}

// ProxyHandler returns a new http.Handler interface that reverse proxies the
// request to the given target.
func ProxyHandler(target *url.URL) http.Handler <span class="cov0" title="0">{ return NewProxy() }</span>

// NewProxy returns a new Websocket reverse proxy that rewrites the
// URL's to the scheme, host and base path provider in target.
func NewProxy() *WebsocketProxy <span class="cov0" title="0">{
        backend := func(r *http.Request) *url.URL </span><span class="cov0" title="0">{
                vars := mux.Vars(r)
                host := vars["host"]
                port := vars["port"]
                workflowName := vars["workflow"]
                run := vars["run"]
                version := vars["version"]

                c, err := workflow.GetWorkflowByName(workflowName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln(err)
                }</span>

                <span class="cov0" title="0">authString := r.Header.Get("Authorization")
                if authString == "" </span><span class="cov0" title="0">{
                        log.Fatalln("No auth header present")
                }</span>
                <span class="cov0" title="0">token := strings.Split(authString, " ")[1]

                usr, _ := user.GetUserByAPIToken(token)

                if usr == nil </span><span class="cov0" title="0">{
                        log.Fatalln("No user present that matches auth information")
                }</span>
                <span class="cov0" title="0">isValid := false
                for _, group := range c.Groups </span><span class="cov0" title="0">{
                        if utils.Contains(usr.Groups, group) </span><span class="cov0" title="0">{
                                isValid = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        log.Fatalln("User is not permitted to access this container")
                }</span>

                <span class="cov0" title="0">logger.Tracef("", "Trying to exec with information %s, %s, %s, %s, %s", host, port, workflowName, run, version)

                url, err := url.Parse(fmt.Sprintf("ws://%s:%s/ws/%s/%s/%s", host, port, workflowName, run, version))
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalln(err)
                }</span>

                // Shallow copy
                <span class="cov0" title="0">u := *url
                u.Fragment = r.URL.Fragment
                // u.Path = r.URL.Path
                // u.RawQuery = r.URL.RawQuery
                return &amp;u</span>
        }
        <span class="cov0" title="0">return &amp;WebsocketProxy{Backend: backend}</span>
}

// ServeHTTP implements the http.Handler that proxies WebSocket connections.
func (w *WebsocketProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        if w.Backend == nil </span><span class="cov0" title="0">{
                log.Println("websocketproxy: backend function is not defined")
                http.Error(rw, "internal server error (code: 1)", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">backendURL := w.Backend(req)
        if backendURL == nil </span><span class="cov0" title="0">{
                log.Println("websocketproxy: backend URL is nil")
                http.Error(rw, "internal server error (code: 2)", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">dialer := w.Dialer
        if w.Dialer == nil </span><span class="cov0" title="0">{
                dialer = DefaultDialer
        }</span>

        // Pass headers from the incoming request to the dialer to forward them to
        // the final destinations.
        <span class="cov0" title="0">requestHeader := http.Header{}
        if origin := req.Header.Get("Origin"); origin != "" </span><span class="cov0" title="0">{
                requestHeader.Add("Origin", origin)
        }</span>
        <span class="cov0" title="0">for _, prot := range req.Header[http.CanonicalHeaderKey("Sec-WebSocket-Protocol")] </span><span class="cov0" title="0">{
                requestHeader.Add("Sec-WebSocket-Protocol", prot)
        }</span>
        <span class="cov0" title="0">for _, cookie := range req.Header[http.CanonicalHeaderKey("Cookie")] </span><span class="cov0" title="0">{
                requestHeader.Add("Cookie", cookie)
        }</span>
        <span class="cov0" title="0">if req.Host != "" </span><span class="cov0" title="0">{
                requestHeader.Set("Host", req.Host)
        }</span>

        // Pass X-Forwarded-For headers too, code below is a part of
        // httputil.ReverseProxy. See http://en.wikipedia.org/wiki/X-Forwarded-For
        // for more information
        // TODO: use RFC7239 http://tools.ietf.org/html/rfc7239
        <span class="cov0" title="0">if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil </span><span class="cov0" title="0">{
                // If we aren't the first proxy retain prior
                // X-Forwarded-For information as a comma+space
                // separated list and fold multiple headers into one.
                if prior, ok := req.Header["X-Forwarded-For"]; ok </span><span class="cov0" title="0">{
                        clientIP = strings.Join(prior, ", ") + ", " + clientIP
                }</span>
                <span class="cov0" title="0">requestHeader.Set("X-Forwarded-For", clientIP)</span>
        }

        // Set the originating protocol of the incoming HTTP request. The SSL might
        // be terminated on our site and because we doing proxy adding this would
        // be helpful for applications on the backend.
        <span class="cov0" title="0">requestHeader.Set("X-Forwarded-Proto", "http")
        if req.TLS != nil </span><span class="cov0" title="0">{
                requestHeader.Set("X-Forwarded-Proto", "https")
        }</span>

        // Enable the director to copy any additional headers it desires for
        // forwarding to the remote server.
        <span class="cov0" title="0">if w.Director != nil </span><span class="cov0" title="0">{
                w.Director(req, requestHeader)
        }</span>

        // Connect to the backend URL, also pass the headers we get from the requst
        // together with the Forwarded headers we prepared above.
        // TODO: support multiplexing on the same backend connection instead of
        // opening a new TCP connection time for each request. This should be
        // optional:
        // http://tools.ietf.org/html/draft-ietf-hybi-websocket-multiplexing-01
        <span class="cov0" title="0">connBackend, resp, err := dialer.Dial(backendURL.String(), requestHeader)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("websocketproxy: couldn't dial to remote backend url %s", err)
                if resp != nil </span><span class="cov0" title="0">{
                        // If the WebSocket handshake fails, ErrBadHandshake is returned
                        // along with a non-nil *http.Response so that callers can handle
                        // redirects, authentication, etcetera.
                        if err := copyResponse(rw, resp); err != nil </span><span class="cov0" title="0">{
                                log.Printf("websocketproxy: couldn't write response after failed remote backend handshake: %s", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        http.Error(rw, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">defer connBackend.Close()

        upgrader := w.Upgrader
        if w.Upgrader == nil </span><span class="cov0" title="0">{
                upgrader = DefaultUpgrader
        }</span>

        // Only pass those headers to the upgrader.
        <span class="cov0" title="0">upgradeHeader := http.Header{}
        if hdr := resp.Header.Get("Sec-Websocket-Protocol"); hdr != "" </span><span class="cov0" title="0">{
                upgradeHeader.Set("Sec-Websocket-Protocol", hdr)
        }</span>
        <span class="cov0" title="0">if hdr := resp.Header.Get("Set-Cookie"); hdr != "" </span><span class="cov0" title="0">{
                upgradeHeader.Set("Set-Cookie", hdr)
        }</span>

        // Now upgrade the existing incoming request to a WebSocket connection.
        // Also pass the header that we gathered from the Dial handshake.
        <span class="cov0" title="0">connPub, err := upgrader.Upgrade(rw, req, upgradeHeader)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("websocketproxy: couldn't upgrade %s", err)
                return
        }</span>
        <span class="cov0" title="0">defer connPub.Close()

        errClient := make(chan error, 1)
        errBackend := make(chan error, 1)
        replicateWebsocketConn := func(dst, src *websocket.Conn, errc chan error) </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        msgType, msg, err := src.ReadMessage()
                        if err != nil </span><span class="cov0" title="0">{
                                m := websocket.FormatCloseMessage(websocket.CloseNormalClosure, fmt.Sprintf("%v", err))
                                if e, ok := err.(*websocket.CloseError); ok </span><span class="cov0" title="0">{
                                        if e.Code != websocket.CloseNoStatusReceived </span><span class="cov0" title="0">{
                                                m = websocket.FormatCloseMessage(e.Code, e.Text)
                                        }</span>
                                }
                                <span class="cov0" title="0">errc &lt;- err
                                dst.WriteMessage(websocket.CloseMessage, m)
                                break</span>
                        }
                        <span class="cov0" title="0">err = dst.WriteMessage(msgType, msg)
                        if err != nil </span><span class="cov0" title="0">{
                                errc &lt;- err
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">go replicateWebsocketConn(connPub, connBackend, errClient)
        go replicateWebsocketConn(connBackend, connPub, errBackend)

        var message string
        select </span>{
        case err = &lt;-errClient:<span class="cov0" title="0">
                message = "websocketproxy: Error when copying from backend to client: %v"</span>
        case err = &lt;-errBackend:<span class="cov0" title="0">
                message = "websocketproxy: Error when copying from client to backend: %v"</span>

        }
        <span class="cov0" title="0">if e, ok := err.(*websocket.CloseError); !ok || e.Code == websocket.CloseAbnormalClosure </span><span class="cov0" title="0">{
                log.Printf(message, err)
        }</span>
}

func copyHeader(dst, src http.Header) <span class="cov0" title="0">{
        for k, vv := range src </span><span class="cov0" title="0">{
                for _, v := range vv </span><span class="cov0" title="0">{
                        dst.Add(k, v)
                }</span>
        }
}

func copyResponse(rw http.ResponseWriter, resp *http.Response) error <span class="cov0" title="0">{
        copyHeader(rw.Header(), resp.Header)
        rw.WriteHeader(resp.StatusCode)
        defer resp.Body.Close()

        _, err := io.Copy(rw, resp.Body)
        return err
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package rabbitmq

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "scaffold/server/config"

        logger "github.com/jfcarter2358/go-logger"
        "github.com/streadway/amqp"
)

var killPublishConn *amqp.Connection
var killPublishChannel *amqp.Channel
var killPublishQueue amqp.Queue
var managerPublishConn *amqp.Connection
var managerPublishChannel *amqp.Channel
var managerPublishQueue amqp.Queue
var workerPublishConn *amqp.Connection
var workerPublishChannel *amqp.Channel
var workerPublishQueue amqp.Queue

func handleError(err error, message string) <span class="cov10" title="16">{
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("", "Unexpected error: %s, %s", err.Error(), message)
        }</span>
}

func RunManagerProducer() <span class="cov1" title="1">{
        var err error
        managerPublishConn, err = amqp.Dial(config.Config.RabbitMQConnectionString)
        handleError(err, "Can't connect to AMQP")

        managerPublishChannel, err = managerPublishConn.Channel()
        handleError(err, "Can't create a amqpChannel")

        managerPublishQueue, err = managerPublishChannel.QueueDeclare(config.Config.WorkerQueueName, true, false, false, false, nil)
        handleError(err, fmt.Sprintf("Could not declare %s queue", config.Config.WorkerQueueName))
}</span>

func ManagerPublish(data interface{}) error <span class="cov0" title="0">{
        body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Unable to marshal manager publish json: %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">err = managerPublishChannel.Publish("", managerPublishQueue.Name, false, false, amqp.Publishing{
                DeliveryMode: amqp.Persistent,
                ContentType:  "text/plain",
                Body:         body,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error publishing message: %s", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func RunWorkerProducer() <span class="cov1" title="1">{
        var err error
        workerPublishConn, err = amqp.Dial(config.Config.RabbitMQConnectionString)
        handleError(err, "Can't connect to AMQP")

        workerPublishChannel, err = workerPublishConn.Channel()
        handleError(err, "Can't create a amqpChannel")

        workerPublishQueue, err = workerPublishChannel.QueueDeclare(config.Config.ManagerQueueName, true, false, false, false, nil)
        handleError(err, fmt.Sprintf("Could not declare %s queue", config.Config.ManagerQueueName))
}</span>

func WorkerPublish(data interface{}) error <span class="cov0" title="0">{
        body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Unable to marshal worker publish json: %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">err = workerPublishChannel.Publish("", workerPublishQueue.Name, false, false, amqp.Publishing{
                DeliveryMode: amqp.Persistent,
                ContentType:  "text/plain",
                Body:         body,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error publishing message: %s", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func RunKillProducer() <span class="cov0" title="0">{
        var err error
        killPublishConn, err = amqp.Dial(config.Config.RabbitMQConnectionString)
        handleError(err, "Can't connect to AMQP")

        killPublishChannel, err = killPublishConn.Channel()
        handleError(err, "Can't create a amqpChannel")

        killPublishQueue, err = killPublishChannel.QueueDeclare(config.Config.ManagerQueueName, true, false, false, false, nil)
        handleError(err, fmt.Sprintf("Could not declare %s queue", config.Config.ManagerQueueName))
}</span>

func KillPublish(data interface{}) error <span class="cov0" title="0">{
        body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Unable to marshal kill publish json: %s", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">err = killPublishChannel.ExchangeDeclare(
                config.Config.KillQueueName, // name
                "fanout",                    // type
                true,                        // durable
                false,                       // auto-deleted
                false,                       // internal
                false,                       // no-wait
                nil,                         // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = killPublishChannel.Publish(config.Config.KillQueueName, "", false, false, amqp.Publishing{
                DeliveryMode: amqp.Persistent,
                ContentType:  "text/plain",
                Body:         body,
        })

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error publishing message: %s", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func RunConsumer(receiveFunc func([]byte) error, queueName string) <span class="cov3" title="2">{
        conn, err := amqp.Dial(config.Config.RabbitMQConnectionString)
        handleError(err, "Can't connect to AMQP")
        defer conn.Close()

        amqpChannel, err := conn.Channel()
        handleError(err, "Can't create a amqpChannel")

        defer amqpChannel.Close()

        queue, err := amqpChannel.QueueDeclare(queueName, true, false, false, false, nil)
        handleError(err, fmt.Sprintf("Could not declare worker queue %s", queueName))

        err = amqpChannel.Qos(1, 0, false)
        handleError(err, "Could not configure QoS")

        messageChannel, err := amqpChannel.Consume(
                queue.Name,
                "",
                false,
                false,
                false,
                false,
                nil,
        )
        handleError(err, "Could not register consumer")

        stopChan := make(chan bool)

        go func() </span><span class="cov3" title="2">{
                logger.Infof("", "Consumer ready, PID: %d", os.Getpid())
                for d := range messageChannel </span><span class="cov0" title="0">{
                        logger.Tracef("", "Received a message: %s", d.Body)

                        if err := receiveFunc(d.Body); err != nil </span><span class="cov0" title="0">{
                                if err := d.Reject(true); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error processing message : %s", err)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Printf("Nack-ed message")
                                }</span>
                        }

                        <span class="cov0" title="0">if err := d.Ack(false); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error acknowledging message : %s", err)
                        }</span> else<span class="cov0" title="0"> {
                                log.Printf("Acknowledged message")
                        }</span>

                }
        }()

        // Stop for program termination
        <span class="cov3" title="2">&lt;-stopChan</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// routes.go

package main

import (
        "scaffold/server/api"
        "scaffold/server/auth"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/docs"
        "scaffold/server/middleware"
        "scaffold/server/page"
        "scaffold/server/page/common"

        "github.com/gin-gonic/gin"
        swaggerfiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func initializeRoutes() <span class="cov10" title="2">{
        router.Static("/static/css", "./static/css")
        router.Static("/static/img", "./static/img")
        router.Static("/static/js", "./static/js")

        // Swagger docs
        docs.SwaggerInfo.BasePath = "/api/v1"
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))

        router.GET("/", page.RedirectIndexPage)

        router.NoRoute(func(c *gin.Context) </span><span class="cov0" title="0">{
                common.Code404Endpoint(c)
        }</span>)

        <span class="cov10" title="2">healthRoutes := router.Group("/health", middleware.CORSMiddleware())
        </span><span class="cov10" title="2">{
                healthRoutes.GET("/healthy", api.Healthy)
                healthRoutes.GET("/ready", api.Ready)
                if config.Config.Node.Type == constants.NODE_TYPE_WORKER </span><span class="cov1" title="1">{
                        healthRoutes.GET("/available", api.Available)
                }</span> else<span class="cov1" title="1"> {
                        healthRoutes.POST("/ping/:name", middleware.EnsureLoggedIn(), api.Ping)
                }</span>
        }

        <span class="cov10" title="2">if config.Config.Node.Type == constants.NODE_TYPE_MANAGER </span><span class="cov1" title="1">{
                authRoutes := router.Group("/auth", middleware.CORSMiddleware())
                </span><span class="cov1" title="1">{
                        authRoutes.POST("/login", middleware.EnsureNotLoggedIn(), auth.PerformLogin)
                        authRoutes.GET("/logout", middleware.EnsureLoggedIn(), auth.PerformLogout)
                        authRoutes.POST("/reset/request", middleware.EnsureNotLoggedIn(), auth.RequestPasswordReset)
                        authRoutes.POST("/reset/do", middleware.EnsureNotLoggedIn(), auth.DoPasswordReset)
                        authRoutes.POST("/join", auth.JoinNode)
                        authRoutes.POST("/token/:username/:name", middleware.EnsureLoggedIn(), middleware.EnsureSelf(), api.GenerateAPIToken)
                        authRoutes.DELETE("/token/:username/:name", middleware.EnsureLoggedIn(), middleware.EnsureSelf(), api.RevokeAPIToken)
                }</span>

                <span class="cov1" title="1">apiRoutes := router.Group("/api", middleware.CORSMiddleware())
                </span><span class="cov1" title="1">{
                        v1Routes := apiRoutes.Group("/v1")
                        </span><span class="cov1" title="1">{
                                workflowRoutes := v1Routes.Group("/workflow")
                                </span><span class="cov1" title="1">{
                                        workflowRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllWorkflows)
                                        workflowRoutes.GET("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("name"), api.GetWorkflowByName)
                                        workflowRoutes.DELETE("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("name"), api.DeleteWorkflowByName)
                                        workflowRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateWorkflow)
                                        workflowRoutes.PUT("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("name"), api.UpdateWorkflowByName)
                                }</span>
                                <span class="cov1" title="1">datastoreRoutes := v1Routes.Group("/datastore")
                                </span><span class="cov1" title="1">{
                                        datastoreRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllDataStores)
                                        datastoreRoutes.GET("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("name"), api.GetDataStoreByName)
                                        datastoreRoutes.DELETE("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("name"), api.DeleteDataStoreByWorkflow)
                                        datastoreRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateDataStore)
                                        datastoreRoutes.PUT("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("name"), api.UpdateDataStoreByWorkflow)
                                }</span>
                                <span class="cov1" title="1">fileRoutes := v1Routes.Group("/file")
                                </span><span class="cov1" title="1">{
                                        fileRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllFiles)
                                        fileRoutes.GET("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("name"), api.GetFilesByWorkflow)
                                        fileRoutes.GET("/:name/:file", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("name"), api.GetFileByNames)
                                        fileRoutes.GET("/:name/:file/download", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("name"), api.DownloadFile)
                                        fileRoutes.POST("/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("name"), api.UploadFile)
                                }</span>
                                <span class="cov1" title="1">stateRoutes := v1Routes.Group("/state")
                                </span><span class="cov1" title="1">{
                                        stateRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllStates)
                                        stateRoutes.GET("/:workflow", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("workflow"), api.GetStatesByWorkflow)
                                        stateRoutes.GET("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("workflow"), api.GetStateByNames)
                                        stateRoutes.DELETE("/:workflow", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.DeleteStatesByWorkflow)
                                        stateRoutes.DELETE("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.DeleteStateByNames)
                                        stateRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateState)
                                        stateRoutes.PUT("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.UpdateStateByNames)
                                }</span>
                                <span class="cov1" title="1">inputRoutes := v1Routes.Group("/input")
                                </span><span class="cov1" title="1">{
                                        inputRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllInputs)
                                        inputRoutes.GET("/:workflow", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("workflow"), api.GetInputsByWorkflow)
                                        inputRoutes.GET("/:workflow/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("workflow"), api.GetInputByNames)
                                        inputRoutes.DELETE("/:workflow", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.DeleteInputsByWorkflow)
                                        inputRoutes.DELETE("/:workflow/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.DeleteInputByNames)
                                        inputRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateInput)
                                        inputRoutes.POST("/:workflow/update", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.UpdateInputDependenciesByName)
                                        inputRoutes.PUT("/:workflow/:name", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.UpdateInputByNames)
                                }</span>
                                <span class="cov1" title="1">taskRoutes := v1Routes.Group("/task")
                                </span><span class="cov1" title="1">{
                                        taskRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllTasks)
                                        taskRoutes.GET("/:workflow", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("workflow"), api.GetTasksByWorkflow)
                                        taskRoutes.GET("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), middleware.EnsureWorkflowGroup("workflow"), api.GetTaskByNames)
                                        taskRoutes.DELETE("/:workflow", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.DeleteTasksByWorkflow)
                                        taskRoutes.DELETE("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.DeleteTaskByNames)
                                        taskRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.CreateTask)
                                        taskRoutes.PUT("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.UpdateTaskByNames)
                                        taskRoutes.PUT("/:workflow/:task/enabled", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.ToggleTaskEnabled)
                                }</span>
                                <span class="cov1" title="1">userRoutes := v1Routes.Group("/user")
                                </span><span class="cov1" title="1">{
                                        userRoutes.GET("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetAllUsers)
                                        userRoutes.GET("/:username", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetUserByUsername)
                                        userRoutes.DELETE("/:username", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.DeleteUserByUsername)
                                        userRoutes.POST("", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin"}), api.CreateUser)
                                        userRoutes.PUT("/:username", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), api.UpdateUserByUsername)
                                }</span>
                                <span class="cov1" title="1">runRoutes := v1Routes.Group("/run")
                                </span><span class="cov1" title="1">{
                                        runRoutes.POST("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.CreateRun)
                                        runRoutes.DELETE("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureWorkflowGroup("workflow"), api.ManagerKillRun)
                                        runRoutes.GET("/:runID", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetRunStatus)
                                }</span>
                                <span class="cov1" title="1">historyRoutes := v1Routes.Group("/history")
                                </span><span class="cov1" title="1">{
                                        historyRoutes.GET("/:runID", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write", "read"}), api.GetHistory)
                                }</span>
                                <span class="cov1" title="1">webhookRoutes := v1Routes.Group("/webhook")
                                </span><span class="cov1" title="1">{
                                        webhookRoutes.POST("/:workflow/:task", middleware.EnsureLoggedIn(), middleware.EnsureRolesAllowed([]string{"admin", "write"}), middleware.EnsureWorkflowGroup("workflow"), api.TriggerWebhookByID)
                                }</span>
                        }
                }

                <span class="cov1" title="1">uiRoutes := router.Group("/ui", middleware.CORSMiddleware())
                </span><span class="cov1" title="1">{
                        uiRoutes.GET("/login", middleware.EnsureNotLoggedIn(), page.LoginPageEndpoint)
                        uiRoutes.GET("/forgot_password", middleware.EnsureNotLoggedIn(), page.ShowForgotPasswordPage)
                        uiRoutes.GET("/email_success", middleware.EnsureNotLoggedIn(), page.ShowEmailSuccessPage)
                        uiRoutes.GET("/email_failure", middleware.EnsureNotLoggedIn(), page.ShowEmailFailurePage)
                        uiRoutes.GET("/reset_password/:reset_password", middleware.EnsureNotLoggedIn(), page.ShowResetPasswordPage)

                        uiRoutes.GET("/dashboard", middleware.EnsureLoggedIn(), page.DashboardPageEndpoint)

                        uiRoutes.GET("/workflows", middleware.EnsureLoggedIn(), page.WorkflowsPageEndpoint)
                        uiRoutes.GET("/workflows/:name", middleware.EnsureLoggedIn(), page.WorkflowPageEndpoint)

                        uiRoutes.GET("/runs", middleware.EnsureLoggedIn(), page.HistoriesPageEndpoint)
                        uiRoutes.GET("/runs/:run_id", middleware.EnsureLoggedIn(), page.HistoryPageEndpoint)

                        uiRoutes.GET("/users", middleware.EnsureLoggedIn(), page.UsersPageEndpoint)
                        uiRoutes.GET("/users/:username", middleware.EnsureLoggedIn(), page.UserPageEndpoint)

                        uiRoutes.GET("/401", common.Code401Endpoint)
                        uiRoutes.GET("/403", common.Code403Endpoint)
                        uiRoutes.GET("/404", common.Code404Endpoint)
                        uiRoutes.GET("/500", common.Code500Endpoint)
                }</span>

                <span class="cov1" title="1">htmxRoutes := router.Group("/htmx", middleware.CORSMiddleware(), middleware.EnsureLoggedInAPI())
                </span><span class="cov1" title="1">{
                        // commonRoutes := htmxRoutes.Group("/common")
                        // {
                        //         if err := common.Init(); err != nil {
                        //                 panic(err)
                        //         }
                        //         commonRoutes.GET("/status", common.StatusEndpoint)
                        //         commonRoutes.GET("/sidebar", common.SidebarEndpoint)
                        //         commonRoutes.GET("/error", common.ErrorEndpoint)
                        //         commonRoutes.GET("/success", common.ErrorEndpoint)
                        //         commonRoutes.GET("/header", common.HeaderEndpoint)
                        // }
                        workflowRoutes := htmxRoutes.Group("/workflow")
                        </span><span class="cov1" title="1">{
                                workflowRoutes.GET("/:name/display/:task", page.WorkflowDisplayEndpoint)
                                workflowRoutes.GET("/:name/output/:task", page.WorkflowOutputEndpoint)
                                workflowRoutes.GET("/:name/started/:task", page.WorkflowStartedEndpoint)
                                workflowRoutes.GET("/:name/finished/:task", page.WorkflowFinishedEndpoint)
                                workflowRoutes.GET("/:name/status/:task", page.WorkflowStatusEndpoint)
                                workflowRoutes.GET("/:name/modal/:task", page.WorkflowModalEndpoint)
                        }</span>
                        <span class="cov1" title="1">workflowsRoutes := htmxRoutes.Group("/workflows")
                        </span><span class="cov1" title="1">{
                                workflowsRoutes.GET("/table", page.WorkflowsTableEndpoint)
                                workflowsRoutes.GET("/search", page.WorkflowsSearchEndpoint)
                        }</span>
                        <span class="cov1" title="1">dashboardRoutes := htmxRoutes.Group("/dashboard")
                        </span><span class="cov1" title="1">{
                                dashboardRoutes.GET("/table", page.DashboardTableEndpoint)
                                dashboardRoutes.GET("/search", page.DashboardSearchEndpoint)
                        }</span>
                        <span class="cov1" title="1">runsRoutes := htmxRoutes.Group("/runs")
                        </span><span class="cov1" title="1">{
                                runsRoutes.GET("/table", page.HistoriesTableEndpoint)
                                runsRoutes.GET("/search", page.HistoriesSearchEndpoint)
                                runsRoutes.GET("/timeline/:run_id", page.HistoryTimelineEndpoint)
                                runsRoutes.GET("/timeline/:run_id/status/:state_name", page.HistoryStateEndpoint)
                        }</span>
                        <span class="cov1" title="1">usersRoutes := htmxRoutes.Group("/users")
                        </span><span class="cov1" title="1">{
                                usersRoutes.GET("/table", page.UsersTableEndpoint)
                                usersRoutes.GET("/search", page.UsersSearchEndpoint)
                        }</span>
                }

        }
        <span class="cov10" title="2">if config.Config.Node.Type == constants.NODE_TYPE_WORKER </span><span class="cov1" title="1">{
                apiRoutes := router.Group("/api", middleware.CORSMiddleware())
                </span><span class="cov1" title="1">{
                        v1Routes := apiRoutes.Group("/v1")
                        </span><span class="cov1" title="1">{
                                taskRoutes := v1Routes.Group("/run")
                                </span><span class="cov1" title="1">{
                                        taskRoutes.DELETE("/:workflow/:task", middleware.EnsureLoggedIn(), api.KillRun)
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package run

import (
        "bytes"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "os/exec"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/datastore"
        "scaffold/server/filestore"
        "scaffold/server/msg"
        "scaffold/server/rabbitmq"
        "scaffold/server/state"
        "scaffold/server/task"
        "scaffold/server/utils"
        "strings"
        "time"

        logger "github.com/jfcarter2358/go-logger"
)

var runError error
var killed = false

type Run struct {
        Name    string            `json:"name" yaml:"name"`
        Task    task.Task         `json:"task" yaml:"task"`
        State   state.State       `json:"state" yaml:"state"`
        Number  int               `json:"number" yaml:"number"`
        Groups  []string          `json:"groups" yaml:"groups"`
        Worker  string            `json:"worker" yaml:"worker"`
        PID     int               `json:"pid" yaml:"pid"`
        Context map[string]string `json:"context" yaml:"context"`
        RunID   string            `json:"run_id" yaml:"run_id"`
}

type RunContext struct {
        Run         *Run
        DataStore   *datastore.DataStore
        RunDir      string
        ScriptPath  string
        EnvInPath   string
        EnvOutPath  string
        DisplayPath string
}

func setErrorStatus(r *Run, output string) <span class="cov0" title="0">{
        r.PID = 0
        r.State.PID = 0
        r.State.Output = output
        r.State.Status = constants.STATE_STATUS_ERROR
        currentTime := time.Now().UTC()
        r.State.Finished = currentTime.Format("2006-01-02T15:04:05Z")
}</span>

func runCmd(cmd *exec.Cmd) <span class="cov0" title="0">{
        runError = cmd.Run()
}</span>

func updateRunState(r *Run, send bool) error <span class="cov0" title="0">{
        r.State.PID = r.PID
        m := msg.RunMsg{
                Task:     r.Task.Name,
                Workflow: r.Task.Workflow,
                Status:   r.State.Status,
                Context:  r.Context,
                State:    r.State,
                RunID:    r.RunID,
        }
        logger.Debugf("", "Updating run state for %v", m)
        if err := state.UpdateStateRunByNames(r.State.Workflow, r.State.Task, r.State); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot update state run: %s %s %v %s", r.Task.Workflow, r.Task.Name, r.State, err.Error())
                return err
        }</span>
        <span class="cov0" title="0">if send </span><span class="cov0" title="0">{
                return rabbitmq.WorkerPublish(m)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func nukeDir(path string) <span class="cov0" title="0">{
        logger.Debugf("", "Removing directory %s", path)
        if _, err := os.Stat(path); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span>{<span class="cov0" title="0">
                        // file does not exist
                }</span> else<span class="cov0" title="0"> {
                        os.RemoveAll(path)
                }</span>
        }
}

func setupRun(rc *RunContext) (bool, error) <span class="cov0" title="0">{
        rc.Run.State.Status = constants.STATE_STATUS_RUNNING
        currentTime := time.Now().UTC()
        rc.Run.State.Started = currentTime.Format("2006-01-02T15:04:05Z")
        if err := state.UpdateStateKilledByNames(rc.Run.Task.Workflow, rc.Run.Task.Name, false); err != nil </span><span class="cov0" title="0">{
                logger.Infof("", "Cannot update state killed: %s %s %s", rc.Run.Task.Workflow, rc.Run.Task.Name, err.Error())
                return false, err
        }</span>
        <span class="cov0" title="0">if err := updateRunState(rc.Run, false); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">rc.RunDir = fmt.Sprintf("/tmp/run/%s/%s/%d", rc.Run.State.Workflow, rc.Run.State.Task, rc.Run.Number)
        rc.ScriptPath = rc.RunDir + "/.run.sh"
        rc.EnvInPath = rc.RunDir + "/.envin"
        rc.EnvOutPath = rc.RunDir + ".envout"
        rc.DisplayPath = rc.RunDir + "/.display"

        // Setup run directory
        nukeDir(rc.RunDir)
        err := os.MkdirAll(rc.RunDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error creating run directory %s", err.Error())
                setErrorStatus(rc.Run, err.Error())
                if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        // Setup datastore
        <span class="cov0" title="0">rc.DataStore, err = datastore.GetDataStoreByWorkflow(rc.Run.State.Workflow)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot get datastore %s", rc.Run.State.Workflow)
                setErrorStatus(rc.Run, err.Error())
                if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

func setupEnvLoad(rc *RunContext) (bool, error) <span class="cov0" title="0">{
        envInput := ""
        for key, val := range rc.Run.Task.Inputs </span><span class="cov0" title="0">{
                dsVal, ok := rc.DataStore.Env[val]
                var encoded string
                if ok </span><span class="cov0" title="0">{
                        encoded = base64.StdEncoding.EncodeToString([]byte(dsVal))
                        envInput += fmt.Sprintf("%s;%s\n", key, encoded)
                        continue</span>
                }
                <span class="cov0" title="0">logger.Warnf("", "Input value missing for %s", val)</span>
        }
        <span class="cov0" title="0">for key, val := range rc.Run.Context </span><span class="cov0" title="0">{
                encoded := base64.StdEncoding.EncodeToString([]byte(val))
                envInput += fmt.Sprintf("%s;%s\n", key, encoded)
                continue</span>
        }
        <span class="cov0" title="0">for key, val := range rc.Run.Task.Env </span><span class="cov0" title="0">{
                encoded := base64.StdEncoding.EncodeToString([]byte(val))
                envInput += fmt.Sprintf("%s;%s\n", key, encoded)
        }</span>

        // Write out envin script
        <span class="cov0" title="0">data := []byte(envInput)
        err := os.WriteFile(rc.EnvInPath, data, 0777)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error writing envin file %s", err.Error())
                setErrorStatus(rc.Run, err.Error())
                if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

func setupRunScript(rc *RunContext) (bool, error) <span class="cov0" title="0">{
        envOutput := ""
        for _, key := range rc.Run.Task.Store.Env </span><span class="cov0" title="0">{
                envOutput += fmt.Sprintf("echo \"%s;$(echo \"${%s}\" | base64)\" &gt;&gt; %s\n", key, key, rc.EnvOutPath)
        }</span>

        <span class="cov0" title="0">runScript := fmt.Sprintf(`
        # load ENV var

        while read -r line; do
                name=${line%%;*}
                value=${line#*;}
                export ${name}="$(echo "${value}" | base64 -d)"
        done &lt; %s
        
        # run command
        %s
        
        # save ENV vars
        %s
        `, rc.EnvInPath, rc.Run.Task.Run, envOutput)

        // Write out our run script
        data := []byte(runScript)
        err := os.WriteFile(rc.ScriptPath, data, 0777)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error writing run file %s", err.Error())
                setErrorStatus(rc.Run, err.Error())
                if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

func loadFiles(rc *RunContext) (bool, error) <span class="cov0" title="0">{
        for _, name := range rc.Run.Task.Load.File </span><span class="cov0" title="0">{
                err := filestore.GetFile(fmt.Sprintf("%s/%s", rc.Run.State.Workflow, name), fmt.Sprintf("%s/%s", rc.RunDir, name))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error getting file %s", err.Error())
                        setErrorStatus(rc.Run, err.Error())
                        if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov0" title="0">return false, err</span>
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}

func checkDisplay(rc *RunContext) (bool, error) <span class="cov0" title="0">{
        logger.Tracef("", "Checking for display at %s", rc.DisplayPath)
        if _, err := os.Stat(rc.DisplayPath); err == nil </span><span class="cov0" title="0">{
                logger.Tracef("", "Display path is present")
                if data, err := os.ReadFile(rc.DisplayPath); err == nil </span><span class="cov0" title="0">{
                        logger.Tracef("", "Read display file")
                        var obj []map[string]interface{}
                        if err := json.Unmarshal(data, &amp;obj); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error unmarshalling display JSON: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Tracef("", "Updating display object")
                                rc.Run.State.Display = obj
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Tracef("", "Display read error: %s", err.Error())
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Tracef("", "Display stat error: %s", err.Error())
        }</span>
        <span class="cov0" title="0">if err := updateRunState(rc.Run, false); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error updating run: %s", err.Error())
                nukeDir(rc.RunDir)
                return false, err
        }</span>
        <span class="cov0" title="0">return false, nil</span>
}

func storeFiles(rc *RunContext) <span class="cov0" title="0">{
        for _, name := range rc.Run.Task.Store.File </span><span class="cov0" title="0">{
                filePath := fmt.Sprintf("%s/%s", rc.RunDir, name)
                if _, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                        err := filestore.UploadFile(filePath, fmt.Sprintf("%s/%s", rc.Run.Task.Workflow, name))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error uploading file %s: %s\n", fmt.Sprintf("%s/%s", rc.Run.Task.Workflow, name), err.Error())
                        }</span>
                        <span class="cov0" title="0">rc.DataStore.Files = append(rc.DataStore.Files, name)
                        rc.DataStore.Files = utils.RemoveDuplicateValues(rc.DataStore.Files)</span>
                }
        }
}

func storeEnv(rc *RunContext) (bool, error) <span class="cov0" title="0">{
        logger.Tracef("", "Storing ENV values to context")
        var dat []byte
        if _, err := os.Stat(rc.EnvOutPath); err == nil </span><span class="cov0" title="0">{
                dat, err = os.ReadFile(rc.EnvOutPath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error reading file %s\n", err.Error())
                        setErrorStatus(rc.Run, err.Error())
                        if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                                nukeDir(rc.RunDir)
                                return false, err
                        }</span>
                }
        }
        <span class="cov0" title="0">envVarList := strings.Split(string(dat), "\n")
        logger.Tracef("", "Got env var list: %v", envVarList)
        envVarMap := map[string]string{}

        for _, val := range envVarList </span><span class="cov0" title="0">{
                name, val, _ := strings.Cut(val, ";")
                decoded, _ := base64.StdEncoding.DecodeString(val)
                envVarMap[name] = string(decoded)
                logger.Tracef("", "Got ENV var %s: %s", name, string(decoded))
        }</span>

        <span class="cov0" title="0">for _, name := range rc.Run.Task.Store.Env </span><span class="cov0" title="0">{
                logger.Tracef("", "Storing %s to context", name)
                if rc.Run.Context == nil </span><span class="cov0" title="0">{
                        rc.Run.Context = make(map[string]string)
                }</span>
                <span class="cov0" title="0">rc.Run.Context[name] = envVarMap[name]</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

func setStatus(rc *RunContext, returnCodeString string, returnCodeInt int) <span class="cov0" title="0">{
        currentTime := time.Now().UTC()
        rc.Run.State.Finished = currentTime.Format("2006-01-02T15:04:05Z")
        if returnCodeString == "" </span><span class="cov0" title="0">{
                if returnCodeInt == 0 </span><span class="cov0" title="0">{
                        rc.Run.State.Status = constants.STATE_STATUS_SUCCESS
                }</span> else<span class="cov0" title="0"> {
                        rc.Run.State.Status = constants.STATE_STATUS_ERROR
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if returnCodeString == "0" </span><span class="cov0" title="0">{
                rc.Run.State.Status = constants.STATE_STATUS_SUCCESS
        }</span> else<span class="cov0" title="0"> {
                rc.Run.State.Status = constants.STATE_STATUS_ERROR
        }</span>
}

func StartContainerRun(rr *Run) (bool, error) <span class="cov0" title="0">{
        rc := &amp;RunContext{
                Run: rr,
        }

        if shouldRestart, err := setupRun(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">if shouldRestart, err := setupEnvLoad(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">if shouldRestart, err := setupRunScript(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">if shouldRestart, err := loadFiles(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">containerName := fmt.Sprintf("%s-%s-%d", rc.Run.State.Workflow, rc.Run.State.Task, rc.Run.Number)

        // Clean up any possible artifacts
        if err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman kill %s", containerName)).Run(); err != nil </span><span class="cov0" title="0">{
                logger.Infof("", "No running container with name %s exists, skipping kill\n", containerName)
        }</span>
        <span class="cov0" title="0">if err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman rm %s", containerName)).Run(); err != nil </span><span class="cov0" title="0">{
                logger.Infof("", "No running container with name %s exists, skipping removal\n", containerName)
        }</span>

        <span class="cov0" title="0">if rc.Run.Task.ContainerLoginCommand != "" </span><span class="cov0" title="0">{
                logger.Debugf("", "Logging into registry with command %s", rc.Run.Task.ContainerLoginCommand)
                if err := exec.Command("/bin/sh", "-c", rc.Run.Task.ContainerLoginCommand).Run(); err != nil </span><span class="cov0" title="0">{
                        logger.Infof("", "Cannot login to container registry: %s\n", err.Error())
                }</span>
        }

        <span class="cov0" title="0">podmanCommand := fmt.Sprintf("podman run --rm --privileged -d %s --device /dev/net/tun:/dev/net/tun ", config.Config.PodmanOpts)
        podmanCommand += fmt.Sprintf("--name %s ", containerName)
        podmanCommand += fmt.Sprintf("--mount type=bind,src=%s,dst=/tmp/run ", rc.RunDir)
        for _, m := range rc.Run.Task.Load.Mounts </span><span class="cov0" title="0">{
                podmanCommand += fmt.Sprintf("--mount type=bind,src=%s,dst=%s ", m, m)
        }</span>
        <span class="cov0" title="0">for _, e := range rc.Run.Task.Load.EnvPassthrough </span><span class="cov0" title="0">{
                podmanCommand += fmt.Sprintf("--env %s=\"${%s}\" ", e, e)
        }</span>
        <span class="cov0" title="0">podmanCommand += rc.Run.Task.Image
        podmanCommand += " bash -c /tmp/run/.run.sh"

        logger.Debugf("", "command: %s", podmanCommand)

        cmd := exec.Command("/bin/sh", "-c", podmanCommand)
        var outb, errb bytes.Buffer
        cmd.Stdout = &amp;outb
        cmd.Stderr = &amp;errb
        go runCmd(cmd)

        output, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman ps -a --filter \"name=%s\" --format \"{{.Status}}\"", containerName)).CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Encountered error: %v\n", err.Error())
                logger.Debugf("", "STDOUT: %s\n", string(output))

                shouldRestart := false
                if strings.Contains(string(output), "no space left on device") </span><span class="cov0" title="0">{
                        shouldRestart = true
                        logs, err := exec.Command("/bin/sh", "-c", "podman system prune -a -f").CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Prune error string: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">logger.Debugf("", "Prune output: %s", logs)</span>
                }
                <span class="cov0" title="0">setErrorStatus(rc.Run, string(output))
                if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                        nukeDir(rc.RunDir)
                        return false, err
                }</span>
                <span class="cov0" title="0">nukeDir(rc.RunDir)
                return shouldRestart, err</span>
        }

        <span class="cov0" title="0">var podmanOutput string
        erroredOut := false
        for !strings.HasPrefix(string(output), "Exited") </span><span class="cov0" title="0">{
                logger.Debugf("", "Checking for exit status: %s", string(output))
                if string(output) == "" </span><span class="cov0" title="0">{
                        podmanOutput = outb.String() + "\n\n" + errb.String()
                        rc.Run.State.Output = podmanOutput
                        if runError != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Error running pod %s\n", runError.Error())
                                setErrorStatus(rc.Run, fmt.Sprintf("%s :: %s", podmanOutput, string(runError.Error())))
                                if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                                        nukeDir(rc.RunDir)
                                        return false, err
                                }</span>
                                <span class="cov0" title="0">erroredOut = true
                                break</span>
                        }
                        // Load in display file if present and able
                        <span class="cov0" title="0">if shouldRestart, err := checkDisplay(rc); err != nil </span><span class="cov0" title="0">{
                                return shouldRestart, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logs, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman logs %s", containerName)).CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                rc.Run.State.Output = fmt.Sprintf("%s\n\n--------------------------------\n\n%s--------------------------------\n\n%s", podmanOutput, logs, string(err.Error()))
                        }</span> else<span class="cov0" title="0"> {
                                rc.Run.State.Output = fmt.Sprintf("%s\n\n--------------------------------\n\n%s", podmanOutput, string(logs))
                        }</span>
                        // Load in display file if present and able
                        <span class="cov0" title="0">if shouldRestart, err := checkDisplay(rc); err != nil </span><span class="cov0" title="0">{
                                return shouldRestart, err
                        }</span>
                }
                <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)
                output, _ = exec.Command("/bin/sh", "-c", fmt.Sprintf("podman ps -a --filter \"name=%s\" --format \"{{.Status}}\"", containerName)).CombinedOutput()</span>
        }

        <span class="cov0" title="0">if !erroredOut </span><span class="cov0" title="0">{
                openParenIdx := strings.Index(string(output), "(")
                closeParenIdx := strings.Index(string(output), ")")
                returnCode := string(output)[openParenIdx+1 : closeParenIdx]

                logs, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman logs %s", containerName)).CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        rc.Run.State.Output = fmt.Sprintf("%s\n\n--------------------------------\n\n%s", podmanOutput, string(err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        rc.Run.State.Output = fmt.Sprintf("%s\n\n--------------------------------\n\n%s", podmanOutput, string(logs))
                }</span>

                <span class="cov0" title="0">storeFiles(rc)

                if shouldRestart, err := checkDisplay(rc); err != nil </span><span class="cov0" title="0">{
                        return shouldRestart, err
                }</span>

                <span class="cov0" title="0">if shouldRestart, err := storeEnv(rc); err != nil </span><span class="cov0" title="0">{
                        return shouldRestart, err
                }</span>

                <span class="cov0" title="0">setStatus(rc, returnCode, 0)

                if rc.Run.Task.ShouldRM </span><span class="cov0" title="0">{
                        rmCommand := fmt.Sprintf("podman rm -f %s", containerName)
                        out, err := exec.Command("bash", "-c", rmCommand).CombinedOutput()
                        logger.Debugf("", "Podman rm: %s", string(out))
                        rc.Run.State.Output += fmt.Sprintf("\n\n--------------------------------\n\n%s", string(out))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("", err.Error())
                                rc.Run.State.Output += fmt.Sprintf("\n\n--------------------------------\n\n%s", err.Error())
                        }</span>
                }
        }

        <span class="cov0" title="0">nukeDir(rc.RunDir)
        if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return false, nil</span>
}

func ContainerKill(cn, tn string) error <span class="cov0" title="0">{
        prefix := fmt.Sprintf("%s.%s", cn, tn)
        logger.Debugf("", "Trying to kill %s", prefix)
        output, err := exec.Command("/bin/sh", "-c", "podman ps -a --format \"{{.Names}}\"").CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("", "Unable to list running containers: %s | %s", err, string(output))
                return err
        }</span>
        <span class="cov0" title="0">logger.Tracef("", "Container output: %s", string(output))
        lines := strings.Split(string(output), "\n")

        logger.Tracef("", "Checking prefix %s", prefix)
        for _, containerName := range lines </span><span class="cov0" title="0">{
                logger.Tracef("", "Checking container %s", containerName)
                if strings.HasPrefix(containerName, prefix) </span><span class="cov0" title="0">{
                        logger.Infof("", "Killing container %s", containerName)
                        if output, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("podman kill %s", containerName)).CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                                logger.Infof("", "Cannot kill container with name %s with output %s", containerName, output)
                                return err
                        }</span>
                        <span class="cov0" title="0">s, err := state.GetStateByNames(cn, tn)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Unable to get state for run %s.%s with error %s", cn, tn, err.Error())
                                return err
                        }</span>
                        <span class="cov0" title="0">s.Status = constants.STATE_STATUS_KILLED
                        if err := state.UpdateStateByNames(cn, tn, s); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Unable to update state %s.%s: %s", cn, tn, err.Error())
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func ExitCode(err error) int <span class="cov0" title="0">{
        var exitErr *exec.ExitError
        if errors.As(err, &amp;exitErr) </span><span class="cov0" title="0">{
                return exitErr.ExitCode()
        }</span>
        // No error
        <span class="cov0" title="0">return 0</span>
}

func StartLocalRun(rr *Run) (bool, error) <span class="cov0" title="0">{
        rc := &amp;RunContext{
                Run: rr,
        }

        if shouldRestart, err := setupRun(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">if shouldRestart, err := setupEnvLoad(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">if shouldRestart, err := setupRunScript(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">if shouldRestart, err := loadFiles(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">if rc.Run.PID &gt; 0 </span><span class="cov0" title="0">{
                if err := exec.Command("/bin/sh", "-c", fmt.Sprintf("kill %d", rc.Run.PID)).Run(); err != nil </span><span class="cov0" title="0">{
                        logger.Infof("", "Cannot kill existing run: %s\n", err.Error())
                }</span>
        }

        <span class="cov0" title="0">localCommand := fmt.Sprintf("cd %s &amp;&amp; ./.run.sh", rc.RunDir)

        logger.Debugf("", "command: %s", localCommand)

        cmd := exec.Command("/bin/bash", "-c", localCommand)
        var outb, errb bytes.Buffer
        cmd.Stdout = &amp;outb
        cmd.Stderr = &amp;errb

        runError = cmd.Start()
        rc.Run.PID = cmd.Process.Pid
        if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">killed = false

        go func() </span><span class="cov0" title="0">{
                runError = cmd.Wait()
                killed = true
        }</span>()

        <span class="cov0" title="0">for !killed </span><span class="cov0" title="0">{
                if runError != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error running pod %s\n", runError.Error())
                        setErrorStatus(rc.Run, fmt.Sprintf("Error running pod %s\n", runError.Error()))
                        if err := updateRunState(rc.Run, true); err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                }
                <span class="cov0" title="0">output := outb.String() + "\n\n" + errb.String()
                logger.Tracef("", "setting output 1 %s", output)
                rc.Run.State.Output = output

                // Load in display file if present and able
                if shouldRestart, err := checkDisplay(rc); err != nil </span><span class="cov0" title="0">{
                        return shouldRestart, err
                }</span>

                <span class="cov0" title="0">if shouldRestart, err := storeEnv(rc); err != nil </span><span class="cov0" title="0">{
                        return shouldRestart, err
                }</span>

                <span class="cov0" title="0">time.Sleep(500 * time.Millisecond)</span>
        }

        <span class="cov0" title="0">output := outb.String() + "\n\n" + errb.String()
        logger.Tracef("", "setting output 2 %s", output)
        rc.Run.State.Output = output

        if err := updateRunState(rc.Run, false); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error updating run: %s", err.Error())
                return false, err
        }</span>

        <span class="cov0" title="0">returnCode := 0
        returnCode = ExitCode(runError)

        storeFiles(rc)

        // Load in display file if present and able
        if shouldRestart, err := checkDisplay(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">if shouldRestart, err := storeEnv(rc); err != nil </span><span class="cov0" title="0">{
                return shouldRestart, err
        }</span>

        <span class="cov0" title="0">setStatus(rc, "", returnCode)

        rc.Run.PID = 0

        err := updateRunState(rc.Run, true)
        return false, err</span>
}

func LocalKill(cn, tn string) error <span class="cov0" title="0">{
        s, err := state.GetStateByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Infof("", "Killing run %s/%s with PID %d", cn, tn, s.PID)
        if s.PID &gt; 0 </span><span class="cov0" title="0">{
                if out, err := exec.Command("/bin/sh", "-c", fmt.Sprintf("sudo kill %d", s.PID)).CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Cannot kill existing run: %s\n", err.Error())
                        if out != nil </span><span class="cov0" title="0">{
                                logger.Tracef("", "Kill output: %s", string(out))
                        }</span>
                        <span class="cov0" title="0">s.Status = constants.STATE_STATUS_KILLED
                        if err := state.UpdateStateByNames(cn, tn, s); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("", "Unable to update state %s.%s: %s", cn, tn, err.Error())
                                return err
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">s.Status = constants.STATE_STATUS_KILLED
                if err := state.UpdateStateByNames(cn, tn, s); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Unable to update state %s.%s: %s", cn, tn, err.Error())
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package state

import (
        "fmt"
        "scaffold/server/constants"

        logger "github.com/jfcarter2358/go-logger"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"
)

type State struct {
        Task           string                   `json:"task" bson:"task" yaml:"task"`
        Workflow       string                   `json:"workflow" bson:"workflow" yaml:"workflow"`
        Status         string                   `json:"status" bson:"status" yaml:"status"`
        Started        string                   `json:"started" bson:"started" yaml:"started"`
        Finished       string                   `json:"finished" bson:"finished" yaml:"finished"`
        Output         string                   `json:"output" bson:"output" yaml:"output"`
        OutputChecksum string                   `json:"output_checksum" bson:"output_checksum" yaml:"output_checksum"`
        Display        []map[string]interface{} `json:"display" bson:"display" yaml:"display"`
        Worker         string                   `json:"worker" bson:"worker" yaml:"worker"`
        Number         int                      `json:"number" bson:"number" yaml:"number"`
        Disabled       bool                     `json:"disabled" bson:"disabled" yaml:"disabled"`
        Killed         bool                     `json:"killed" bson:"killed" yaml:"killed"`
        PID            int                      `json:"pid" bson:"pid" yaml:"pid"`
        History        []string                 `json:"history" bson:"history" yaml:"history"`
        Context        map[string]string        `json:"context" bson:"context" yaml:"context"`
}

func CreateState(s *State) error <span class="cov9" title="36">{
        ss, err := GetStateByNames(s.Workflow, s.Task)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting states: %s", err.Error())
        }</span>
        <span class="cov9" title="36">if ss != nil </span><span class="cov5" title="6">{
                return nil
        }</span>

        <span class="cov8" title="30">_, err = mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME].InsertOne(mongodb.Ctx, s)
        return err</span>
}

func DeleteStateByNames(workflow, task string) error <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "task": task}

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no state found with names %s, %s", workflow, task)
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func DeleteStatesByWorkflow(workflow string) error <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow}

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteMany(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.DeletedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no states found with workflow %s", workflow)
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func GetAllStates() ([]*State, error) <span class="cov0" title="0">{
        filter := bson.D{{}}

        states, err := FilterStates(filter)

        return states, err
}</span>

func CopyStatesByNames(workflow, task1, task2 string) error <span class="cov0" title="0">{
        filter1 := bson.M{"workflow": workflow, "task": task1}
        states, err := FilterStates(filter1)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(states) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no state found with names %s, %s", workflow, task1)
        }</span>
        <span class="cov0" title="0">if len(states) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("multiple states found with names %s, %s", workflow, task1)
        }</span>

        <span class="cov0" title="0">filter2 := bson.M{"workflow": workflow, "task": task2}
        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx
        opts := options.Replace().SetUpsert(true)

        _, err = collection.ReplaceOne(ctx, filter2, states[0], opts)

        return err</span>
}

func GetStateByNames(workflow, task string) (*State, error) <span class="cov9" title="36">{
        filter := bson.M{"workflow": workflow, "task": task}

        states, err := FilterStates(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov9" title="36">if len(states) == 0 </span><span class="cov8" title="30">{
                return nil, nil
        }</span>

        <span class="cov5" title="6">if len(states) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple states found with names %s, %s", workflow, task)
        }</span>

        <span class="cov5" title="6">return states[0], nil</span>
}

func GetStateByNamesAndRunID(workflow, task, runID string) (*State, error) <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "task": task}

        states, err := FilterStates(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(states) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if len(states) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple states found with names %s, %s", workflow, task)
        }</span>

        <span class="cov0" title="0">return states[0], nil</span>
}

func GetStateByNamesNumber(workflow, task string, number int) (*State, error) <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "task": task, "number": number}

        states, err := FilterStates(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(states) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no state found with names %s, %s", workflow, task)
        }</span>

        <span class="cov0" title="0">if len(states) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple states found with names %s, %s", workflow, task)
        }</span>

        <span class="cov0" title="0">return states[0], nil</span>
}

func GetStatesByWorkflow(workflow string) ([]*State, error) <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow}

        states, err := FilterStates(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return states, nil</span>
}

func UpdateStateByNames(workflow, task string, s *State) error <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "task": task}

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, s, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.ModifiedCount == 0 </span><span class="cov0" title="0">{
                return CreateState(s)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func UpdateStateKilledByNames(workflow, task string, killed bool) error <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "task": task}

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        update := bson.D{
                {"$set", bson.D{{"killed", killed}}},
        }

        result, err := collection.UpdateOne(ctx, filter, update)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                logger.Tracef("", "no state found with names %s, %s", workflow, task)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func UpdateStateRunByNames(workflow, task string, s State) error <span class="cov0" title="0">{

        ss, err := GetStateByNames(workflow, task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // checksum := md5.Sum([]byte(s.Output))
        // s.OutputChecksum = string(checksum[:])

        <span class="cov0" title="0">ss.Status = s.Status
        ss.Started = s.Started
        ss.Finished = s.Finished
        ss.Output = s.Output
        // ss.OutputChecksum = s.OutputChecksum
        ss.Display = s.Display
        ss.PID = s.PID

        logger.Tracef("", "Updating state by names")

        return UpdateStateByNames(workflow, task, ss)</span>
}

func ClearStateByNames(workflow, task string, runNumber int) error <span class="cov0" title="0">{
        s := &amp;State{
                Task:           task,
                Workflow:       workflow,
                Status:         constants.STATE_STATUS_NOT_STARTED,
                Started:        "",
                Finished:       "",
                Output:         "",
                OutputChecksum: "",
                Number:         runNumber,
                Worker:         "",
                Display:        make([]map[string]interface{}, 0),
        }

        if err := UpdateStateByNames(workflow, task, s); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Cannot update state %s.%s: %s", workflow, task, err.Error())
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GetStatesByWorker(worker string) ([]*State, error) <span class="cov6" title="12">{
        filter := bson.M{"worker": worker}

        states, err := FilterStates(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="12">return states, nil</span>
}

func FilterStates(filter interface{}) ([]*State, error) <span class="cov10" title="48">{
        // A slice of tasks for storing the decoded documents
        var states []*State

        collection := mongodb.Collections[constants.MONGODB_STATE_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return states, err
        }</span>

        <span class="cov10" title="48">for cur.Next(ctx) </span><span class="cov5" title="6">{
                var s State
                err := cur.Decode(&amp;s)
                if err != nil </span><span class="cov0" title="0">{
                        return states, err
                }</span>

                <span class="cov5" title="6">states = append(states, &amp;s)</span>
        }

        <span class="cov10" title="48">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return states, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov10" title="48">cur.Close(ctx)

        return states, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package task

import (
        "fmt"
        "scaffold/server/constants"
        "scaffold/server/state"
        "time"

        logger "github.com/jfcarter2358/go-logger"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"

        "scaffold/server/mongodb"
)

type TaskDependsOn struct {
        Success []string `json:"success" bson:"success" yaml:"success"`
        Error   []string `json:"error" bson:"error" yaml:"error"`
        Always  []string `json:"always" bson:"always" yaml:"always"`
}

type TaskLoadStore struct {
        Env            []string `json:"env" bson:"env" yaml:"env"`
        File           []string `json:"file" bson:"file" yaml:"file"`
        EnvPassthrough []string `json:"env_passthrough" bson:"env_passthrough" yaml:"env_passthrough"`
        Mounts         []string `json:"mounts" bson:"mounts" yaml:"mounts"`
}

type TaskCheck struct {
        Cron      string            `json:"cron" bson:"cron" yaml:"cron"`
        Image     string            `json:"image" bson:"image" yaml:"image"`
        Run       string            `json:"run" bson:"run" yaml:"run"`
        Store     TaskLoadStore     `json:"store" bson:"store" yaml:"store"`
        Load      TaskLoadStore     `json:"load" bson:"load" yaml:"load"`
        Env       map[string]string `json:"env" bson:"env" yaml:"env"`
        Inputs    map[string]string `json:"inputs" bson:"inputs" yaml:"inputs"`
        Updated   string            `json:"updated" bson:"updated" yaml:"updated"`
        RunNumber int               `json:"run_number" bson:"run_number" yaml:"run_number"`
}

type Task struct {
        Name        string            `json:"name" bson:"name" yaml:"name"`
        Kind        string            `json:"kind" bson:"kind" yaml:"kind"`
        Cron        string            `json:"cron" bson:"cron" yaml:"cron"`
        Workflow    string            `json:"workflow" bson:"workflow" yaml:"workflow"`
        DependsOn   TaskDependsOn     `json:"depends_on" bson:"depends_on" yaml:"depends_on"`
        Image       string            `json:"image" bson:"image" yaml:"image"`
        Run         string            `json:"run" bson:"run" yaml:"run"`
        Store       TaskLoadStore     `json:"store" bson:"store" yaml:"store"`
        Load        TaskLoadStore     `json:"load" bson:"load" yaml:"load"`
        Env         map[string]string `json:"env" bson:"env" yaml:"env"`
        Inputs      map[string]string `json:"inputs" bson:"inputs" yaml:"inputs"`
        Updated     string            `json:"updated" bson:"updated" yaml:"updated"`
        RunNumber   int               `json:"run_number" bson:"run_number" yaml:"run_number"`
        ShouldRM    bool              `json:"should_rm" bson:"should_rm" yaml:"should_rm"`
        AutoExecute bool              `json:"auto_execute" bson:"auto_execute" yaml:"auto_execute"`
        Disabled    bool              `json:"disabled" bson:"disabled" yaml:"disabled"`
        // Check                 TaskCheck         `json:"check" bson:"check" yaml:"check"`
        ContainerLoginCommand string `json:"container_login_command" bson:"container_login_command" yaml:"container_login_command"`
}

func CreateTask(t *Task) error <span class="cov8" title="36">{
        tt, err := GetTaskByNames(t.Workflow, t.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting tasks: %s", err.Error())
        }</span>
        <span class="cov8" title="36">if tt != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("task already exists with names %s, %s", t.Workflow, t.Name)
        }</span>

        <span class="cov8" title="36">if t.Kind == "" </span><span class="cov8" title="36">{
                t.Kind = constants.TASK_KIND_LOCAL
        }</span>

        <span class="cov8" title="36">s := state.State{
                Task:     t.Name,
                Workflow: t.Workflow,
                Status:   constants.STATE_STATUS_NOT_STARTED,
                Started:  "",
                Finished: "",
                Output:   "",
                Number:   t.RunNumber,
                Display:  make([]map[string]interface{}, 0),
                Killed:   false,
                History:  make([]string, 0),
                Context:  map[string]string{},
        }
        if err := state.CreateState(&amp;s); err != nil </span><span class="cov0" title="0">{
                logger.Warnf("", "Error creating state for task: %s", err.Error())
        }</span>

        <span class="cov8" title="36">_, err = mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME].InsertOne(mongodb.Ctx, t)
        return err</span>
}

func DeleteTaskByNames(workflow, task string) error <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "name": task}

        collection := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no task found with names %s, %s", workflow, task)
        }</span>

        <span class="cov0" title="0">return nil</span>

}

func DeleteTasksByWorkflow(workflow string) error <span class="cov4" title="6">{
        filter := bson.M{"workflow": workflow}

        collection := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteMany(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="6">if result.DeletedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no tasks found with workflow %s", workflow)
        }</span>

        <span class="cov4" title="6">return nil</span>

}

func GetAllTasks() ([]*Task, error) <span class="cov8" title="33">{
        filter := bson.D{{}}

        tasks, err := FilterTasks(filter)

        return tasks, err
}</span>

func GetTaskByNames(workflow, task string) (*Task, error) <span class="cov8" title="36">{
        filter := bson.M{"workflow": workflow, "name": task}

        tasks, err := FilterTasks(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="36">if len(tasks) == 0 </span><span class="cov8" title="36">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if len(tasks) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple tasks found with names %s, %s", workflow, task)
        }</span>

        <span class="cov0" title="0">return tasks[0], nil</span>
}

func GetTasksByWorkflow(workflow string) ([]*Task, error) <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow}

        tasks, err := FilterTasks(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tasks, nil</span>
}

func UpdateTaskByNames(workflow, task string, t *Task) error <span class="cov0" title="0">{
        filter := bson.M{"workflow": workflow, "name": task}
        currentTime := time.Now().UTC()
        t.Updated = currentTime.Format("2006-01-02T15:04:05Z")
        t.Workflow = workflow

        logger.Debugf("", "Updating task %v", *t)

        collection := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, t, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return CreateTask(t)
                // return fmt.Errorf("no task found with names %s, %s", workflow, task)
        }</span>

        <span class="cov0" title="0">logger.Debugf("", "Update result: %v", result)

        return nil</span>
}

func FilterTasks(filter interface{}) ([]*Task, error) <span class="cov10" title="69">{
        // A slice of tasks for storing the decoded documents
        var tasks []*Task

        collection := mongodb.Collections[constants.MONGODB_TASK_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return tasks, err
        }</span>

        <span class="cov10" title="69">for cur.Next(ctx) </span><span class="cov4" title="6">{
                var s Task
                err := cur.Decode(&amp;s)
                if err != nil </span><span class="cov0" title="0">{
                        return tasks, err
                }</span>

                <span class="cov4" title="6">tasks = append(tasks, &amp;s)</span>
        }

        <span class="cov10" title="69">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return tasks, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov10" title="69">cur.Close(ctx)

        return tasks, nil</span>
}

func VerifyDepends(cn, tn string) (bool, error) <span class="cov0" title="0">{
        t, err := GetTaskByNames(cn, tn)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">for _, n := range t.DependsOn.Success </span><span class="cov0" title="0">{
                s, err := state.GetStateByNames(cn, n)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_SUCCESS </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">for _, n := range t.DependsOn.Error </span><span class="cov0" title="0">{
                s, err := state.GetStateByNames(cn, n)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_ERROR </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package user

import (
        "fmt"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/utils"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo/options"
        "golang.org/x/crypto/bcrypt"

        "scaffold/server/mongodb"

        logger "github.com/jfcarter2358/go-logger"
)

type User struct {
        Username          string     `json:"username" bson:"username" yaml:"username"`
        Password          string     `json:"password" bson:"password" yaml:"password"`
        GivenName         string     `json:"given_name" bson:"given_name" yaml:"given_name"`
        FamilyName        string     `json:"family_name" bson:"family_name" yaml:"family_name"`
        Email             string     `json:"email" bson:"email" yaml:"email"`
        ResetToken        string     `json:"reset_token" bson:"reset_token" yaml:"reset_token"`
        ResetTokenCreated string     `json:"reset_token_created" bson:"reset_token_created" yaml:"reset_token_created"`
        Created           string     `json:"created" bson:"created" yaml:"created"`
        Updated           string     `json:"updated" bson:"updated" yaml:"updated"`
        LoginToken        string     `json:"login_token" bson:"login_token" yaml:"login_token"`
        APITokens         []APIToken `json:"api_tokens" bson:"api_tokens" yaml:"api_tokens"`
        Groups            []string   `json:"groups" bson:"groups" yaml:"groups"`
        Roles             []string   `json:"roles" bson:"roles" yaml:"roles"`
}

type APIToken struct {
        Name    string `json:"name" bson:"name" yaml:"name"`
        Token   string `json:"token" bson:"token" yaml:"token"`
        Created string `json:"created" bson:"created" yaml:"created"`
}

func CreateUser(u *User) error <span class="cov7" title="11">{
        currentTime := time.Now().UTC()
        u.Created = currentTime.Format("2006-01-02T15:04:05Z")
        u.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        uu, err := GetUserByUsername(u.Username)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting users: %s", err.Error())
        }</span>
        <span class="cov7" title="11">if uu != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user already exists with username %s", u.Username)
        }</span>

        <span class="cov7" title="11">password, err := HashAndSalt([]byte(u.Password))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="11">u.Password = password

        _, err = mongodb.Collections[constants.MONGODB_USER_COLLECTION_NAME].InsertOne(mongodb.Ctx, u)
        return err</span>
}

func DeleteUserByUsername(username string) error <span class="cov6" title="9">{
        filter := bson.M{"username": username}

        collection := mongodb.Collections[constants.MONGODB_USER_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="9">if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("no user found with username %s", username)
        }</span>

        <span class="cov6" title="9">return nil</span>

}

func GetAllUsers() ([]*User, error) <span class="cov8" title="17">{
        filter := bson.D{{}}

        users, err := FilterUsers(filter)

        return users, err
}</span>

func GetUserByUsername(username string) (*User, error) <span class="cov8" title="16">{
        filter := bson.M{"username": username}

        allUsers, err := GetAllUsers()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Unable to get all users")
                return nil, err
        }</span>
        <span class="cov8" title="16">logger.Debugf("", "All users: %v", allUsers)

        logger.Debugf("", "Searching for username %s with filter %v", username, filter)

        users, err := FilterUsers(filter)

        logger.Debugf("", "Got users: %v", users)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="16">if len(users) == 0 </span><span class="cov7" title="12">{
                return nil, nil
        }</span>

        <span class="cov4" title="4">if len(users) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple users found with username %s", username)
        }</span>

        <span class="cov4" title="4">return users[0], nil</span>
}

func GetUserByAPIToken(apiToken string) (*User, error) <span class="cov0" title="0">{
        // filter := bson.M{"api_tokens": bson.M{"token": apiToken}}

        filter := bson.D{{}}
        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, u := range users </span><span class="cov0" title="0">{
                for _, t := range u.APITokens </span><span class="cov0" title="0">{
                        if err := bcrypt.CompareHashAndPassword([]byte(t.Token), []byte(apiToken)); err == nil </span><span class="cov0" title="0">{
                                return u, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no user found with api token %s", apiToken)</span>
}

func GetUserByEmail(email string) (*User, error) <span class="cov0" title="0">{
        filter := bson.M{"email": email}

        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no user found with email %s", email)
        }</span>

        <span class="cov0" title="0">if len(users) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple users found with email %s", email)
        }</span>

        <span class="cov0" title="0">return users[0], nil</span>
}

func GetUserByLoginToken(loginToken string) (*User, error) <span class="cov0" title="0">{
        /*
                if loginToken == "" {
                        return nil, fmt.Errorf("invalid login token")
                }

                filter := bson.M{"login_token": loginToken}

                users, err := FilterUsers(filter)

                if err != nil {
                        return nil, err
                }

                if len(users) == 0 {
                        return nil, fmt.Errorf("no user found with login token %s", loginToken)
                }

                if len(users) &gt; 1 {
                        return nil, fmt.Errorf("multiple users found with login token %s", loginToken)
                }

                return users[0], nil
        */

        filter := bson.D{{}}
        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, u := range users </span><span class="cov0" title="0">{
                if err := bcrypt.CompareHashAndPassword([]byte(u.LoginToken), []byte(loginToken)); err == nil </span><span class="cov0" title="0">{
                        return u, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no user found with login token %s", loginToken)</span>
}

func GetUserByResetToken(resetToken string) (*User, error) <span class="cov0" title="0">{
        /*
                filter := bson.M{"reset_token": resetToken}

                users, err := FilterUsers(filter)

                if err != nil {
                        return nil, err
                }

                if len(users) == 0 {
                        return nil, fmt.Errorf("no user found with reset_token %s", resetToken)
                }

                if len(users) &gt; 1 {
                        return nil, fmt.Errorf("multiple users found with reset_token %s", resetToken)
                }

                return users[0], nil
        */

        filter := bson.D{{}}
        users, err := FilterUsers(filter)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, u := range users </span><span class="cov0" title="0">{
                if err := bcrypt.CompareHashAndPassword([]byte(u.ResetToken), []byte(resetToken)); err == nil </span><span class="cov0" title="0">{
                        return u, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no user found with reset token %s", resetToken)</span>
}

func GenerateAPIToken(username, name string) (string, error) <span class="cov0" title="0">{
        token := utils.GenerateToken(32)
        currentTime := time.Now().UTC()

        hashedToken, err := HashAndSalt([]byte(token))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">apiToken := APIToken{
                Name:    name,
                Token:   hashedToken,
                Created: currentTime.Format("2006-01-02T15:04:05Z"),
        }

        u, err := GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">u.APITokens = append(u.APITokens, apiToken)

        err = UpdateUserByUsername(username, u)
        return token, err</span>
}

func RevokeAPIToken(username, name string) error <span class="cov0" title="0">{
        u, err := GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for idx, apiToken := range u.APITokens </span><span class="cov0" title="0">{
                if apiToken.Name == name </span><span class="cov0" title="0">{
                        u.APITokens = append(u.APITokens[:idx], u.APITokens[idx+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">err = UpdateUserByUsername(username, u)
        return err</span>
}

func UpdateUserByUsername(username string, u *User) error <span class="cov1" title="1">{
        filter := bson.M{"username": username}

        currentTime := time.Now().UTC()
        u.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        collection := mongodb.Collections[constants.MONGODB_USER_COLLECTION_NAME]
        ctx := mongodb.Ctx

        opts := options.Replace().SetUpsert(true)

        result, err := collection.ReplaceOne(ctx, filter, u, opts)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if result.ModifiedCount != 1 </span><span class="cov0" title="0">{
                return CreateUser(u)
                // return fmt.Errorf("no user found with username %s", username)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func FilterUsers(filter interface{}) ([]*User, error) <span class="cov10" title="33">{
        // A slice of tasks for storing the decoded documents
        var users []*User

        collection := mongodb.Collections[constants.MONGODB_USER_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return users, err
        }</span>

        <span class="cov10" title="33">for cur.Next(ctx) </span><span class="cov9" title="24">{
                var u User
                err := cur.Decode(&amp;u)
                if err != nil </span><span class="cov0" title="0">{
                        return users, err
                }</span>
                <span class="cov9" title="24">logger.Tracef("", "Found user: %s", u.Username)

                users = append(users, &amp;u)</span>
        }

        <span class="cov10" title="33">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return users, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov10" title="33">cur.Close(ctx)

        return users, nil</span>
}

func VerifyAdmin() error <span class="cov1" title="1">{
        user, _ := GetUserByUsername(config.Config.Admin.Username)

        logger.Debugf("", "No user found for admin")
        if user != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov1" title="1">u := &amp;User{
                Username:          config.Config.Admin.Username,
                Password:          config.Config.Admin.Password,
                GivenName:         "admin",
                FamilyName:        "admin",
                Email:             config.Config.Admin.Email,
                ResetToken:        "",
                ResetTokenCreated: "",
                LoginToken:        "",
                APITokens:         []APIToken{},
                Groups:            []string{"admin"},
                Roles:             []string{"admin"},
        }

        logger.Infof("", "Creating admin user")

        err := CreateUser(u)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Could not create admin user: %s", err.Error())
        }</span>

        <span class="cov1" title="1">return err</span>
}

func HashAndSalt(pwd []byte) (string, error) <span class="cov7" title="11">{
        hash, err := bcrypt.GenerateFromPassword(pwd, bcrypt.MinCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov7" title="11">return string(hash), nil</span>
}

func VerifyUser(username, password string) (bool, error) <span class="cov0" title="0">{
        u, err := GetUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if u == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("no user found that matches credentials")
        }</span>

        <span class="cov0" title="0">err = bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// utils.go

package utils

import (
        "log"
        "math/rand"
        "os/exec"
        "strconv"

        logger "github.com/jfcarter2358/go-logger"

        "github.com/gin-gonic/gin"
)

func Error(err error, c *gin.Context, statusCode int) <span class="cov0" title="0">{
        logger.Error("", err.Error())
        c.JSON(statusCode, gin.H{"error": err.Error()})
}</span>

func Contains(s []string, e string) bool <span class="cov0" title="0">{
        for _, a := range s </span><span class="cov0" title="0">{
                if a == e </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func ContainsInt(s []int, e int) bool <span class="cov0" title="0">{
        for _, a := range s </span><span class="cov0" title="0">{
                if a == e </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func Remove(l []string, item string) []string <span class="cov0" title="0">{
        for i, other := range l </span><span class="cov0" title="0">{
                if other == item </span><span class="cov0" title="0">{
                        return append(l[:i], l[i+1:]...)
                }</span>
        }
        <span class="cov0" title="0">return l</span>
}

func Keys(m map[string]string) []string <span class="cov0" title="0">{
        keys := make([]string, len(m))

        i := 0
        for k := range m </span><span class="cov0" title="0">{
                keys[i] = k
                i++
        }</span>
        <span class="cov0" title="0">return keys</span>
}

func RemoveDuplicateValues(stringSlice []string) []string <span class="cov0" title="0">{
        keys := make(map[string]bool)
        list := []string{}

        // If the key(values of the slice) is not equal
        // to the already present value in new slice (list)
        // then we append it. else we jump on another element.
        for _, entry := range stringSlice </span><span class="cov0" title="0">{
                if _, value := keys[entry]; !value </span><span class="cov0" title="0">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov0" title="0">return list</span>
}

func InstallPackages(packages []string) error <span class="cov0" title="0">{
        out, err := exec.Command("apt-get", "update", "-y").CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("apt-get update: %v", string(out))
                return err
        }</span>
        <span class="cov0" title="0">for _, pkg := range packages </span><span class="cov0" title="0">{
                out, err := exec.Command("apt-get", "install", "-y", pkg).CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("apt-get install %s: %s", pkg, string(out))
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func GenerateToken(length int) string <span class="cov0" title="0">{
        token := strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16) + strconv.FormatInt(rand.Int63(), 16)

        token = token[:length]
        return token
}</span>

func DynamicAPIResponse(ctx *gin.Context, redirect string, status int, response gin.H) <span class="cov0" title="0">{
        _, err := ctx.Cookie("scaffold_token")
        if err == nil </span><span class="cov0" title="0">{
                logger.Debugf("", "Redirecting to %s", redirect)
                ctx.Redirect(302, redirect)
                return
        }</span>
        <span class="cov0" title="0">ctx.JSON(status, response)</span>
}

func MergeDict(a, b map[string]string) map[string]string <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                a = make(map[string]string)
        }</span>
        <span class="cov0" title="0">if b == nil </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">for key, val := range b </span><span class="cov0" title="0">{
                a[key] = val
        }</span>
        <span class="cov0" title="0">return a</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package worker

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "scaffold/server/auth"
        "scaffold/server/config"
        "scaffold/server/constants"
        "scaffold/server/health"
        "scaffold/server/msg"
        "scaffold/server/run"
        "scaffold/server/state"
        "scaffold/server/task"
        "time"

        "github.com/google/uuid"
        logger "github.com/jfcarter2358/go-logger"
)

var RunQueue []run.Run
var startTime int64

var JoinKey = ""
var PrimaryKey = ""
var ID = ""
var isRunning = false

func Run() <span class="cov1" title="1">{
        startTime = time.Now().UTC().Unix()

        ID = uuid.New().String()

        go EnsureManagerConnection()

        health.IsHealthy = true
        if config.Config.RestartPeriod &gt; 0 </span><span class="cov1" title="1">{
                for </span><span class="cov10" title="22">{
                        if !isRunning </span><span class="cov10" title="22">{
                                now := time.Now().UTC().Unix()
                                if now-startTime &gt; int64(config.Config.RestartPeriod) </span><span class="cov0" title="0">{
                                        os.Exit(0)
                                }</span>
                                <span class="cov10" title="22">time.Sleep(500 * time.Millisecond)</span>
                        }
                }
        }
}

func JoinManager() error <span class="cov1" title="1">{
        JoinKey = config.Config.Node.JoinKey
        PrimaryKey = config.Config.Node.PrimaryKey

        obj := auth.NodeJoinObject{
                Name:     ID,
                Host:     config.Config.Host,
                Port:     config.Config.Port,
                WSPort:   config.Config.WSPort,
                Protocol: config.Config.Protocol,
                JoinKey:  JoinKey,
                Version:  constants.VERSION,
        }
        postBody, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov1" title="1">postBodyBuffer := bytes.NewBuffer(postBody)

        httpClient := http.Client{}
        requestURL := fmt.Sprintf("%s://%s:%d/auth/join", config.Config.Node.ManagerProtocol, config.Config.Node.ManagerHost, config.Config.Node.ManagerPort)
        req, _ := http.NewRequest("POST", requestURL, postBodyBuffer)
        req.Header.Set("Content-Type", "application/json")
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return fmt.Errorf("received join status code %d", resp.StatusCode)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func CheckManagerHealth() error <span class="cov0" title="0">{
        queryURL := fmt.Sprintf("%s://%s:%d/health/ready", config.Config.Node.ManagerProtocol, config.Config.Node.ManagerHost, config.Config.Node.ManagerPort)
        resp, err := http.Get(queryURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to reach manager, response code: %d", resp.StatusCode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func DoPing() int <span class="cov7" title="11">{
        httpClient := &amp;http.Client{}
        requestURL := fmt.Sprintf("%s://%s:%d/health/ping/%s", config.Config.Node.ManagerProtocol, config.Config.Node.ManagerHost, config.Config.Node.ManagerPort, ID)
        req, _ := http.NewRequest("POST", requestURL, nil)
        req.Header.Set("Authorization", fmt.Sprintf("X-Scaffold-API %s", PrimaryKey))
        req.Header.Set("Content-Type", "application/json")
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "manager ping returned error %s", err.Error())
                return -1
        }</span>
        <span class="cov7" title="11">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return resp.StatusCode
        }</span>
        <span class="cov7" title="11">return 0</span>
}

func EnsureManagerConnection() <span class="cov1" title="1">{
        err := JoinManager()
        health.IsReady = false
        for err != nil </span><span class="cov0" title="0">{
                time.Sleep(time.Duration(config.Config.HeartbeatInterval) * time.Millisecond)
                err = JoinManager()
        }</span>
        <span class="cov1" title="1">health.IsReady = true
        for </span><span class="cov7" title="11">{
                rc := DoPing()
                if rc == http.StatusUnauthorized </span><span class="cov0" title="0">{
                        err := JoinManager()
                        health.IsReady = false
                        for err != nil </span><span class="cov0" title="0">{
                                health.IsReady = true
                                time.Sleep(time.Duration(config.Config.HeartbeatInterval) * time.Millisecond)
                                err = JoinManager()
                        }</span>
                }
                <span class="cov7" title="11">time.Sleep(time.Duration(config.Config.HeartbeatInterval) * time.Millisecond)</span>
        }
}

func QueueDataReceive(data []byte) error <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">isRunning = true

        var m msg.TriggerMsg

        if err := json.Unmarshal(data, &amp;m); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "Error processing queue message: %s", err.Error())
                isRunning = false
                return err
        }</span>

        <span class="cov0" title="0">logger.Debugf("", "Action object: %v", m)

        switch m.Action </span>{
        case constants.ACTION_TRIGGER:<span class="cov0" title="0">
                t, err := task.GetTaskByNames(m.Workflow, m.Task)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("", "Error getting task %s.%s: %s", m.Workflow, m.Task, err.Error())
                        isRunning = false
                        return err
                }</span>

                <span class="cov0" title="0">r := run.Run{
                        Name:   uuid.New().String(),
                        Task:   *t,
                        Number: m.Number,
                        Groups: m.Groups,
                        RunID:  m.RunID,
                        State: state.State{
                                Task:     m.Task,
                                Workflow: m.Workflow,
                                Status:   constants.STATE_STATUS_WAITING,
                                Started:  "",
                                Finished: "",
                                Output:   "",
                                Number:   m.Number,
                                Worker:   ID,
                                Display:  make([]map[string]interface{}, 0),
                                Context:  m.Context,
                        },
                        Worker:  ID,
                        Context: m.Context,
                }

                if t.Kind == constants.TASK_KIND_CONTAINER </span><span class="cov0" title="0">{
                        // run.ContainerKill(m.Workflow, m.Task)

                        for </span><span class="cov0" title="0">{
                                s, err := state.GetStateByNames(m.Workflow, m.Task)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_RUNNING </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">time.Sleep(time.Duration(config.Config.CheckInterval) * time.Millisecond)</span>
                        }

                        <span class="cov0" title="0">shouldRestart, _ := run.StartContainerRun(&amp;r)
                        for shouldRestart </span><span class="cov0" title="0">{
                                shouldRestart, _ = run.StartContainerRun(&amp;r)
                        }</span>
                }
                <span class="cov0" title="0">if t.Kind == constants.TASK_KIND_LOCAL </span><span class="cov0" title="0">{
                        // run.LocalKill(m.Workflow, m.Task)

                        for </span><span class="cov0" title="0">{
                                s, err := state.GetStateByNames(m.Workflow, m.Task)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if s.Status != constants.STATE_STATUS_RUNNING </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">time.Sleep(time.Duration(config.Config.CheckInterval) * time.Millisecond)</span>
                        }

                        <span class="cov0" title="0">shouldRestart, _ := run.StartLocalRun(&amp;r)
                        for shouldRestart </span><span class="cov0" title="0">{
                                shouldRestart, _ = run.StartLocalRun(&amp;r)
                        }</span>
                }

                <span class="cov0" title="0">logger.Debugf("", "Run finished")</span>
        }

        <span class="cov0" title="0">isRunning = false
        return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package workflow

import (
        "fmt"
        "scaffold/server/constants"
        "scaffold/server/datastore"
        "scaffold/server/input"
        "scaffold/server/task"
        "sync"
        "time"

        logger "github.com/jfcarter2358/go-logger"

        "go.mongodb.org/mongo-driver/bson"

        "scaffold/server/mongodb"
)

type Workflow struct {
        Version string            `json:"version" bson:"version" yaml:"version"`
        Name    string            `json:"name" bson:"name" yaml:"name"`
        Inputs  []input.Input     `json:"inputs" bson:"inputs" yaml:"inputs"`
        Tasks   []task.Task       `json:"tasks" bson:"tasks" yaml:"tasks"`
        Created string            `json:"created" bson:"created" yaml:"created"`
        Updated string            `json:"updated" bson:"updated" yaml:"updated"`
        Groups  []string          `json:"groups" bson:"groups" yaml:"groups"`
        Links   map[string]string `json:"links" bson:"links" yaml:"links"`
}

type cacheObj struct {
        Workflows map[string]Workflow
        Lock      *sync.RWMutex
}

var cache = cacheObj{
        Workflows: make(map[string]Workflow),
        Lock:      &amp;sync.RWMutex{},
}

func SetCache(ws []*Workflow) <span class="cov1" title="1">{
        cache.Lock.Lock()
        defer cache.Lock.Unlock()

        for _, w := range ws </span><span class="cov0" title="0">{
                cache.Workflows[w.Name] = *w
        }</span>
}

func AddCache(w Workflow) <span class="cov5" title="6">{
        cache.Lock.Lock()
        defer cache.Lock.Unlock()

        cache.Workflows[w.Name] = w
}</span>

func DeleteCache(name string) <span class="cov5" title="6">{
        cache.Lock.Lock()
        defer cache.Lock.Unlock()

        delete(cache.Workflows, name)
}</span>

func GetCacheAll() map[string]Workflow <span class="cov0" title="0">{
        cache.Lock.Lock()
        defer cache.Lock.Unlock()

        return cache.Workflows
}</span>

func GetCacheSingle(name string) Workflow <span class="cov0" title="0">{
        cache.Lock.Lock()
        defer cache.Lock.Unlock()

        if w, ok := cache.Workflows[name]; ok </span><span class="cov0" title="0">{
                return w
        }</span>
        <span class="cov0" title="0">return Workflow{}</span>
}

func CreateWorkflow(w *Workflow) error <span class="cov5" title="6">{
        currentTime := time.Now().UTC()
        w.Created = currentTime.Format("2006-01-02T15:04:05Z")
        w.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        ww, err := GetWorkflowByName(w.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting workflows: %s", err.Error())
        }</span>
        <span class="cov5" title="6">if ww != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("workflow already exists with name %s", w.Name)
        }</span>

        <span class="cov5" title="6">_, err = mongodb.Collections[constants.MONGODB_WORKFLOW_COLLECTION_NAME].InsertOne(mongodb.Ctx, w)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="6">for _, t := range w.Tasks </span><span class="cov10" title="36">{
                t.Workflow = w.Name
                t.RunNumber = 0
                if err := task.CreateTask(&amp;t); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="6">for _, i := range w.Inputs </span><span class="cov7" title="12">{
                i.Workflow = w.Name
                if err := input.CreateInput(&amp;i); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov5" title="6">d := &amp;datastore.DataStore{
                Name:    w.Name,
                Env:     make(map[string]string),
                Files:   make([]string, 0),
                Created: w.Created,
                Updated: w.Updated,
        }

        for _, val := range w.Inputs </span><span class="cov7" title="12">{
                d.Env[val.Name] = val.Default
        }</span>

        <span class="cov5" title="6">err = datastore.CreateDataStore(d)

        if err == nil </span><span class="cov5" title="6">{
                AddCache(*w)
        }</span>
        <span class="cov5" title="6">return err</span>
}

func DeleteWorkflowByName(name string) error <span class="cov5" title="6">{
        filter := bson.M{"name": name}

        collection := mongodb.Collections[constants.MONGODB_WORKFLOW_COLLECTION_NAME]
        ctx := mongodb.Ctx

        result, err := collection.DeleteOne(ctx, filter)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="6">DeleteCache(name)

        if result.DeletedCount != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to delete workflow %s, doesn't exist", name)
        }</span>

        <span class="cov5" title="6">if err := task.DeleteTasksByWorkflow(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="6">if err := input.DeleteInputsByWorkflow(name); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="6">err = datastore.DeleteDataStoreByWorkflow(name)

        return err</span>

}

func GetAllWorkflows() ([]*Workflow, error) <span class="cov2" title="2">{
        filter := bson.M{}

        workflows, err := FilterWorkflows(filter)

        return workflows, err
}</span>

func GetWorkflowByName(name string) (*Workflow, error) <span class="cov8" title="18">{
        filter := bson.M{"name": name}

        workflows, err := FilterWorkflows(filter)

        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("", "filter workflows returned error %s", err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="18">if len(workflows) == 0 </span><span class="cov5" title="6">{
                return nil, nil
        }</span>

        <span class="cov7" title="12">if len(workflows) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("multiple workflows found with name %s", name)
        }</span>

        <span class="cov7" title="12">return workflows[0], nil</span>
}

func UpdateWorkflowByName(name string, w *Workflow) error <span class="cov1" title="1">{
        // filter := bson.M{"name": name}

        // currentTime := time.Now().UTC()
        // w.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        // collection := mongodb.Collections[constants.MONGODB_WORKFLOW_COLLECTION_NAME]
        // ctx := mongodb.Ctx

        // opts := options.Replace().SetUpsert(true)

        // states, err := state.GetStatesByWorkflow(name)
        // if err != nil {
        //         return err
        // }
        // tasks, err := task.GetTasksByWorkflow(name)
        // if err != nil {
        //         return nil
        // }

        // result, err := collection.ReplaceOne(ctx, filter, w, opts)

        // if err != nil {
        //         return err
        // }

        // if result.ModifiedCount != 1 {
        //         AddCache(*w)
        //         return CreateWorkflow(w)
        //         // return fmt.Errorf("no workflow found with name %s", name)
        // }

        // AddCache(*w)

        // taskNames := make([]string, len(states))

        // for idx, t := range tasks {
        //         taskNames[idx] = t.Name
        // }

        // newNames := make([]string, len(w.Tasks))

        // for idx, t := range w.Tasks {
        //         if !utils.Contains(taskNames, t.Name) {
        //                 t.Workflow = name
        //                 logger.Debugf("", "Creating task %s with workflow %s", t.Name, t.Workflow)
        //                 if err := task.CreateTask(&amp;t); err != nil {
        //                         return err
        //                 }
        //                 continue
        //         }
        //         logger.Debugf("", "Updating task %s with workflow %s", t.Name, name)
        //         if err := task.UpdateTaskByNames(name, t.Name, &amp;t); err != nil {
        //                 return err
        //         }
        //         newNames[idx] = t.Name
        // }

        // logger.Debugf("", "Old tasks: %v", taskNames)
        // logger.Debugf("", "New tasks: %v", newNames)

        // for _, t := range tasks {
        //         if !utils.Contains(newNames, t.Name) {
        //                 logger.Debugf("", "Removing task %s", t.Name)
        //                 if err := task.DeleteTaskByNames(name, t.Name); err != nil {
        //                         return err
        //                 }
        //         }
        // }

        // return err

        // filter := bson.M{"name": name}
        // currentTime := time.Now().UTC()
        // w.Updated = currentTime.Format("2006-01-02T15:04:05Z")

        // logger.Debugf("", "Updating workflow %v", *w)

        // collection := mongodb.Collections[constants.MONGODB_WORKFLOW_COLLECTION_NAME]
        // ctx := mongodb.Ctx

        // opts := options.Replace().SetUpsert(true)

        // result, err := collection.ReplaceOne(ctx, filter, w, opts)

        // if err != nil {
        //         return err
        // }

        // if result.ModifiedCount != 1 {
        //         return CreateWorkflow(w)
        // }

        // logger.Debugf("", "Update result: %v", result)

        // return nil

        if err := DeleteWorkflowByName(name); err != nil </span><span class="cov0" title="0">{
                logger.Warnf("", "Got error doing workflow update delete: %s", err.Error())
        }</span>
        <span class="cov1" title="1">return CreateWorkflow(w)</span>
}

func FilterWorkflows(filter interface{}) ([]*Workflow, error) <span class="cov8" title="20">{
        // A slice of tasks for storing the decoded documents
        var workflows []*Workflow

        collection := mongodb.Collections[constants.MONGODB_WORKFLOW_COLLECTION_NAME]
        ctx := mongodb.Ctx

        cur, err := collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return workflows, err
        }</span>

        <span class="cov8" title="20">for cur.Next(ctx) </span><span class="cov7" title="13">{
                var c Workflow
                err := cur.Decode(&amp;c)
                if err != nil </span><span class="cov0" title="0">{
                        return workflows, err
                }</span>

                <span class="cov7" title="13">workflows = append(workflows, &amp;c)</span>
        }

        <span class="cov8" title="20">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                return workflows, err
        }</span>

        // once exhausted, close the cursor
        <span class="cov8" title="20">cur.Close(ctx)

        return workflows, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
